WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:00.516 --> 00:00:05.000 A:middle
[音乐]

00:00:07.516 --> 00:00:11.500 A:middle
[掌声]

00:00:12.786 --> 00:00:13.366 A:middle
&gt;&gt; 大家好

00:00:14.736 --> 00:00:15.946 A:middle
我是 Ben 跟我一起的

00:00:15.946 --> 00:00:17.066 A:middle
是我的同事 Doug

00:00:17.066 --> 00:00:19.496 A:middle
我们将要跟你们讲讲 Swift 里的 API 设计

00:00:20.326 --> 00:00:21.786 A:middle
那么 在有了关于

00:00:21.786 --> 00:00:24.136 A:middle
二进制和模块稳定性的介绍后

00:00:24.536 --> 00:00:26.096 A:middle
我们感到非常兴奋

00:00:26.096 --> 00:00:27.746 A:middle
这是我们第一次能够介绍框架

00:00:28.126 --> 00:00:29.586 A:middle
这个框架很好地利用

00:00:29.586 --> 00:00:31.176 A:middle
Swift 来提供丰富

00:00:31.436 --> 00:00:33.406 A:middle
有效且便于使用的 API

00:00:33.406 --> 00:00:36.006 A:middle
作为 Apple SDK 的一部分

00:00:36.556 --> 00:00:37.956 A:middle
现在 我们已经知道了

00:00:38.076 --> 00:00:39.566 A:middle
设计这些 API 的一部分内容

00:00:39.566 --> 00:00:40.986 A:middle
也就是我们今天要跟你们聊的

00:00:40.986 --> 00:00:43.116 A:middle
那么 我们将要涉及到

00:00:43.116 --> 00:00:44.746 A:middle
一些基本的概念

00:00:45.606 --> 00:00:47.396 A:middle
并且理解它们是如何影响

00:00:47.396 --> 00:00:48.306 A:middle
你的 API 设计的

00:00:48.746 --> 00:00:49.516 A:middle
然后我们需要

00:00:49.516 --> 00:00:51.066 A:middle
深入了解一些

00:00:51.066 --> 00:00:53.516 A:middle
Swift 5.1 的新功能

00:00:53.516 --> 00:00:54.996 A:middle
来看看它们是如何提供帮助

00:00:54.996 --> 00:00:56.476 A:middle
使你的 API 表现更出色

00:00:57.406 --> 00:00:58.246 A:middle
同时我们也将向

00:00:58.246 --> 00:00:59.976 A:middle
你们展示一些例子

00:00:59.976 --> 00:01:01.486 A:middle
源自我们最新的 Swift 框架

00:01:01.756 --> 00:01:04.686 A:middle
包括 SwiftUI 以及 RealityKit

00:01:06.496 --> 00:01:08.926 A:middle
那么 我们之前已经讲过了 API 设计

00:01:09.116 --> 00:01:11.096 A:middle
尤其在 2016 年我们

00:01:11.096 --> 00:01:13.856 A:middle
介绍了 Swift API 设计指南

00:01:14.546 --> 00:01:15.926 A:middle
你们现在仍可以在

00:01:15.926 --> 00:01:17.106 A:middle
Swift.org 网站对这些进行查看

00:01:17.466 --> 00:01:18.626 A:middle
它们包含了一些

00:01:18.626 --> 00:01:21.076 A:middle
很有用的建议 围绕着如何命名

00:01:21.166 --> 00:01:22.046 A:middle
以及为你的 API 写文档

00:01:22.086 --> 00:01:24.256 A:middle
但是我现在不会重复这些

00:01:24.786 --> 00:01:26.186 A:middle
但是有一点

00:01:26.186 --> 00:01:27.306 A:middle
我们今天需要去解决

00:01:27.306 --> 00:01:30.466 A:middle
这就是

00:01:30.466 --> 00:01:32.406 A:middle
使用时的清晰明确

00:01:32.406 --> 00:01:34.606 A:middle
是作为 API 设计师的最大目标

00:01:35.166 --> 00:01:37.096 A:middle
你想要做到这一点 这样一来

00:01:37.096 --> 00:01:39.116 A:middle
在阅读使用你的 API 的代码时

00:01:39.736 --> 00:01:40.886 A:middle
它所做的就会一目了然

00:01:41.756 --> 00:01:43.506 A:middle
同时 你想要做到这一点

00:01:43.626 --> 00:01:45.146 A:middle
使你的 API 可以得到正确使用

00:01:46.136 --> 00:01:48.696 A:middle
好的命名和可读性

00:01:48.696 --> 00:01:50.016 A:middle
对此至关重要

00:01:50.756 --> 00:01:53.036 A:middle
还有一个新的东西

00:01:53.036 --> 00:01:53.886 A:middle
是关于命名的

00:01:53.886 --> 00:01:55.366 A:middle
就是接下来

00:01:55.366 --> 00:01:57.146 A:middle
我们将不在

00:01:57.146 --> 00:01:59.366 A:middle
我们仅限 Swift 使用的 API

00:01:59.366 --> 00:02:00.986 A:middle
中使用 Swift 类型的前缀

00:02:00.986 --> 00:02:04.136 A:middle
现在 这会为

00:02:04.266 --> 00:02:06.956 A:middle
这些 API 带来更整洁

00:02:07.016 --> 00:02:07.766 A:middle
更可读的体验

00:02:07.766 --> 00:02:11.756 A:middle
目前 在 C 和 Objective-C 语言中我们

00:02:11.756 --> 00:02:13.866 A:middle
不得不使用前缀 因为

00:02:14.026 --> 00:02:15.816 A:middle
每个符号都处在全球

00:02:15.816 --> 00:02:17.546 A:middle
命名空间里 没有一个好的方法

00:02:17.546 --> 00:02:18.346 A:middle
来消除歧义

00:02:19.376 --> 00:02:20.766 A:middle
基于这一原因 Apple

00:02:21.036 --> 00:02:22.966 A:middle
和开发人员必须遵循一套

00:02:22.966 --> 00:02:24.946 A:middle
非常严格的前缀惯例

00:02:25.736 --> 00:02:27.386 A:middle
为了统一 我们将

00:02:27.386 --> 00:02:29.406 A:middle
继续使用前缀

00:02:29.406 --> 00:02:31.536 A:middle
在那些 Swift 版本的 API 同时

00:02:31.536 --> 00:02:33.446 A:middle
在 Objective-C 语言有对应的情况下

00:02:35.516 --> 00:02:37.626 A:middle
但是 Swift 的模块系统

00:02:37.626 --> 00:02:40.106 A:middle
可以消除歧义 通过

00:02:40.106 --> 00:02:41.556 A:middle
在类型前面加上

00:02:41.556 --> 00:02:42.256 A:middle
模块名称

00:02:42.256 --> 00:02:44.046 A:middle
由于这个原因

00:02:44.046 --> 00:02:46.076 A:middle
标准库也从来没有前缀

00:02:46.356 --> 00:02:47.816 A:middle
你们中的很多人已经发现了

00:02:47.876 --> 00:02:48.986 A:middle
你们也可以将其从你们的

00:02:48.986 --> 00:02:49.926 A:middle
Swift 框架上去除

00:02:50.496 --> 00:02:53.886 A:middle
但是请记住

00:02:53.886 --> 00:02:55.326 A:middle
即便如此 你们也需要

00:02:55.326 --> 00:02:56.986 A:middle
小心谨慎一点

00:02:57.996 --> 00:02:59.966 A:middle
一个非常笼统的名称会让

00:02:59.966 --> 00:03:01.776 A:middle
你的用户必须手动

00:03:01.776 --> 00:03:03.336 A:middle
区分产生歧义的状况

00:03:03.336 --> 00:03:04.046 A:middle
一旦有冲突的话

00:03:04.926 --> 00:03:06.846 A:middle
而且请始终记住

00:03:06.846 --> 00:03:07.776 A:middle
使用时的清晰明确

00:03:08.736 --> 00:03:10.266 A:middle
某个特定框架的一个笼统名称

00:03:10.266 --> 00:03:11.856 A:middle
可能看上去会有点儿

00:03:11.856 --> 00:03:13.496 A:middle
让人困惑

00:03:13.536 --> 00:03:14.166 A:middle
当你没有上下文的时候

00:03:14.626 --> 00:03:17.686 A:middle
现在 我们要讲几个主题

00:03:17.686 --> 00:03:19.116 A:middle
值 引用

00:03:19.116 --> 00:03:21.476 A:middle
协议和泛型

00:03:21.926 --> 00:03:23.216 A:middle
这之后我们将要讲到

00:03:23.216 --> 00:03:24.656 A:middle
我们的两个新功能

00:03:24.656 --> 00:03:27.126 A:middle
关键路径成员查找和属性包装器

00:03:28.096 --> 00:03:29.356 A:middle
那么 让我们先来讲一下

00:03:29.356 --> 00:03:30.896 A:middle
值和引用

00:03:31.016 --> 00:03:32.416 A:middle
首先快速回顾一下

00:03:32.666 --> 00:03:34.616 A:middle
Swift 有三个创建类型的基本概念

00:03:34.616 --> 00:03:38.426 A:middle
类 结构和枚举

00:03:39.776 --> 00:03:41.456 A:middle
类是引用类型

00:03:41.456 --> 00:03:42.236 A:middle
那代表着当你有一个变量

00:03:42.236 --> 00:03:44.076 A:middle
它就指向

00:03:44.076 --> 00:03:46.006 A:middle
有着实际值的对象

00:03:46.796 --> 00:03:48.266 A:middle
当你对它进行复制

00:03:48.266 --> 00:03:50.006 A:middle
就是在复制引用

00:03:50.466 --> 00:03:51.726 A:middle
那代表着当你

00:03:51.726 --> 00:03:53.066 A:middle
通过引用改变一个值

00:03:53.066 --> 00:03:55.416 A:middle
你实际上在改变

00:03:55.416 --> 00:03:57.086 A:middle
同一个对象

00:03:57.086 --> 00:03:57.976 A:middle
而两个变量都指向这个对象

00:03:59.436 --> 00:04:00.756 A:middle
所以它们都能看到变化

00:04:01.296 --> 00:04:04.926 A:middle
在另一方面 结构和枚举

00:04:04.926 --> 00:04:06.446 A:middle
是值类型

00:04:06.446 --> 00:04:07.356 A:middle
当你复制它们

00:04:07.476 --> 00:04:09.556 A:middle
就会复制其所有内容

00:04:09.946 --> 00:04:11.196 A:middle
那代表着当你

00:04:11.196 --> 00:04:12.626 A:middle
做出一个改变 你只是在

00:04:12.626 --> 00:04:14.036 A:middle
改变那一个拷贝

00:04:15.086 --> 00:04:16.866 A:middle
现在 在你的 API 里使用值类型

00:04:16.866 --> 00:04:18.416 A:middle
能带来很多好处

00:04:18.486 --> 00:04:20.555 A:middle
在使用的清晰明确方面

00:04:20.995 --> 00:04:21.846 A:middle
如果你知道你每次都在

00:04:21.846 --> 00:04:24.166 A:middle
获得一个全新的 独一无二的拷贝

00:04:24.556 --> 00:04:25.746 A:middle
那么你就不需要担心

00:04:25.746 --> 00:04:27.206 A:middle
值来自哪里

00:04:27.436 --> 00:04:29.006 A:middle
是否有人对其设有引用

00:04:29.006 --> 00:04:30.126 A:middle
或者是在

00:04:30.126 --> 00:04:31.556 A:middle
你不知情的情况下

00:04:31.246 --> 00:04:31.556 A:middle
进行修改

00:04:32.426 --> 00:04:34.426 A:middle
你不需要 比如

00:04:34.426 --> 00:04:36.346 A:middle
做一个防御性的拷贝

00:04:36.346 --> 00:04:37.686 A:middle
现在 有了这个

00:04:37.686 --> 00:04:38.866 A:middle
出现了一个常见问题 就是

00:04:39.066 --> 00:04:40.966 A:middle
我是否应该将引用或者

00:04:40.966 --> 00:04:43.336 A:middle
一个值的类型用于我某一段

00:04:43.336 --> 00:04:43.956 A:middle
特定的代码

00:04:44.276 --> 00:04:45.986 A:middle
而每种使用情况是不同的

00:04:45.986 --> 00:04:47.646 A:middle
所以没有一个硬性规定

00:04:48.036 --> 00:04:49.006 A:middle
但是有一些笼统的指南

00:04:49.006 --> 00:04:50.686 A:middle
也就是总的来说

00:04:50.686 --> 00:04:52.856 A:middle
你应该倾向使用

00:04:52.856 --> 00:04:54.716 A:middle
结构而不是类 除非你

00:04:54.716 --> 00:04:56.496 A:middle
有一个使用类的很好的理由

00:04:57.216 --> 00:04:58.736 A:middle
如果你默认使用一个类

00:04:58.736 --> 00:04:59.996 A:middle
当每次在创建类型时

00:04:59.996 --> 00:05:01.086 A:middle
试着将这一默认从你

00:05:01.086 --> 00:05:02.386 A:middle
运行的代码中移开

00:05:02.386 --> 00:05:02.886 A:middle
看看会怎么样

00:05:03.956 --> 00:05:05.496 A:middle
目前 类

00:05:05.496 --> 00:05:06.896 A:middle
在 Swift 中还很重要

00:05:07.426 --> 00:05:08.956 A:middle
它们很关键 如果你需要

00:05:09.076 --> 00:05:10.786 A:middle
通过引用计数

00:05:10.786 --> 00:05:11.656 A:middle
管理资源

00:05:12.146 --> 00:05:13.316 A:middle
虽然 你可能常常想要将

00:05:13.536 --> 00:05:14.976 A:middle
那个类包含在一个结构里

00:05:14.976 --> 00:05:15.706 A:middle
像我们马上会看到的那样

00:05:16.896 --> 00:05:18.816 A:middle
它们也是有用的结构体

00:05:18.816 --> 00:05:20.316 A:middle
如果有东西需要被基础性地

00:05:20.316 --> 00:05:22.046 A:middle
存储和分享

00:05:22.836 --> 00:05:24.826 A:middle
很重要的一点 如果你的类型

00:05:24.826 --> 00:05:26.046 A:middle
具有标识

00:05:26.196 --> 00:05:28.316 A:middle
标识的概念

00:05:28.316 --> 00:05:29.656 A:middle
与值分离

00:05:30.386 --> 00:05:32.106 A:middle
这通常标记着某个类

00:05:32.106 --> 00:05:33.566 A:middle
是合理的

00:05:34.766 --> 00:05:36.796 A:middle
现在 有时我们

00:05:36.796 --> 00:05:38.806 A:middle
必须进行判断

00:05:38.876 --> 00:05:39.646 A:middle
那就是在 RealityKit

00:05:40.526 --> 00:05:42.506 A:middle
RealityKit 的 API 围绕着

00:05:42.506 --> 00:05:44.016 A:middle
这些称为实体的东西

00:05:44.636 --> 00:05:46.896 A:middle
这些代表着

00:05:46.896 --> 00:05:48.276 A:middle
出现在场景的对象

00:05:48.686 --> 00:05:50.656 A:middle
它们被存储在

00:05:50.656 --> 00:05:52.156 A:middle
RealityKit 引擎的中心

00:05:52.156 --> 00:05:53.356 A:middle
它们具有标识

00:05:54.086 --> 00:05:55.776 A:middle
当你需要操控一个场景

00:05:55.836 --> 00:05:57.956 A:middle
通过改变对象的

00:05:57.956 --> 00:06:00.336 A:middle
外表或者将它们移动

00:06:00.336 --> 00:06:01.946 A:middle
然后你就直接

00:06:01.946 --> 00:06:04.126 A:middle
在那个引擎里操控对象了

00:06:04.546 --> 00:06:05.666 A:middle
你可以把引用类型看作是

00:06:05.666 --> 00:06:08.706 A:middle
把手

00:06:08.706 --> 00:06:11.076 A:middle
可以处理 RealityKit 中的实际对象

00:06:11.556 --> 00:06:13.106 A:middle
所以这对于引用类型来说

00:06:13.106 --> 00:06:13.846 A:middle
有着完美用途

00:06:14.536 --> 00:06:17.446 A:middle
但是 这些实体的属性

00:06:17.446 --> 00:06:19.546 A:middle
比如它们的定位

00:06:19.546 --> 00:06:21.676 A:middle
或综合某一场景中的方向

00:06:21.676 --> 00:06:23.636 A:middle
被建模成为值的类型

00:06:24.396 --> 00:06:25.276 A:middle
现在 让我们来看看它们

00:06:25.276 --> 00:06:26.096 A:middle
在代码里看上去如何

00:06:26.896 --> 00:06:28.416 A:middle
假设我们想在

00:06:28.776 --> 00:06:30.546 A:middle
这里创建场景

00:06:31.146 --> 00:06:33.646 A:middle
那么我们首先要创建一个

00:06:33.646 --> 00:06:34.406 A:middle
material 类型

00:06:34.916 --> 00:06:36.906 A:middle
然后我们在外面创建

00:06:36.906 --> 00:06:38.286 A:middle
两个盒子

00:06:38.416 --> 00:06:39.576 A:middle
然后我们需要把它们

00:06:39.576 --> 00:06:40.426 A:middle
固定在场景中

00:06:41.196 --> 00:06:42.476 A:middle
接下来 一旦完成这个

00:06:42.576 --> 00:06:43.796 A:middle
我们就可以操控场景

00:06:43.836 --> 00:06:45.896 A:middle
通过直接使用代码我们可以

00:06:46.086 --> 00:06:47.486 A:middle
将小一点盒子在

00:06:47.486 --> 00:06:48.286 A:middle
Y 轴上移动

00:06:48.336 --> 00:06:51.426 A:middle
或者将大一点的盒子旋转 45 度

00:06:51.836 --> 00:06:53.096 A:middle
当我们在

00:06:53.096 --> 00:06:54.776 A:middle
这些引用类型上进行这些操作时

00:06:54.776 --> 00:06:56.096 A:middle
我们正在直接

00:06:56.096 --> 00:06:57.296 A:middle
操控场景

00:06:57.296 --> 00:06:59.056 A:middle
这是很直观的

00:07:02.676 --> 00:07:03.786 A:middle
像这里一样 也就是

00:07:03.786 --> 00:07:04.616 A:middle
使得每个盒子都是

00:07:04.616 --> 00:07:05.276 A:middle
不同的颜色

00:07:05.816 --> 00:07:07.006 A:middle
我们会使用的一种方法也许是

00:07:07.046 --> 00:07:10.526 A:middle
是将 material.tintColor 

00:07:10.526 --> 00:07:11.066 A:middle
设置成红色

00:07:11.886 --> 00:07:14.576 A:middle
现在 我会期待什么结果呢

00:07:14.576 --> 00:07:16.056 A:middle
这个 API 的用户在这个时候

00:07:16.056 --> 00:07:16.366 A:middle
会发生什么呢

00:07:17.206 --> 00:07:19.556 A:middle
这两个盒子都要变吗

00:07:19.776 --> 00:07:21.026 A:middle
因为我改变了同时

00:07:21.026 --> 00:07:22.186 A:middle
创建出这两个的变量

00:07:23.066 --> 00:07:24.516 A:middle
或者只要

00:07:24.516 --> 00:07:26.706 A:middle
后创建的盒子会适用

00:07:26.706 --> 00:07:27.396 A:middle
这一新变化

00:07:27.796 --> 00:07:29.526 A:middle
也就是说 material 应该

00:07:29.836 --> 00:07:32.446 A:middle
作为引用类型还是值类型

00:07:33.216 --> 00:07:35.666 A:middle
这两个中的任一模型都有可能

00:07:35.736 --> 00:07:37.166 A:middle
成为一个 API 的合理设计

00:07:37.166 --> 00:07:39.636 A:middle
虽然 在这里使用

00:07:39.636 --> 00:07:40.766 A:middle
值类型的好处在于 如果

00:07:40.766 --> 00:07:41.966 A:middle
在你的代码里有一段很长的距离

00:07:42.036 --> 00:07:43.776 A:middle
在你一开始

00:07:43.776 --> 00:07:45.176 A:middle
创建和使用 material

00:07:45.176 --> 00:07:46.666 A:middle
类型并进行更改之间

00:07:47.226 --> 00:07:48.536 A:middle
然后你忘记自己

00:07:48.536 --> 00:07:49.526 A:middle
之前使用过它

00:07:49.526 --> 00:07:50.976 A:middle
最后你可能更改了

00:07:50.976 --> 00:07:51.816 A:middle
一部分场景

00:07:51.816 --> 00:07:52.766 A:middle
而你并不想这么做

00:07:53.596 --> 00:07:54.726 A:middle
基于这一理由

00:07:54.726 --> 00:07:56.086 A:middle
RealityKit 选择将

00:07:56.116 --> 00:07:57.946 A:middle
material 作为一个值类型

00:07:58.926 --> 00:08:00.316 A:middle
但是引用语义

00:08:00.316 --> 00:08:01.956 A:middle
对于其他 API 来说也合理

00:08:01.956 --> 00:08:03.246 A:middle
就如我们在实体中看到的一样

00:08:04.236 --> 00:08:06.666 A:middle
重要的一点在于你的

00:08:06.666 --> 00:08:09.906 A:middle
API 有一个容易解释的模型

00:08:10.066 --> 00:08:12.536 A:middle
解释事物如何以及为何运作

00:08:13.246 --> 00:08:16.006 A:middle
最重要的一点是 

00:08:16.006 --> 00:08:17.636 A:middle
那一行为如何运作不应该

00:08:17.636 --> 00:08:19.676 A:middle
被类型的偶发

00:08:19.676 --> 00:08:22.056 A:middle
执行细节所驱动

00:08:22.296 --> 00:08:22.896 A:middle
相反 应该是一个

00:08:22.896 --> 00:08:25.296 A:middle
有意识的选择 是基于用例的

00:08:26.626 --> 00:08:27.736 A:middle
那么 我说的

00:08:27.736 --> 00:08:28.896 A:middle
偶发执行细节

00:08:28.896 --> 00:08:29.236 A:middle
是指什么呢

00:08:29.236 --> 00:08:30.966 A:middle
好吧 让我们来看一个

00:08:30.966 --> 00:08:32.096 A:middle
示例类型

00:08:32.426 --> 00:08:33.765 A:middle
比如一个 material 类型

00:08:33.996 --> 00:08:36.836 A:middle
我希望它像一个值

00:08:36.836 --> 00:08:38.296 A:middle
所以我将它设置成一个结构

00:08:38.506 --> 00:08:39.635 A:middle
我赋予它一些简单的属性

00:08:39.635 --> 00:08:41.106 A:middle
比如 roughness

00:08:41.106 --> 00:08:43.476 A:middle
然后我给它一个 textture 属性

00:08:43.856 --> 00:08:45.376 A:middle
让我们假设纹 texture

00:08:45.376 --> 00:08:46.536 A:middle
属性需要去通过

00:08:46.536 --> 00:08:48.486 A:middle
引用计数来管理资源

00:08:48.486 --> 00:08:50.816 A:middle
所以我决定将它设置成一个类

00:08:52.106 --> 00:08:53.906 A:middle
现在 我们之前说过

00:08:53.906 --> 00:08:55.246 A:middle
当你对一个值类型进行复制

00:08:55.246 --> 00:08:56.936 A:middle
你将会复制其所有存储

00:08:56.936 --> 00:08:57.426 A:middle
的属性

00:08:58.086 --> 00:08:59.196 A:middle
但是当你复制一个

00:08:59.196 --> 00:09:00.926 A:middle
引用类型时 你只是在

00:09:00.926 --> 00:09:02.376 A:middle
复制那一个引用

00:09:03.226 --> 00:09:04.936 A:middle
所以当你在复制

00:09:04.936 --> 00:09:06.776 A:middle
这个 material 类型时 

00:09:06.776 --> 00:09:08.296 A:middle
最后会发生的情况就是

00:09:08.296 --> 00:09:09.656 A:middle
创建了引用副本

00:09:09.686 --> 00:09:10.996 A:middle
所以两个类型最后

00:09:11.226 --> 00:09:13.186 A:middle
共享了同一个纹理对象

00:09:14.576 --> 00:09:16.096 A:middle
现在 是否可以

00:09:16.626 --> 00:09:17.356 A:middle
实际上取决于

00:09:17.356 --> 00:09:18.726 A:middle
纹理的实现

00:09:19.106 --> 00:09:21.016 A:middle
如果纹理不可变 那么

00:09:21.016 --> 00:09:21.966 A:middle
就非常完美

00:09:21.966 --> 00:09:23.576 A:middle
事实上 这是很理想的

00:09:23.576 --> 00:09:24.696 A:middle
从一个共享的角度考虑

00:09:26.066 --> 00:09:27.326 A:middle
但是如果纹理

00:09:27.326 --> 00:09:28.996 A:middle
在根本上是易变类型

00:09:29.806 --> 00:09:30.876 A:middle
那么我这里所创建的

00:09:30.876 --> 00:09:32.116 A:middle
实际上就有点奇怪了

00:09:32.116 --> 00:09:33.256 A:middle
它的运作既不像

00:09:33.256 --> 00:09:35.016 A:middle
一个引用 也不像一个值

00:09:35.426 --> 00:09:37.076 A:middle
我可以对结构上的属性

00:09:37.236 --> 00:09:37.886 A:middle
做出改变

00:09:38.936 --> 00:09:40.826 A:middle
而且它只影响其中一个变量

00:09:40.856 --> 00:09:43.086 A:middle
但是如果我作出更改

00:09:43.086 --> 00:09:46.286 A:middle
从纹理引用到

00:09:46.286 --> 00:09:48.846 A:middle
对象 那么它将影响两个变量

00:09:49.066 --> 00:09:49.936 A:middle
而这是非常令人惊奇的

00:09:49.936 --> 00:09:51.736 A:middle
对于你 API 的用户来说

00:09:51.736 --> 00:09:53.336 A:middle
也许甚至比

00:09:53.336 --> 00:09:54.296 A:middle
你一直受困于

00:09:54.356 --> 00:09:56.356 A:middle
引用语义还要让人困惑

00:09:56.936 --> 00:09:59.466 A:middle
所以在这儿我们需要做一个

00:09:59.466 --> 00:10:01.896 A:middle
真正的关键区分

00:10:01.896 --> 00:10:03.906 A:middle
在值和引用类型之间

00:10:04.306 --> 00:10:06.856 A:middle
结构与类相比

00:10:06.856 --> 00:10:08.836 A:middle
以及值和引用语义

00:10:09.116 --> 00:10:10.836 A:middle
和类型的表现

00:10:12.376 --> 00:10:13.916 A:middle
仅仅因为一些东西是

00:10:13.916 --> 00:10:15.146 A:middle
值类型 比如结构

00:10:15.286 --> 00:10:16.856 A:middle
未必代表着

00:10:16.856 --> 00:10:18.826 A:middle
你会自动从中获得

00:10:18.826 --> 00:10:20.266 A:middle
值操作

00:10:20.496 --> 00:10:22.006 A:middle
有一种方式 不是

00:10:22.006 --> 00:10:23.386 A:middle
唯一的方式 但是普遍的方式

00:10:23.866 --> 00:10:25.966 A:middle
就是当你将一个可变

00:10:26.376 --> 00:10:27.826 A:middle
的引用类型作为

00:10:27.866 --> 00:10:28.616 A:middle
公共 API 的一部分

00:10:28.616 --> 00:10:31.086 A:middle
所以第一个问题 如果你

00:10:31.086 --> 00:10:32.176 A:middle
想让一些东西表现的像一个值

00:10:32.176 --> 00:10:33.456 A:middle
那么任何

00:10:33.456 --> 00:10:35.486 A:middle
它显示的引用是可变的吗

00:10:36.686 --> 00:10:38.416 A:middle
请记住 这并不

00:10:38.416 --> 00:10:39.466 A:middle
总是很明显

00:10:40.056 --> 00:10:41.446 A:middle
如果我们在处理一个

00:10:41.446 --> 00:10:43.696 A:middle
非最终类 那么你

00:10:43.696 --> 00:10:47.036 A:middle
实际上可能得到的可能是一个可变的子类

00:10:47.436 --> 00:10:49.536 A:middle
幸运的是 我们

00:10:49.536 --> 00:10:51.436 A:middle
有很多技术来避免

00:10:51.436 --> 00:10:52.496 A:middle
类似这样的问题

00:10:53.616 --> 00:10:55.986 A:middle
所以最早的一个就是去做

00:10:55.986 --> 00:10:56.946 A:middle
我们经常针对引用类型

00:10:56.946 --> 00:10:58.956 A:middle
所做的 也就是做一个防御性拷贝

00:10:59.316 --> 00:11:00.846 A:middle
这样我们就可以将 texture

00:11:00.846 --> 00:11:02.396 A:middle
存储属性转为 private

00:11:03.476 --> 00:11:05.966 A:middle
然后创建一个计算后的属性

00:11:06.296 --> 00:11:08.816 A:middle
在设置中

00:11:08.816 --> 00:11:10.726 A:middle
我们复制 texture 对象

00:11:11.286 --> 00:11:12.996 A:middle
这就避免了可变的

00:11:12.996 --> 00:11:14.226 A:middle
子类问题

00:11:15.176 --> 00:11:16.396 A:middle
但是 问题没有解决

00:11:16.396 --> 00:11:17.566 A:middle
如果纹理在

00:11:17.566 --> 00:11:19.506 A:middle
根本上是可变类型

00:11:20.036 --> 00:11:21.366 A:middle
因为你仍然可以改变它

00:11:21.366 --> 00:11:22.916 A:middle
只需要通过 get 方法

00:11:22.976 --> 00:11:24.166 A:middle
这就是引用的工作原理

00:11:25.036 --> 00:11:26.806 A:middle
那么让我们来考虑一下

00:11:26.806 --> 00:11:29.886 A:middle
另一种方式

00:11:29.886 --> 00:11:31.436 A:middle
完全不显示引用类型

00:11:31.766 --> 00:11:34.326 A:middle
相反 只是显示了

00:11:34.326 --> 00:11:36.346 A:middle
我们希望反应在对象上的属性

00:11:36.866 --> 00:11:38.526 A:middle
作为计算生成的属性在我们的

00:11:38.526 --> 00:11:40.046 A:middle
material 值类型上

00:11:41.006 --> 00:11:42.676 A:middle
所以我们可以创建一个通过计算

00:11:42.676 --> 00:11:43.156 A:middle
产生的属性

00:11:43.156 --> 00:11:44.496 A:middle
在 get 方法中

00:11:44.496 --> 00:11:45.916 A:middle
转到相关的

00:11:45.916 --> 00:11:46.846 A:middle
对象的属性

00:11:47.486 --> 00:11:50.196 A:middle
但是在 set 方法中

00:11:50.196 --> 00:11:53.106 A:middle
首先检查对象是否被

00:11:53.106 --> 00:11:54.226 A:middle
唯一引用

00:11:54.476 --> 00:11:56.836 A:middle
如果不是 那么这个时候

00:11:57.006 --> 00:11:59.026 A:middle
我们可以在继续之前

00:11:59.026 --> 00:12:01.226 A:middle
完全复制 texture 对象

00:12:01.226 --> 00:12:02.446 A:middle
并作出更改

00:12:03.556 --> 00:12:05.516 A:middle
通过添加这一行来检查

00:12:05.516 --> 00:12:06.756 A:middle
唯一性 我们已经

00:12:06.756 --> 00:12:09.216 A:middle
执行了完整的写时复制

00:12:09.396 --> 00:12:10.906 A:middle
语义

00:12:10.906 --> 00:12:12.276 A:middle
同时仍显示我们希望出现

00:12:12.566 --> 00:12:14.326 A:middle
在我们的引用类型上的属性

00:12:16.556 --> 00:12:17.996 A:middle
那么接下来 我们来讲讲

00:12:17.996 --> 00:12:19.546 A:middle
协议和泛型

00:12:20.276 --> 00:12:21.976 A:middle
那么 我们已经看过了值类型是如何

00:12:22.166 --> 00:12:24.676 A:middle
使用户清晰明确的

00:12:24.676 --> 00:12:25.856 A:middle
使用你的 API

00:12:26.686 --> 00:12:28.356 A:middle
但是 值类型并不是一个新东西

00:12:28.356 --> 00:12:30.306 A:middle
我们在 Objective-C 语言中一直有

00:12:30.376 --> 00:12:32.366 A:middle
CGPoint 或 CGrect 之类的

00:12:33.036 --> 00:12:33.786 A:middle
那么区别是什么呢

00:12:33.836 --> 00:12:35.646 A:middle
Swift 中的区别

00:12:36.036 --> 00:12:37.236 A:middle
在于可以向

00:12:37.436 --> 00:12:39.896 A:middle
结构和枚举添加协议

00:12:40.506 --> 00:12:41.966 A:middle
同样也包括类

00:12:42.506 --> 00:12:43.976 A:middle
这意味着你可以共享代码

00:12:43.976 --> 00:12:45.726 A:middle
通过使用泛型可以

00:12:46.036 --> 00:12:47.016 A:middle
跨越很多值类型

00:12:47.816 --> 00:12:49.376 A:middle
所以当你觉得你需要

00:12:49.376 --> 00:12:50.406 A:middle
共享一些

00:12:50.406 --> 00:12:51.586 A:middle
不同类型的代码

00:12:51.586 --> 00:12:53.576 A:middle
并不是一定要创建类继承关系

00:12:53.576 --> 00:12:55.466 A:middle
使其中的父类

00:12:55.466 --> 00:12:57.106 A:middle
有共享功能

00:12:58.286 --> 00:13:00.756 A:middle
而是 就像老话说的那样

00:13:00.756 --> 00:13:02.876 A:middle
在 Swift 中 一切从协议开始

00:13:04.176 --> 00:13:06.906 A:middle
但是 那并不意味着当

00:13:06.906 --> 00:13:08.596 A:middle
你打开 XCode 时你会得到

00:13:08.596 --> 00:13:09.816 A:middle
一个空的源文件 你要做的

00:13:09.816 --> 00:13:12.356 A:middle
第一件事是用键盘输入协议

00:13:12.986 --> 00:13:14.766 A:middle
在 Swift API 设计中

00:13:14.766 --> 00:13:16.606 A:middle
就像任何的 Swift 设计一样

00:13:16.606 --> 00:13:18.546 A:middle
首先通过具体的类型探索用例

00:13:18.546 --> 00:13:20.376 A:middle
并且理解

00:13:20.376 --> 00:13:21.466 A:middle
你想要共享的代码是什么

00:13:21.466 --> 00:13:23.686 A:middle
当你发现自己在不同类型上

00:13:23.686 --> 00:13:25.086 A:middle
重复多个功能时

00:13:25.706 --> 00:13:27.516 A:middle
然后通过泛型将代码

00:13:27.516 --> 00:13:29.196 A:middle
共享出去

00:13:30.106 --> 00:13:32.906 A:middle
那么 那可能意味着创建新的协议

00:13:33.336 --> 00:13:35.616 A:middle
但是首先 想一想

00:13:35.616 --> 00:13:37.516 A:middle
通过现存的协议组成

00:13:37.516 --> 00:13:38.186 A:middle
你需要的东西

00:13:38.296 --> 00:13:39.096 A:middle
而且当你在设计

00:13:39.096 --> 00:13:40.446 A:middle
协议时 请确保它们是

00:13:40.446 --> 00:13:41.426 A:middle
可组合的

00:13:42.106 --> 00:13:44.876 A:middle
作为创建协议的

00:13:44.876 --> 00:13:46.866 A:middle
一种替代 你可以考虑

00:13:47.376 --> 00:13:49.506 A:middle
创建一个泛型

00:13:50.456 --> 00:13:51.896 A:middle
那么 让我们来看一些例子

00:13:51.896 --> 00:13:53.256 A:middle
这些例子展示了刚刚提到的

00:13:53.256 --> 00:13:53.816 A:middle
不同的东西

00:13:54.466 --> 00:13:56.316 A:middle
那么 假设我想要创建

00:13:56.316 --> 00:13:57.236 A:middle
一个几何 API

00:13:57.546 --> 00:13:59.206 A:middle
作为其中的一部分 我想要

00:13:59.206 --> 00:14:02.036 A:middle
创建几何向量上的操作

00:14:02.036 --> 00:14:05.186 A:middle
我可能会从为一个

00:14:05.186 --> 00:14:06.706 A:middle
GeometricVector 创建协议开始

00:14:07.086 --> 00:14:08.096 A:middle
我可以赋予其

00:14:08.096 --> 00:14:09.156 A:middle
我想要定义的操作

00:14:09.156 --> 00:14:11.816 A:middle
比如坐标或者

00:14:11.816 --> 00:14:13.356 A:middle
向量间的距离

00:14:15.726 --> 00:14:17.556 A:middle
现在 我需要存储

00:14:17.556 --> 00:14:18.636 A:middle
向量的维度

00:14:18.636 --> 00:14:21.176 A:middle
那么我可能会使我的几何

00:14:21.176 --> 00:14:23.656 A:middle
向量继承自 SIMD 协议

00:14:23.956 --> 00:14:25.226 A:middle
如果你还不熟悉

00:14:25.226 --> 00:14:26.326 A:middle
SIMD 类型 它们

00:14:26.326 --> 00:14:27.466 A:middle
基本上有点像

00:14:27.466 --> 00:14:28.616 A:middle
同质元组

00:14:28.616 --> 00:14:30.016 A:middle
能够很有效地

00:14:30.016 --> 00:14:32.256 A:middle
一次性在每个元素上

00:14:32.256 --> 00:14:32.816 A:middle
执行计算

00:14:33.656 --> 00:14:34.836 A:middle
而且它们还在

00:14:34.836 --> 00:14:36.246 A:middle
Swift 5.1 中有很多了不起的新功能

00:14:36.676 --> 00:14:38.186 A:middle
它们完美地适用于

00:14:38.276 --> 00:14:39.346 A:middle
几何运算

00:14:39.776 --> 00:14:40.696 A:middle
那么 我们要将我们的维度

00:14:40.696 --> 00:14:42.656 A:middle
存储在基础 SIMD 类型中

00:14:42.656 --> 00:14:44.086 A:middle
而且我们还想要对它进行限制

00:14:44.086 --> 00:14:46.636 A:middle
使它只能在标量 SIMD 上工作

00:14:46.896 --> 00:14:47.526 A:middle
这样一来我们就可以

00:14:47.526 --> 00:14:49.716 A:middle
进行我们想要的计算

00:14:49.926 --> 00:14:50.896 A:middle
现在 一旦我们定义了这个协议

00:14:50.896 --> 00:14:52.476 A:middle
我们就可以继续

00:14:52.476 --> 00:14:53.396 A:middle
进行默认的

00:14:53.396 --> 00:14:55.066 A:middle
执行操作 进行所有

00:14:55.066 --> 00:14:56.816 A:middle
我们想在向量上进行的操作

00:14:57.706 --> 00:14:59.796 A:middle
然后我们希望给予

00:14:59.796 --> 00:15:02.716 A:middle
这个协议一致性

00:15:02.946 --> 00:15:04.046 A:middle
针对每一个我们想要其获得

00:15:04.046 --> 00:15:05.616 A:middle
这些新功能的类型

00:15:06.286 --> 00:15:08.586 A:middle
这个三步

00:15:08.826 --> 00:15:10.666 A:middle
定义协议的过程

00:15:10.666 --> 00:15:12.346 A:middle
赋予了它一个默认的执行 

00:15:12.346 --> 00:15:13.696 A:middle
然后为多种类型增添了一致性

00:15:13.696 --> 00:15:15.906 A:middle
事实上这有点乏味

00:15:16.316 --> 00:15:17.436 A:middle
我们有必要后退

00:15:17.436 --> 00:15:18.516 A:middle
一步想一想

00:15:19.076 --> 00:15:21.296 A:middle
协议真的是必要的吗

00:15:22.136 --> 00:15:23.756 A:middle
事实上

00:15:23.756 --> 00:15:25.276 A:middle
这些一致性实际上没有它们的

00:15:25.276 --> 00:15:27.476 A:middle
自定义执行

00:15:27.476 --> 00:15:28.986 A:middle
这实际上是一个警告的信号

00:15:29.086 --> 00:15:30.786 A:middle
说明协议是没用的

00:15:30.966 --> 00:15:31.946 A:middle
不是每个类型

00:15:31.976 --> 00:15:33.186 A:middle
都有自定义

00:15:33.586 --> 00:15:34.916 A:middle
而且实际上 这一操作

00:15:34.916 --> 00:15:36.456 A:middle
在每个不同种类的

00:15:36.456 --> 00:15:37.136 A:middle
SIMD 类型上都存在

00:15:38.156 --> 00:15:39.906 A:middle
那么 协议真的有在

00:15:39.906 --> 00:15:40.696 A:middle
带给我们什么东西吗

00:15:42.146 --> 00:15:43.506 A:middle
如果我们退一步

00:15:43.506 --> 00:15:45.116 A:middle
不在我们的新协议上

00:15:45.116 --> 00:15:46.116 A:middle
编写默认执行

00:15:46.116 --> 00:15:48.856 A:middle
相反 我们只是将其编写成

00:15:48.856 --> 00:15:51.296 A:middle
直接在 SIMD 协议上的扩展

00:15:51.296 --> 00:15:52.136 A:middle
有着相同的限制

00:15:52.136 --> 00:15:54.316 A:middle
这样我们就完成了

00:15:54.366 --> 00:15:55.836 A:middle
在这个单页的代码中

00:15:56.056 --> 00:15:57.746 A:middle
我们已经自动将所有

00:15:57.746 --> 00:15:59.776 A:middle
我们需要的功能赋给所有的

00:15:59.776 --> 00:16:01.616 A:middle
包含浮点数的 SIMD 类型 

00:16:03.406 --> 00:16:04.846 A:middle
要创建这个协议的

00:16:04.846 --> 00:16:06.236 A:middle
继承式关系

00:16:06.236 --> 00:16:08.046 A:middle
并且将不同类型

00:16:08.046 --> 00:16:09.796 A:middle
划分进继承关系

00:16:09.866 --> 00:16:10.916 A:middle
听上去很吸引人

00:16:11.416 --> 00:16:12.986 A:middle
但是这有点太过于形式

00:16:12.986 --> 00:16:14.536 A:middle
就是让人感觉很满意

00:16:14.536 --> 00:16:16.106 A:middle
但并不总是必要

00:16:17.186 --> 00:16:19.226 A:middle
而且这里总是会涉及到

00:16:19.226 --> 00:16:20.076 A:middle
一个现实的问题

00:16:20.706 --> 00:16:22.646 A:middle
这个没有协议的 更简单的

00:16:22.646 --> 00:16:24.246 A:middle
基于扩展的方式

00:16:24.246 --> 00:16:26.566 A:middle
让编译过程简单很多

00:16:27.186 --> 00:16:28.276 A:middle
如果没有这一串

00:16:28.276 --> 00:16:29.486 A:middle
不必要的协议见证表

00:16:29.486 --> 00:16:31.436 A:middle
你的二进制文件会小很多

00:16:32.746 --> 00:16:34.056 A:middle
事实上 我们发现在

00:16:34.146 --> 00:16:36.006 A:middle
很大的项目上

00:16:36.006 --> 00:16:38.186 A:middle
有着大量的复杂协议类型

00:16:38.186 --> 00:16:40.686 A:middle
通过这个

00:16:40.686 --> 00:16:42.296 A:middle
简化方式并减少

00:16:42.296 --> 00:16:45.306 A:middle
协议的数量

00:16:45.306 --> 00:16:46.636 A:middle
我们可以极大地缩短

00:16:46.636 --> 00:16:48.056 A:middle
编译这些 App 的时间

00:16:50.186 --> 00:16:52.856 A:middle
目前 这个方式

00:16:52.856 --> 00:16:54.576 A:middle
对一小部分项目有用

00:16:54.946 --> 00:16:56.296 A:middle
但是当你在设计

00:16:56.296 --> 00:16:57.596 A:middle
一个更完全的 API 时 就涉及

00:16:57.596 --> 00:16:58.416 A:middle
一个可扩展问题

00:16:58.416 --> 00:17:01.516 A:middle
早些时候 我们想着

00:17:01.516 --> 00:17:03.676 A:middle
创建一个协议

00:17:03.676 --> 00:17:05.636 A:middle
我们说了我们要定义几何向量

00:17:05.636 --> 00:17:07.836 A:middle
并用它继承 SIMD

00:17:08.136 --> 00:17:09.636 A:middle
用于我们的存储

00:17:10.455 --> 00:17:11.846 A:middle
但是这真的是正确的吗

00:17:11.976 --> 00:17:14.336 A:middle
这是一种承继关系吗

00:17:14.336 --> 00:17:16.046 A:middle
我们真的可以说几何

00:17:16.046 --> 00:17:18.415 A:middle
向量是 SIMD 类型吗

00:17:18.415 --> 00:17:21.096 A:middle
我的意思是说 一些操作是合理的

00:17:21.096 --> 00:17:23.326 A:middle
你可以添加或者移除向量

00:17:23.965 --> 00:17:24.776 A:middle
但是有一些不行

00:17:24.776 --> 00:17:26.546 A:middle
你不能将两个

00:17:26.546 --> 00:17:27.296 A:middle
向量相互乘起来

00:17:27.296 --> 00:17:29.826 A:middle
或者将数字 1 添加至向量

00:17:29.826 --> 00:17:31.886 A:middle
但是这些操作在

00:17:31.886 --> 00:17:33.736 A:middle
所有的 SIMD 类型都是可行的

00:17:33.946 --> 00:17:35.266 A:middle
在其他的条件下要有

00:17:35.266 --> 00:17:37.276 A:middle
其他合理的定义

00:17:37.276 --> 00:17:39.206 A:middle
只是不是在几何的情况下

00:17:40.326 --> 00:17:41.986 A:middle
如果我们正在设计一个

00:17:41.986 --> 00:17:43.856 A:middle
便于使用的 API

00:17:44.126 --> 00:17:45.316 A:middle
那么我们也许应该考虑另一个选项

00:17:45.316 --> 00:17:48.906 A:middle
这个选项不是承继关系

00:17:48.906 --> 00:17:50.366 A:middle
而是执行一种组合关系

00:17:50.856 --> 00:17:53.236 A:middle
就是将一个 SIMD 值包含在

00:17:53.676 --> 00:17:55.256 A:middle
一个泛型结构里

00:17:55.866 --> 00:17:57.666 A:middle
这样我们就可以创建一个

00:17:57.666 --> 00:17:59.506 A:middle
几何向量的结构

00:17:59.786 --> 00:18:02.096 A:middle
而且我们将其设定为

00:18:02.096 --> 00:18:03.936 A:middle
SIMD 存储类型的泛型

00:18:03.936 --> 00:18:05.816 A:middle
这样它就可以处理浮点类型

00:18:06.086 --> 00:18:07.736 A:middle
以及任何不同数量的维度

00:18:08.366 --> 00:18:11.166 A:middle
然后 一旦我们完成了这个操作

00:18:11.166 --> 00:18:13.086 A:middle
对于在我们的

00:18:13.086 --> 00:18:15.116 A:middle
新类型上显示什么 API 就有了

00:18:15.116 --> 00:18:16.586 A:middle
更精细的控制

00:18:17.566 --> 00:18:19.956 A:middle
所以我们就可以定义两个

00:18:19.956 --> 00:18:20.926 A:middle
向量的相加

00:18:21.296 --> 00:18:23.096 A:middle
而不是某一向量

00:18:23.096 --> 00:18:24.126 A:middle
单个数字的相加

00:18:24.416 --> 00:18:26.556 A:middle
又或者 我们可以依照标量

00:18:27.056 --> 00:18:29.156 A:middle
定义向量的相乘

00:18:29.156 --> 00:18:31.386 A:middle
而不是两个向量

00:18:31.386 --> 00:18:33.196 A:middle
彼此相乘

00:18:35.286 --> 00:18:37.546 A:middle
而且我们仍然可以使用泛型扩展

00:18:37.546 --> 00:18:39.376 A:middle
这样一来 我们执行的

00:18:39.426 --> 00:18:41.226 A:middle
坐标和距离

00:18:41.226 --> 00:18:42.676 A:middle
就和它们之前的是一样的

00:18:43.306 --> 00:18:45.876 A:middle
现在 我们已经在

00:18:45.876 --> 00:18:47.796 A:middle
标准库使用了这一技术

00:18:47.796 --> 00:18:49.906 A:middle
例如 我们就有了一个

00:18:49.906 --> 00:18:50.966 A:middle
SIMD 协议

00:18:51.166 --> 00:18:53.406 A:middle
而且然后我们有了

00:18:53.406 --> 00:18:54.766 A:middle
泛型结构 其代表了

00:18:54.766 --> 00:18:56.996 A:middle
不同尺寸的 SIMD 类型

00:18:57.466 --> 00:19:00.676 A:middle
请注意 这里并没有 SIMD2 或者

00:19:00.716 --> 00:19:02.016 A:middle
SIMD3 协议

00:19:02.016 --> 00:19:03.616 A:middle
它们不必添加很多值

00:19:04.626 --> 00:19:06.166 A:middle
用户仍可以通过

00:19:06.166 --> 00:19:08.216 A:middle
扩展来为特定尺寸的 SIMD

00:19:08.756 --> 00:19:11.136 A:middle
编写泛型代码 比如

00:19:11.136 --> 00:19:12.846 A:middle
对于一个跨产品操作的 SIMD3 类型

00:19:12.846 --> 00:19:14.146 A:middle
你仅仅想要

00:19:14.146 --> 00:19:17.176 A:middle
定义一个三维的 SIMD 类型

00:19:17.856 --> 00:19:19.486 A:middle
希望这些能让你知道

00:19:19.486 --> 00:19:21.376 A:middle
泛型是如何

00:19:21.376 --> 00:19:22.966 A:middle
像协议一样

00:19:22.966 --> 00:19:25.096 A:middle
强大又具扩展性

00:19:25.906 --> 00:19:27.236 A:middle
现在 我们在这里还是在

00:19:27.236 --> 00:19:28.006 A:middle
借助协议的力量

00:19:28.976 --> 00:19:30.106 A:middle
我们在泛型 SIMD 上

00:19:30.106 --> 00:19:31.896 A:middle
有限制标量类型的浮点

00:19:31.896 --> 00:19:33.666 A:middle
它为我们

00:19:33.666 --> 00:19:34.776 A:middle
提供了基本代码块

00:19:34.776 --> 00:19:38.726 A:middle
可以用于写代码

00:19:39.276 --> 00:19:40.796 A:middle
现在 在我们的

00:19:40.796 --> 00:19:42.656 A:middle
GeometricVector 类型上 我们可以

00:19:42.656 --> 00:19:43.856 A:middle
编写同样的跨产品操作

00:19:44.426 --> 00:19:45.706 A:middle
但是当我们这样做

00:19:45.706 --> 00:19:47.276 A:middle
执行操作看上去

00:19:47.276 --> 00:19:48.116 A:middle
会有点丑陋

00:19:48.606 --> 00:19:49.486 A:middle
因为我们必须保持

00:19:49.536 --> 00:19:51.006 A:middle
间接通过值存储

00:19:51.006 --> 00:19:52.356 A:middle
来获取

00:19:52.356 --> 00:19:54.156 A:middle
X Y 和 Z 坐标

00:19:54.496 --> 00:19:56.046 A:middle
所以 如果我们可以

00:19:56.046 --> 00:19:56.806 A:middle
解决这个问题 会很棒

00:19:57.246 --> 00:19:58.616 A:middle
现在 很显然我们可以

00:19:58.616 --> 00:19:59.946 A:middle
的向量类型上为

00:19:59.946 --> 00:20:01.516 A:middle
X Y 和 Z 编写计算出的属性

00:20:01.576 --> 00:20:02.896 A:middle
但是实际上在

00:20:02.896 --> 00:20:05.846 A:middle
Swift 5.1 有一个新功能叫做

00:20:05.846 --> 00:20:07.876 A:middle
关键路径成员查找 

00:20:07.876 --> 00:20:09.696 A:middle
你可以编写单个下标操作

00:20:09.696 --> 00:20:11.446 A:middle
同时显示

00:20:11.636 --> 00:20:13.766 A:middle
一个类型中的多个

00:20:13.766 --> 00:20:15.286 A:middle
不同的计算属性

00:20:15.286 --> 00:20:18.096 A:middle
这样一来 我们就可以根据选择

00:20:18.096 --> 00:20:20.426 A:middle
来使用它 如果可行

00:20:20.426 --> 00:20:22.256 A:middle
就一次性将

00:20:22.256 --> 00:20:25.266 A:middle
SIMD 上的所有属性显示在

00:20:25.266 --> 00:20:25.836 A:middle
我们的几何向量上

00:20:26.396 --> 00:20:27.536 A:middle
让我们来看看我们是如何做的

00:20:28.506 --> 00:20:31.296 A:middle
那么首先 我们将我们的 GeometricVector

00:20:31.296 --> 00:20:33.886 A:middle
标记为 dynamicMemberLookup 属性

00:20:34.686 --> 00:20:37.936 A:middle
紧接着 编译器

00:20:37.936 --> 00:20:39.146 A:middle
会提醒我们写一个特殊的

00:20:39.236 --> 00:20:40.546 A:middle
动态成员下标

00:20:41.136 --> 00:20:44.966 A:middle
这个下标采取关键路径

00:20:44.966 --> 00:20:46.206 A:middle
执行这一下标

00:20:46.206 --> 00:20:47.746 A:middle
的影响是任何

00:20:47.806 --> 00:20:49.606 A:middle
可通过该关键路径

00:20:49.606 --> 00:20:52.096 A:middle
自动访问的属性

00:20:52.096 --> 00:20:53.826 A:middle
都会在我们的 GeometricVector 类型上

00:20:54.256 --> 00:20:56.436 A:middle
显示为计算属性

00:20:56.946 --> 00:20:58.336 A:middle
在这个例子中 我们想要

00:20:58.386 --> 00:21:00.556 A:middle
关键路径是进入 SIMD 存储类型

00:21:00.556 --> 00:21:02.496 A:middle
并返回一个标量

00:21:02.956 --> 00:21:04.336 A:middle
然后我们使用那个关键路径

00:21:04.336 --> 00:21:05.766 A:middle
继续并获取

00:21:05.766 --> 00:21:08.516 A:middle
来自值存储的值并返回

00:21:08.516 --> 00:21:11.076 A:middle
一旦我们完成了这些

00:21:11.156 --> 00:21:12.946 A:middle
我们的几何向量

00:21:12.946 --> 00:21:13.826 A:middle
就会自动获得所有

00:21:13.826 --> 00:21:15.216 A:middle
SIMD 拥有的属性

00:21:16.036 --> 00:21:17.806 A:middle
举个例子

00:21:17.806 --> 00:21:18.816 A:middle
可以获取 X Y 和 Z 坐标

00:21:18.996 --> 00:21:20.036 A:middle
而且它们甚至出现在

00:21:20.036 --> 00:21:21.646 A:middle
Xcode 的自动补全里

00:21:22.646 --> 00:21:24.386 A:middle
如果你想在 Swift 5 里尝试这一功能

00:21:24.386 --> 00:21:25.446 A:middle
当它是基于字符串时

00:21:25.446 --> 00:21:27.066 A:middle
这里的区别在于

00:21:27.066 --> 00:21:28.526 A:middle
这个版本是

00:21:28.526 --> 00:21:29.876 A:middle
完全类型安全的

00:21:30.556 --> 00:21:31.586 A:middle
而且更多的东西是在

00:21:31.586 --> 00:21:34.806 A:middle
编译时完成

00:21:35.046 --> 00:21:36.016 A:middle
既然我们可以访问

00:21:36.016 --> 00:21:37.306 A:middle
X Y 和 Z 属性 那么

00:21:37.306 --> 00:21:38.916 A:middle
我们就可以很大程度上

00:21:39.346 --> 00:21:41.936 A:middle
简化我们的跨产品操作了

00:21:42.436 --> 00:21:44.466 A:middle
就是这样 看上去好多了

00:21:44.756 --> 00:21:45.996 A:middle
目前 这个动态成员

00:21:46.296 --> 00:21:48.266 A:middle
的功能不仅对于

00:21:48.266 --> 00:21:49.606 A:middle
发送属性有用

00:21:49.606 --> 00:21:52.436 A:middle
你还可以将复杂的逻辑放进下标

00:21:52.436 --> 00:21:54.376 A:middle
那么我们再来看一个例子

00:21:54.986 --> 00:21:57.536 A:middle
让我们回到早前的例子

00:21:57.536 --> 00:21:59.576 A:middle
在这个例子中 我们

00:21:59.576 --> 00:22:01.296 A:middle
通过写时复制语义

00:22:01.636 --> 00:22:03.616 A:middle
显示了 texture 的特定属性

00:22:04.146 --> 00:22:05.746 A:middle
这对于一个属性是有效的

00:22:05.746 --> 00:22:07.106 A:middle
但是会很不幸

00:22:07.106 --> 00:22:08.646 A:middle
如果我们需要每次都编写

00:22:08.646 --> 00:22:09.566 A:middle
相同的代码

00:22:10.606 --> 00:22:11.846 A:middle
如果它想要将

00:22:11.846 --> 00:22:13.726 A:middle
texture 上的所有属性

00:22:13.926 --> 00:22:15.476 A:middle
使用写时复制语义属性

00:22:15.786 --> 00:22:16.996 A:middle
作为 material 类型的属性怎么办

00:22:16.996 --> 00:22:18.296 A:middle
那么 我们可以通过动态

00:22:18.296 --> 00:22:18.896 A:middle
成员查找来实现

00:22:19.766 --> 00:22:21.696 A:middle
那么首先 我们要将

00:22:21.696 --> 00:22:23.456 A:middle
dynamicMemberLookup 添加至我们的类型

00:22:24.986 --> 00:22:26.926 A:middle
然后我们执行

00:22:26.926 --> 00:22:27.946 A:middle
下标操作

00:22:27.946 --> 00:22:29.496 A:middle
而且我们要使它采取

00:22:29.666 --> 00:22:30.926 A:middle
一个可写的关键路径

00:22:30.926 --> 00:22:32.846 A:middle
因为我们希望可以同时获取

00:22:32.846 --> 00:22:33.856 A:middle
并设定属性

00:22:34.816 --> 00:22:37.346 A:middle
再将泛型作为返回值

00:22:37.616 --> 00:22:38.636 A:middle
因为我们想要在 texture 中

00:22:38.636 --> 00:22:40.806 A:middle
获取不同的类型

00:22:41.376 --> 00:22:44.526 A:middle
然后我们执行 get 和 set 方法

00:22:44.666 --> 00:22:45.896 A:middle
在 get 方法中我们只需要

00:22:45.896 --> 00:22:46.956 A:middle
进行之前的操作

00:22:47.576 --> 00:22:49.506 A:middle
但是在 set 方法中 在我们做出

00:22:49.506 --> 00:22:51.696 A:middle
更改前 我们要添加唯一

00:22:51.696 --> 00:22:54.256 A:middle
引用检查和 texture 的完整拷贝

00:22:55.036 --> 00:22:57.056 A:middle
通过这样的做法

00:22:57.056 --> 00:22:58.606 A:middle
在这个简洁的下标中

00:22:58.606 --> 00:23:00.416 A:middle
我们显示了

00:23:00.416 --> 00:23:02.726 A:middle
texture 上的每一个属性

00:23:02.726 --> 00:23:04.606 A:middle
同时在我们的 texture 类型上有

00:23:04.606 --> 00:23:05.416 A:middle
写时复制语义

00:23:06.036 --> 00:23:07.526 A:middle
这是一个非常有用的方式

00:23:07.526 --> 00:23:09.996 A:middle
以此来从你的类型中获取值语义

00:23:11.916 --> 00:23:14.286 A:middle
这个新的功能有很多

00:23:14.286 --> 00:23:15.126 A:middle
不同的应用

00:23:15.126 --> 00:23:16.616 A:middle
事实上它和 5.1 中的

00:23:16.616 --> 00:23:18.856 A:middle
一个新功能很好地组合在了一起

00:23:19.126 --> 00:23:20.436 A:middle
那就是属性包装器

00:23:20.436 --> 00:23:21.826 A:middle
接下来 Doug 会聊一聊这个话题

00:23:22.366 --> 00:23:30.356 A:middle
Doug [掌声]

00:23:30.856 --> 00:23:31.446 A:middle
&gt;&gt; 谢谢你 Ben

00:23:32.926 --> 00:23:36.416 A:middle
那么 Swift 是为了清晰

00:23:36.416 --> 00:23:38.566 A:middle
简洁的代码设计的

00:23:38.566 --> 00:23:40.846 A:middle
也是为了构建表现力优异的 API 对吗

00:23:40.886 --> 00:23:42.066 A:middle
也是为了代码的重新利用

00:23:42.066 --> 00:23:42.826 A:middle
我们已经谈过了

00:23:42.896 --> 00:23:44.956 A:middle
泛型和协议

00:23:44.956 --> 00:23:46.106 A:middle
有了它们你才可以

00:23:46.406 --> 00:23:48.766 A:middle
创建泛型代码

00:23:48.766 --> 00:23:50.636 A:middle
所以为了你的功能和类型

00:23:50.636 --> 00:23:51.476 A:middle
那是可以被再利用的

00:23:51.866 --> 00:23:54.026 A:middle
所以属性包装器

00:23:54.026 --> 00:23:55.766 A:middle
是 Swift 5.1 的新功能

00:23:56.486 --> 00:23:58.066 A:middle
属性包装器背后的想法

00:23:58.066 --> 00:23:59.796 A:middle
是有效地从你编写的

00:23:59.796 --> 00:24:01.566 A:middle
计算属性中获取

00:24:01.566 --> 00:24:02.456 A:middle
代码的重新利用

00:24:03.456 --> 00:24:06.376 A:middle
像这样 这儿有一堆代码

00:24:07.486 --> 00:24:10.266 A:middle
那么这里发生了什么呢

00:24:10.266 --> 00:24:12.936 A:middle
所以 我们尝试去做的就是

00:24:13.356 --> 00:24:15.526 A:middle
显示一个 public 属性 对吗

00:24:16.276 --> 00:24:16.946 A:middle
然后我们得到了这个

00:24:16.946 --> 00:24:17.976 A:middle
我们只是想要一个 image 属性

00:24:17.976 --> 00:24:18.526 A:middle
并且是 public

00:24:18.916 --> 00:24:20.256 A:middle
但是我们并不希望

00:24:20.606 --> 00:24:22.236 A:middle
所有的用户 我们的客户

00:24:22.236 --> 00:24:23.966 A:middle
可以那里编写任意值

00:24:24.226 --> 00:24:25.676 A:middle
我们想要描述一些策略

00:24:25.746 --> 00:24:27.016 A:middle
那么这就变成计算过的属性

00:24:27.326 --> 00:24:29.616 A:middle
我们实际的存储回到

00:24:29.616 --> 00:24:31.116 A:middle
这里 在内部的

00:24:31.116 --> 00:24:32.056 A:middle
imageStorage 属性中

00:24:32.646 --> 00:24:34.106 A:middle
所以通向那存储的访问权限

00:24:34.366 --> 00:24:36.926 A:middle
都是通过 get 和 set 方法建立的

00:24:37.636 --> 00:24:39.566 A:middle
这有很多代码

00:24:39.706 --> 00:24:40.926 A:middle
你们可以先看一看

00:24:41.396 --> 00:24:42.256 A:middle
你们中的一些人也许

00:24:42.256 --> 00:24:43.556 A:middle
认出了这是什么

00:24:44.446 --> 00:24:45.966 A:middle
它真的是一种很冗长的方式

00:24:45.966 --> 00:24:49.176 A:middle
来描述这只是一个惰性变量 image

00:24:50.616 --> 00:24:52.446 A:middle
现在这样就好多了

00:24:53.696 --> 00:24:55.216 A:middle
这是一行代码而不是

00:24:55.276 --> 00:24:57.316 A:middle
有着杂乱访问策略逻辑的

00:24:57.456 --> 00:24:59.436 A:middle
两个属性

00:24:59.936 --> 00:25:02.256 A:middle
我们有这个很好的修饰语

00:25:02.376 --> 00:25:04.626 A:middle
lazy 来告诉你

00:25:04.626 --> 00:25:06.146 A:middle
这里真实的语义是什么

00:25:07.266 --> 00:25:07.996 A:middle
这很重要

00:25:07.996 --> 00:25:08.936 A:middle
能更好的写文档

00:25:08.936 --> 00:25:09.866 A:middle
也更便于阅读

00:25:10.776 --> 00:25:11.826 A:middle
这就是为什么 lazy

00:25:11.826 --> 00:25:13.376 A:middle
自 Swift 1 就在语言中存在了

00:25:14.136 --> 00:25:18.856 A:middle
现在问题是

00:25:19.256 --> 00:25:21.226 A:middle
这是一个更笼统问题的例子

00:25:21.346 --> 00:25:23.306 A:middle
那么 让我们来看看这里的

00:25:23.306 --> 00:25:24.996 A:middle
另一个例子 也就是代码结构

00:25:25.716 --> 00:25:26.856 A:middle
基本上是相似的

00:25:28.006 --> 00:25:29.746 A:middle
但是策略以及实际

00:25:29.746 --> 00:25:30.986 A:middle
在 get 和 set 中

00:25:30.986 --> 00:25:32.556 A:middle
的执行不一样

00:25:32.856 --> 00:25:33.956 A:middle
那么如果你在看

00:25:33.956 --> 00:25:35.646 A:middle
这里的逻辑

00:25:35.646 --> 00:25:37.836 A:middle
你看到这是一个延迟初始化模式

00:25:37.836 --> 00:25:39.476 A:middle
你必须设置过这个

00:25:40.236 --> 00:25:41.956 A:middle
或者在你可以读取之前

00:25:41.956 --> 00:25:42.436 A:middle
曾初始化过

00:25:42.436 --> 00:25:43.456 A:middle
否则你就会失败

00:25:43.456 --> 00:25:45.006 A:middle
这是非常常见的事情

00:25:46.206 --> 00:25:47.196 A:middle
这类的代码出现在

00:25:47.196 --> 00:25:47.916 A:middle
很多地方

00:25:48.456 --> 00:25:50.816 A:middle
我们不会通过

00:25:50.816 --> 00:25:52.676 A:middle
为 Swift 提供另一种语言的扩展

00:25:53.226 --> 00:25:55.296 A:middle
来解决这个问题

00:25:56.266 --> 00:25:57.326 A:middle
但是事实上 我们想要

00:25:57.326 --> 00:25:58.476 A:middle
更宏观地解决这个

00:25:58.476 --> 00:25:59.606 A:middle
因为我们希望人们可以构建

00:25:59.606 --> 00:26:00.906 A:middle
这些东西的库

00:26:00.906 --> 00:26:02.026 A:middle
在这个库中

00:26:02.026 --> 00:26:03.476 A:middle
他们能够分离出

00:26:03.476 --> 00:26:05.356 A:middle
访问单个值的策略

00:26:05.986 --> 00:26:07.716 A:middle
所以这就是

00:26:07.716 --> 00:26:09.076 A:middle
属性包装器背后的想法

00:26:09.076 --> 00:26:10.936 A:middle
就是去消除这种样板

00:26:10.936 --> 00:26:12.356 A:middle
并获得表现更加优异的 API

00:26:13.556 --> 00:26:15.006 A:middle
那么 它们看上去有点像这样

00:26:15.716 --> 00:26:17.706 A:middle
这里的想法就是我们希望

00:26:17.706 --> 00:26:19.296 A:middle
当你在声明一个属性时能

00:26:19.296 --> 00:26:20.206 A:middle
使用标记

00:26:20.206 --> 00:26:22.236 A:middle
所以在这里它就是 public 文本变量

00:26:22.236 --> 00:26:26.316 A:middle
并运用延迟

00:26:26.316 --> 00:26:28.136 A:middle
初始化属性包装器来

00:26:28.136 --> 00:26:29.876 A:middle
给予它特别的语义

00:26:29.876 --> 00:26:30.936 A:middle
来给予它

00:26:30.936 --> 00:26:32.176 A:middle
特别的策略

00:26:33.696 --> 00:26:35.266 A:middle
现在这个 @LateInitialized

00:26:35.266 --> 00:26:36.686 A:middle
这是一个自定义属性

00:26:36.686 --> 00:26:37.906 A:middle
这是一个新的标记

00:26:37.906 --> 00:26:38.986 A:middle
我们在 Swift 中会稍微用到

00:26:39.406 --> 00:26:41.496 A:middle
最根本的 它就是在说

00:26:41.686 --> 00:26:42.836 A:middle
应用这个延迟初始化模式

00:26:42.836 --> 00:26:43.686 A:middle
无论它是什么

00:26:43.686 --> 00:26:44.876 A:middle
我们之后会回到这个来

00:26:45.516 --> 00:26:47.316 A:middle
但是仅仅从代码角度看

00:26:47.316 --> 00:26:49.726 A:middle
这整个都像是惰性的

00:26:49.726 --> 00:26:51.046 A:middle
它为我们带来的好处和

00:26:51.106 --> 00:26:52.166 A:middle
惰性是完全一样的

00:26:52.736 --> 00:26:54.506 A:middle
我们已经完全摆脱了样板文件

00:26:55.516 --> 00:26:57.796 A:middle
但是同时 我们也在

00:26:57.886 --> 00:26:58.866 A:middle
声明的位置就说明了

00:26:58.866 --> 00:27:00.426 A:middle
实际上的语义

00:27:00.426 --> 00:27:01.996 A:middle
比起那些混乱的代码

00:27:01.996 --> 00:27:04.406 A:middle
这更容易阅读和理解

00:27:05.386 --> 00:27:07.626 A:middle
好的 关于这一行小小的代码

00:27:07.626 --> 00:27:08.466 A:middle
已经讲得够多了

00:27:08.636 --> 00:27:09.916 A:middle
让我们来看看那延迟初始化

00:27:09.916 --> 00:27:10.866 A:middle
实际上看起来是怎么样的

00:27:11.776 --> 00:27:13.206 A:middle
你在这里将会看到

00:27:13.206 --> 00:27:13.816 A:middle
它是一些代码

00:27:13.816 --> 00:27:15.976 A:middle
但是就跟我们刚刚看到的代码一样

00:27:15.976 --> 00:27:17.936 A:middle
延迟初始化背后的

00:27:18.276 --> 00:27:20.076 A:middle
策略模版是一样的

00:27:21.136 --> 00:27:22.776 A:middle
在这里你有 get 和 set

00:27:22.956 --> 00:27:24.846 A:middle
set 是更新存储

00:27:24.876 --> 00:27:25.876 A:middle
get 是检查以确保

00:27:25.876 --> 00:27:27.376 A:middle
至少将其设置过一次

00:27:27.376 --> 00:27:28.276 A:middle
并且当我们有设置时

00:27:28.276 --> 00:27:30.416 A:middle
返回值 这非常直接

00:27:31.176 --> 00:27:33.476 A:middle
现在使这个简单的

00:27:33.476 --> 00:27:35.716 A:middle
泛型变得有意思的点在于

00:27:35.756 --> 00:27:37.216 A:middle
它是一个属性包装器

00:27:37.686 --> 00:27:39.196 A:middle
它由这里

00:27:39.306 --> 00:27:40.786 A:middle
顶部的 propertyWrapper 属性

00:27:40.786 --> 00:27:41.256 A:middle
指出是什么样

00:27:42.376 --> 00:27:43.606 A:middle
那么 它所做的就是

00:27:43.606 --> 00:27:45.396 A:middle
允许自定义属性句法

00:27:45.396 --> 00:27:47.086 A:middle
也就是说我们能将这个东西

00:27:47.086 --> 00:27:49.086 A:middle
运用到其他一些属性上

00:27:49.936 --> 00:27:50.986 A:middle
现在 有了 propertyWrapper 属性

00:27:50.986 --> 00:27:52.936 A:middle
就出现了一些要求

00:27:53.096 --> 00:27:55.036 A:middle
主要的一个问题要有

00:27:55.286 --> 00:27:56.406 A:middle
value 属性

00:27:57.056 --> 00:27:59.336 A:middle
这是所有策略执行的地方

00:27:59.386 --> 00:28:01.146 A:middle
所以所有访问

00:28:01.146 --> 00:28:02.686 A:middle
延迟初始化属性的权限都经过这里

00:28:03.876 --> 00:28:05.386 A:middle
而且我们看到实际的

00:28:05.386 --> 00:28:06.836 A:middle
标记是找到一些

00:28:06.836 --> 00:28:08.356 A:middle
提取的概念关于什么是

00:28:08.356 --> 00:28:09.416 A:middle
延迟初始化

00:28:10.156 --> 00:28:11.166 A:middle
在这个特殊的例子中

00:28:11.166 --> 00:28:12.756 A:middle
另一个有趣的事情是

00:28:12.756 --> 00:28:14.706 A:middle
我们已经声明了一个

00:28:14.706 --> 00:28:15.956 A:middle
没有参数的初始化

00:28:17.716 --> 00:28:19.016 A:middle
现在 在属性包装器里

00:28:19.016 --> 00:28:19.756 A:middle
这是可选的

00:28:19.906 --> 00:28:21.506 A:middle
但是当你使用时

00:28:21.506 --> 00:28:22.756 A:middle
它想说明的就是

00:28:22.756 --> 00:28:24.516 A:middle
应用该包装器属性

00:28:25.036 --> 00:28:26.806 A:middle
免费获得了

00:28:26.806 --> 00:28:28.056 A:middle
隐式初始化

00:28:28.056 --> 00:28:29.136 A:middle
在这个特殊的初始化中

00:28:32.076 --> 00:28:32.166 A:middle
&gt;&gt; 好的

00:28:33.986 --> 00:28:35.116 A:middle
让我们来实际运用这个东西

00:28:35.426 --> 00:28:37.006 A:middle
所以 当你通过将其

00:28:37.006 --> 00:28:38.176 A:middle
应用至一个特定的属性

00:28:38.176 --> 00:28:39.886 A:middle
来使用属性包装器时

00:28:39.886 --> 00:28:41.546 A:middle
编译器要将

00:28:41.546 --> 00:28:44.856 A:middle
那个代码翻译成两个分开的属性

00:28:44.856 --> 00:28:46.876 A:middle
基本上 我们正在

00:28:46.876 --> 00:28:48.076 A:middle
扩展成为我们一开始

00:28:48.076 --> 00:28:48.716 A:middle
看到的模式

00:28:49.426 --> 00:28:51.416 A:middle
所以你有一个带 $ 前缀的

00:28:51.416 --> 00:28:53.346 A:middle
备份存储属性

00:28:53.346 --> 00:28:55.826 A:middle
所以 $text 的类型

00:28:56.116 --> 00:28:58.396 A:middle
是属性包装器类型的一个实例

00:28:58.456 --> 00:28:59.276 A:middle
所以我们现在有一个

00:28:59.276 --> 00:29:00.806 A:middle
LateInitialized 字符串

00:29:01.826 --> 00:29:03.246 A:middle
它提供存储

00:29:04.616 --> 00:29:05.976 A:middle
通过调用无参数初始化

00:29:06.256 --> 00:29:09.646 A:middle
它将由编译器进行隐式初始化

00:29:09.646 --> 00:29:11.256 A:middle
就是我们刚刚提到的

00:29:11.586 --> 00:29:12.836 A:middle
因为它在那儿 现在我们

00:29:12.836 --> 00:29:13.996 A:middle
获得了隐式初始化

00:29:14.546 --> 00:29:16.586 A:middle
而延迟初始化随时可以进行

00:29:16.866 --> 00:29:18.706 A:middle
你也许能想起来

00:29:18.706 --> 00:29:19.666 A:middle
存储被设成了 nil

00:29:21.136 --> 00:29:21.966 A:middle
编译器在这里

00:29:21.966 --> 00:29:23.596 A:middle
还做了一件事 就是

00:29:23.596 --> 00:29:26.526 A:middle
将文本翻译成计算属性

00:29:27.286 --> 00:29:28.706 A:middle
所以 get 要

00:29:28.706 --> 00:29:31.066 A:middle
创建一个对 $text 的访问

00:29:31.506 --> 00:29:33.776 A:middle
然后通过

00:29:33.776 --> 00:29:36.056 A:middle
调用 get 值来获取

00:29:36.056 --> 00:29:36.926 A:middle
$text 的值

00:29:36.976 --> 00:29:39.346 A:middle
在 set 里我们也进行同样的操作

00:29:39.346 --> 00:29:42.686 A:middle
在 $text.value 中写下新的值

00:29:43.026 --> 00:29:44.756 A:middle
所以就是这个

00:29:44.756 --> 00:29:46.356 A:middle
属性包装器能有

00:29:46.356 --> 00:29:47.496 A:middle
其自己的存储

00:29:47.496 --> 00:29:48.296 A:middle
无论它想要怎么存储

00:29:48.296 --> 00:29:49.416 A:middle
无论是本地或者其他地方

00:29:49.986 --> 00:29:52.796 A:middle
然后无论执行什么

00:29:52.796 --> 00:29:54.886 A:middle
你指定的策略

00:29:54.886 --> 00:29:57.386 A:middle
通过 get 和 set 访问数据

00:29:58.756 --> 00:30:00.656 A:middle
所以总的来说 这是很好的

00:30:00.656 --> 00:30:02.576 A:middle
我们已经将策略和它的应用分离

00:30:02.736 --> 00:30:04.236 A:middle
将其放在

00:30:04.236 --> 00:30:07.736 A:middle
延迟初始化包装器中

00:30:07.966 --> 00:30:10.156 A:middle
无论我们想要什么类型

00:30:10.156 --> 00:30:11.466 A:middle
我们都可以对任意数量的

00:30:11.466 --> 00:30:14.006 A:middle
不同属性进行操作

00:30:14.006 --> 00:30:15.506 A:middle
在简单很多同时有更少的样板文件

00:30:17.196 --> 00:30:19.316 A:middle
那么 让我们来看看另一个例子

00:30:20.236 --> 00:30:21.546 A:middle
Ben 有提到过关于

00:30:21.546 --> 00:30:23.276 A:middle
值和引用语义的东西

00:30:23.866 --> 00:30:24.606 A:middle
现在 当你在处理

00:30:24.606 --> 00:30:26.196 A:middle
引用语义和可变状态时

00:30:26.196 --> 00:30:27.516 A:middle
你会发现在

00:30:27.516 --> 00:30:28.866 A:middle
在某些时候进行着

00:30:28.866 --> 00:30:29.436 A:middle
防御性拷贝

00:30:30.046 --> 00:30:31.486 A:middle
当然 我们可以手动在任何

00:30:31.486 --> 00:30:32.866 A:middle
需要的地方做这件事

00:30:32.866 --> 00:30:34.086 A:middle
但是为什么不为此

00:30:34.086 --> 00:30:35.036 A:middle
构建一个属性包装器呢

00:30:35.506 --> 00:30:38.506 A:middle
所以 这就是属性包装器

00:30:38.506 --> 00:30:40.146 A:middle
它的样子基本上

00:30:40.146 --> 00:30:41.526 A:middle
和我们之前看到的一样

00:30:41.526 --> 00:30:42.546 A:middle
它有存储能力

00:30:42.546 --> 00:30:43.786 A:middle
它有一个值属性

00:30:44.306 --> 00:30:45.636 A:middle
这个属性包装器的

00:30:45.676 --> 00:30:48.276 A:middle
所有策略都在 set里

00:30:48.536 --> 00:30:49.766 A:middle
当我们有了一个新的值

00:30:49.766 --> 00:30:50.836 A:middle
继续并复制这个值

00:30:51.216 --> 00:30:52.876 A:middle
而且由于我们正在使用 NSCopying

00:30:52.876 --> 00:30:54.906 A:middle
来进行复制

00:30:54.906 --> 00:30:56.436 A:middle
它就会继续并调用复制方法

00:30:56.436 --> 00:30:57.166 A:middle
然后进行投射

00:30:58.516 --> 00:30:59.736 A:middle
关于防御性拷贝的

00:30:59.736 --> 00:31:02.246 A:middle
另一件有趣的事情在于

00:31:02.246 --> 00:31:04.196 A:middle
它提供一个初始值的初始化

00:31:04.816 --> 00:31:06.746 A:middle
这就像那个没有参数的初始化

00:31:06.746 --> 00:31:08.086 A:middle
在你的属性包装器里

00:31:08.086 --> 00:31:08.996 A:middle
它并不是必须的

00:31:09.436 --> 00:31:11.546 A:middle
但是如果它在那里

00:31:11.546 --> 00:31:13.976 A:middle
就会让你在属性包装其中的

00:31:13.976 --> 00:31:15.076 A:middle
所有属性

00:31:15.076 --> 00:31:15.926 A:middle
都被赋为默认值

00:31:16.336 --> 00:31:18.776 A:middle
那个默认值会被填入这个初始化

00:31:19.106 --> 00:31:20.406 A:middle
我们可以在

00:31:20.406 --> 00:31:21.376 A:middle
初始化上实行任何我们

00:31:21.376 --> 00:31:22.206 A:middle
希望的策略

00:31:22.826 --> 00:31:24.116 A:middle
在我们的这个例子中

00:31:24.116 --> 00:31:25.076 A:middle
就跟 set 策略一样

00:31:25.356 --> 00:31:27.766 A:middle
我们想要继续并创建一个

00:31:27.766 --> 00:31:30.926 A:middle
防御性拷贝

00:31:33.296 --> 00:31:34.376 A:middle
之后为它分配一个结果

00:31:35.206 --> 00:31:35.946 A:middle
让我们来看一下

00:31:36.436 --> 00:31:38.636 A:middle
那么 如果我们要定义一些

00:31:38.636 --> 00:31:40.116 A:middle
防御性拷贝 UIBezierPath

00:31:40.956 --> 00:31:41.716 A:middle
会发生什么呢

00:31:41.716 --> 00:31:43.036 A:middle
好吧 编译器会

00:31:43.306 --> 00:31:44.956 A:middle
将其编译成两个

00:31:44.956 --> 00:31:45.896 A:middle
不同的定义

00:31:46.256 --> 00:31:46.976 A:middle
首先 在这里我们将会

00:31:46.976 --> 00:31:48.756 A:middle
有一个初始化

00:31:49.386 --> 00:31:51.256 A:middle
所以这里 无论何时我们创建这个路径

00:31:51.256 --> 00:31:53.006 A:middle
它有一个默认的

00:31:53.006 --> 00:31:54.366 A:middle
UIBezierPath

00:31:54.886 --> 00:31:56.536 A:middle
只是创建了空白的实例

00:31:56.956 --> 00:31:58.366 A:middle
然后当我们继续并

00:31:58.366 --> 00:32:00.056 A:middle
将其变成多个属性时

00:32:00.056 --> 00:32:01.826 A:middle
就有了备份

00:32:01.826 --> 00:32:03.186 A:middle
存储属性 $path

00:32:03.856 --> 00:32:05.326 A:middle
请注意我们是如何将它初始化的

00:32:05.406 --> 00:32:06.936 A:middle
我们将用户提供的

00:32:06.936 --> 00:32:09.026 A:middle
初始值传输至

00:32:09.026 --> 00:32:11.576 A:middle
初始值初始化 这样它

00:32:11.576 --> 00:32:12.756 A:middle
就可以被防御性复制了

00:32:13.566 --> 00:32:14.556 A:middle
get 和 set 方法

00:32:14.556 --> 00:32:15.376 A:middle
看上去完全一样

00:32:15.376 --> 00:32:16.376 A:middle
get 和 set

00:32:16.376 --> 00:32:18.686 A:middle
都需要 $path.value

00:32:19.836 --> 00:32:21.666 A:middle
现在 当然在默认情况下

00:32:21.666 --> 00:32:22.616 A:middle
是正确的语义

00:32:22.616 --> 00:32:24.106 A:middle
防御性拷贝应该

00:32:24.106 --> 00:32:24.846 A:middle
继续并进行复制

00:32:25.486 --> 00:32:26.786 A:middle
在这个例子中我们了解了

00:32:26.786 --> 00:32:28.356 A:middle
有关默认值的知识

00:32:28.516 --> 00:32:29.546 A:middle
就是创建一个新的对象

00:32:29.716 --> 00:32:31.086 A:middle
为什么我们要操作并复制呢

00:32:31.486 --> 00:32:33.606 A:middle
所以 让我们来稍微优化一下

00:32:33.606 --> 00:32:34.766 A:middle
因为我们可以做到

00:32:35.796 --> 00:32:37.286 A:middle
所以我们能够扩展防御拷贝

00:32:37.326 --> 00:32:37.956 A:middle
它只是一个类型

00:32:38.046 --> 00:32:39.066 A:middle
关于这个类型

00:32:39.066 --> 00:32:39.966 A:middle
没有什么神奇的

00:32:39.966 --> 00:32:40.906 A:middle
除了在使用时它表现得像

00:32:40.906 --> 00:32:42.466 A:middle
一个属性包装器

00:32:42.946 --> 00:32:44.176 A:middle
而且我们可以添加

00:32:44.246 --> 00:32:45.686 A:middle
withoutCopying 初始化

00:32:46.286 --> 00:32:49.516 A:middle
当我们这么使用时 

00:32:49.516 --> 00:32:50.936 A:middle
我们可以进行并为我们的类型

00:32:50.936 --> 00:32:52.246 A:middle
编写一个初始化程序

00:32:53.256 --> 00:32:54.796 A:middle
在这里我们在做的就是

00:32:54.796 --> 00:32:57.666 A:middle
我们正在为 $path 赋值

00:32:57.666 --> 00:32:59.586 A:middle
让它调用防御性 withoutCopying

00:32:59.586 --> 00:33:01.416 A:middle
初始化程序 这样我们就可以避免

00:33:01.416 --> 00:33:02.056 A:middle
出现多余的拷贝

00:33:03.146 --> 00:33:04.256 A:middle
所以这里没有更多

00:33:04.256 --> 00:33:06.076 A:middle
神奇的事情了

00:33:06.266 --> 00:33:08.206 A:middle
$path 只是一个存储属性

00:33:08.256 --> 00:33:09.516 A:middle
它唯一神奇的点在于

00:33:09.516 --> 00:33:11.136 A:middle
它是编译器作为将其应用到

00:33:11.246 --> 00:33:13.586 A:middle
属性包装器模式的一部分

00:33:13.586 --> 00:33:14.896 A:middle
而生成的

00:33:15.456 --> 00:33:16.766 A:middle
但是你可以

00:33:16.766 --> 00:33:18.766 A:middle
将它作为一个普通变量对待

00:33:18.766 --> 00:33:20.436 A:middle
包括设定

00:33:20.436 --> 00:33:21.256 A:middle
自己的初始化

00:33:21.866 --> 00:33:24.056 A:middle
现在 这还是

00:33:24.256 --> 00:33:25.396 A:middle
有点像样板文件

00:33:25.396 --> 00:33:26.476 A:middle
很不幸的是 我们不得不

00:33:26.476 --> 00:33:27.446 A:middle
编写那个初始化程序

00:33:27.516 --> 00:33:28.256 A:middle
所以你要看到

00:33:28.256 --> 00:33:29.816 A:middle
其他的初始化格式了

00:33:30.546 --> 00:33:32.786 A:middle
当你在

00:33:32.786 --> 00:33:34.926 A:middle
声明自定义属性时

00:33:34.926 --> 00:33:36.446 A:middle
使用 @DefensiveCopying

00:33:36.446 --> 00:33:37.826 A:middle
你可以就在属性声明里

00:33:37.826 --> 00:33:39.056 A:middle
进行初始化

00:33:39.206 --> 00:33:40.266 A:middle
按照你的想法来

00:33:40.686 --> 00:33:42.636 A:middle
所以这里我们就可以继续并调用

00:33:42.636 --> 00:33:44.186 A:middle
withoutCopying 初始化程序

00:33:44.186 --> 00:33:45.446 A:middle
来用我们想要的值

00:33:45.446 --> 00:33:47.606 A:middle
初始化备份存储属性

00:33:47.966 --> 00:33:49.536 A:middle
这个一个很好的小声明

00:33:49.936 --> 00:33:51.236 A:middle
而你还是获得了在

00:33:51.236 --> 00:33:52.386 A:middle
记忆初始化

00:33:52.386 --> 00:33:54.326 A:middle
获取默认设定的好处

00:33:56.436 --> 00:34:00.016 A:middle
好吧 所以 属性包装器事实上

00:34:00.016 --> 00:34:01.576 A:middle
还是很强大的

00:34:01.836 --> 00:34:03.756 A:middle
它们将访问数据的

00:34:03.756 --> 00:34:06.326 A:middle
这个策略概念抽象化了

00:34:06.536 --> 00:34:08.416 A:middle
所以你可以决定如何存储你的数据

00:34:08.656 --> 00:34:10.626 A:middle
而且你也可以决定如何访问你的数据

00:34:11.106 --> 00:34:12.766 A:middle
针对你的属性包装器 

00:34:12.766 --> 00:34:14.016 A:middle
你的用户要做的就是

00:34:14.156 --> 00:34:15.846 A:middle
使用那个自定义属性句法

00:34:16.266 --> 00:34:17.366 A:middle
来联系进你的系统

00:34:17.616 --> 00:34:19.616 A:middle
所以在我们开发

00:34:19.616 --> 00:34:20.906 A:middle
属性包装器时 我们发现了

00:34:20.906 --> 00:34:22.755 A:middle
针对它们的很多不同使用

00:34:23.335 --> 00:34:24.716 A:middle
都是围绕这类数据访问

00:34:24.716 --> 00:34:26.496 A:middle
的大致概念的

00:34:27.246 --> 00:34:28.525 A:middle
所以举个例子 你也许已经

00:34:28.525 --> 00:34:29.886 A:middle
看到用户默认示例

00:34:30.306 --> 00:34:31.525 A:middle
这里就是我们

00:34:31.525 --> 00:34:32.626 A:middle
建立的一个关系 这个关系在

00:34:32.626 --> 00:34:34.246 A:middle
你刚刚作为 Bool 引用的

00:34:34.246 --> 00:34:35.795 A:middle
Swift 中类型良好的属性

00:34:35.795 --> 00:34:37.466 A:middle
和一些字符串

00:34:37.466 --> 00:34:38.726 A:middle
类型实体之间

00:34:39.045 --> 00:34:40.085 A:middle
所以我们在结构参数中

00:34:40.085 --> 00:34:41.636 A:middle
明确描述了

00:34:41.815 --> 00:34:43.815 A:middle
如何继续并获取数据

00:34:44.246 --> 00:34:46.255 A:middle
处理用户默认的

00:34:46.255 --> 00:34:47.926 A:middle
所有逻辑 就在这个

00:34:47.926 --> 00:34:50.136 A:middle
用户默认属性包装器中完成了

00:34:51.076 --> 00:34:53.196 A:middle
所以我们构建 @ThreadSpecific

00:34:53.196 --> 00:34:54.446 A:middle
如果你想要以本地线程存储

00:34:55.356 --> 00:34:55.966 A:middle
你可以应用

00:34:55.966 --> 00:34:57.206 A:middle
ThreadSpecific 属性包装器

00:34:57.296 --> 00:34:58.426 A:middle
处理系统的线程相关

00:34:58.426 --> 00:35:00.176 A:middle
存储的所有细节

00:35:00.176 --> 00:35:02.376 A:middle
就都在属性包装器里面

00:35:02.556 --> 00:35:03.796 A:middle
你可以就把这个东西想成

00:35:03.906 --> 00:35:05.766 A:middle
一个本地的记忆池

00:35:06.756 --> 00:35:08.326 A:middle
还有 在 Swift 社区

00:35:08.326 --> 00:35:09.106 A:middle
正如我们已经

00:35:09.106 --> 00:35:10.636 A:middle
构建的这个功能 我们发现

00:35:11.376 --> 00:35:13.026 A:middle
在描述命令行参数时

00:35:13.026 --> 00:35:14.696 A:middle
它实现得非常好

00:35:14.696 --> 00:35:15.496 A:middle
如果你通过一个

00:35:15.496 --> 00:35:17.376 A:middle
库构建了一个命令行工具

00:35:17.376 --> 00:35:18.906 A:middle
用于记录

00:35:19.256 --> 00:35:20.476 A:middle
简写语法

00:35:20.476 --> 00:35:21.926 A:middle
意思是我想要 Minimum value

00:35:22.106 --> 00:35:23.426 A:middle
这就是 @Option 的描述

00:35:24.156 --> 00:35:25.276 A:middle
这就是用户传递的

00:35:25.276 --> 00:35:26.406 A:middle
缩写字符串

00:35:26.406 --> 00:35:27.516 A:middle
以及含义是什么

00:35:27.596 --> 00:35:28.776 A:middle
以及所有其他的东西

00:35:28.776 --> 00:35:31.026 A:middle
你需要非常非常简洁地

00:35:31.026 --> 00:35:32.936 A:middle
说明你的命令行选项

00:35:33.636 --> 00:35:34.666 A:middle
有很多真的非常酷

00:35:34.666 --> 00:35:35.916 A:middle
的东西我们可以通过

00:35:35.916 --> 00:35:37.046 A:middle
属性包装器完成

00:35:37.046 --> 00:35:38.756 A:middle
因为这个良好 干净的句法

00:35:38.756 --> 00:35:39.616 A:middle
可以生产一些东西

00:35:40.816 --> 00:35:42.456 A:middle
也许你在

00:35:42.456 --> 00:35:44.386 A:middle
另一场会议中已经了解了

00:35:44.386 --> 00:35:46.086 A:middle
我们在 SwiftUI 中广泛地

00:35:46.386 --> 00:35:48.636 A:middle
使用了属性包装器来描述

00:35:48.636 --> 00:35:50.906 A:middle
视图的数据依赖

00:35:52.016 --> 00:35:54.116 A:middle
在 Swift UI 中

00:35:54.116 --> 00:35:55.326 A:middle
有几个不同的

00:35:55.326 --> 00:35:56.896 A:middle
属性包装器存在

00:35:57.036 --> 00:35:58.556 A:middle
那么这里我们有一个 @State

00:35:58.556 --> 00:35:59.806 A:middle
来引入查看本地状态

00:36:01.716 --> 00:36:02.986 A:middle
我们有 @Binding 来

00:36:02.986 --> 00:36:04.236 A:middle
声明它是来自其他地方的

00:36:04.516 --> 00:36:05.036 A:middle
你也许已经看到了

00:36:05.036 --> 00:36:06.586 A:middle
@Environment 一个环境对象

00:36:07.676 --> 00:36:09.206 A:middle
所有的这些都是属性包装器

00:36:09.206 --> 00:36:10.636 A:middle
在 Swift 中以那种方式

00:36:10.636 --> 00:36:12.196 A:middle
描述它们的一个好处在于

00:36:12.196 --> 00:36:15.216 A:middle
你在明确你的策略

00:36:15.216 --> 00:36:17.216 A:middle
数据在哪里

00:36:17.216 --> 00:36:19.326 A:middle
它是如何被访问的

00:36:19.326 --> 00:36:20.506 A:middle
都可以在声明中给出

00:36:21.106 --> 00:36:22.306 A:middle
但是当你继续并构建你的视图时

00:36:22.306 --> 00:36:24.586 A:middle
你并不在意那个

00:36:24.716 --> 00:36:26.386 A:middle
你不在乎数据在哪里

00:36:26.556 --> 00:36:28.136 A:middle
系统为你管理好了

00:36:28.926 --> 00:36:30.536 A:middle
你就可以查看

00:36:30.536 --> 00:36:32.216 A:middle
Keynote 讲演的

00:36:32.216 --> 00:36:32.806 A:middle
特定的一页

00:36:33.536 --> 00:36:34.266 A:middle
输入数字

00:36:34.716 --> 00:36:35.696 A:middle
如果你想要继续并编辑

00:36:35.696 --> 00:36:38.426 A:middle
一些东西 那么你可以使

00:36:39.376 --> 00:36:41.726 A:middle
找到实际捆绑的幻灯片

00:36:42.776 --> 00:36:45.996 A:middle
所以 处理数据的

00:36:45.996 --> 00:36:47.736 A:middle
所有逻辑 以及观察

00:36:47.776 --> 00:36:49.096 A:middle
变化更新 或者甚至是

00:36:49.096 --> 00:36:50.256 A:middle
在存储数据

00:36:50.476 --> 00:36:51.946 A:middle
在属性包装器类型中

00:36:51.946 --> 00:36:53.696 A:middle
的策略里都解决了

00:36:53.976 --> 00:36:55.116 A:middle
你不需要考虑

00:36:55.336 --> 00:36:56.766 A:middle
你只需要考虑处理

00:36:56.766 --> 00:36:57.626 A:middle
你实际的数据

00:36:58.306 --> 00:37:00.136 A:middle
现在 在这页幻灯片上

00:37:00.136 --> 00:37:01.796 A:middle
有一个东西有点意思

00:37:02.436 --> 00:37:04.906 A:middle
那么这是 $slide.title

00:37:05.546 --> 00:37:06.736 A:middle
我们将其传递 这样就可以

00:37:06.876 --> 00:37:08.506 A:middle
在文本框编辑页标题

00:37:09.986 --> 00:37:12.566 A:middle
$slide 我们之前已经看到过了

00:37:12.646 --> 00:37:14.486 A:middle
那是备份存储属性

00:37:14.486 --> 00:37:15.356 A:middle
那就是编译器

00:37:15.356 --> 00:37:16.836 A:middle
为我们进行合成

00:37:17.176 --> 00:37:19.546 A:middle
因为我们在这里应用了

00:37:19.546 --> 00:37:20.436 A:middle
Binding 属性包装器

00:37:21.826 --> 00:37:23.236 A:middle
但在 Binding 中

00:37:23.686 --> 00:37:24.676 A:middle
是没有标题的

00:37:26.066 --> 00:37:28.096 A:middle
标题是我的数据模型的一部分

00:37:28.096 --> 00:37:29.096 A:middle
我一个幻灯片的数据模型

00:37:29.186 --> 00:37:29.646 A:middle
那么这给了我们什么呢

00:37:30.086 --> 00:37:32.426 A:middle
所以 实际上这是一个

00:37:32.426 --> 00:37:34.446 A:middle
属性包装器和

00:37:34.446 --> 00:37:36.716 A:middle
先前 Ben 讲到的关键路径成员

00:37:36.716 --> 00:37:39.226 A:middle
查找功能的结合

00:37:39.806 --> 00:37:42.256 A:middle
那么这样的话 让我们实际来

00:37:42.306 --> 00:37:43.896 A:middle
关注 @Binding

00:37:43.896 --> 00:37:45.526 A:middle
也就是在 Swift UI 里的东西 并且提供了

00:37:45.526 --> 00:37:46.816 A:middle
这个高级引用

00:37:47.136 --> 00:37:49.646 A:middle
首先也是最重要的 Binding

00:37:49.646 --> 00:37:50.416 A:middle
是一个属性包装器

00:37:50.946 --> 00:37:53.736 A:middle
所以它有 value

00:37:53.736 --> 00:37:55.166 A:middle
可以以任何类型的参数存在

00:37:55.166 --> 00:37:56.786 A:middle
因为你可以对任何东西进行捆绑

00:37:57.096 --> 00:37:59.416 A:middle
它有着任何样式的访问权限

00:37:59.416 --> 00:38:00.106 A:middle
这并不重要

00:38:00.276 --> 00:38:02.456 A:middle
我们并不知道这是什么

00:38:02.456 --> 00:38:04.426 A:middle
因为是由框架为我们处理的

00:38:04.536 --> 00:38:07.646 A:middle
通过泛型下标

00:38:07.646 --> 00:38:09.306 A:middle
捆绑也是支持关键

00:38:09.346 --> 00:38:12.716 A:middle
路径成员查找的泛型下标

00:38:12.766 --> 00:38:13.506 A:middle
有点儿拗口

00:38:13.566 --> 00:38:14.486 A:middle
我们不需要知道

00:38:14.486 --> 00:38:15.756 A:middle
是怎么实现的

00:38:15.756 --> 00:38:16.466 A:middle
但是我们应该更加仔细地

00:38:16.466 --> 00:38:17.606 A:middle
看一看类型签名

00:38:17.606 --> 00:38:18.676 A:middle
因为它很有趣

00:38:19.096 --> 00:38:21.476 A:middle
那么 我们已经讲过了关键路径

00:38:21.986 --> 00:38:24.966 A:middle
它与特定的值类型紧密联系

00:38:24.966 --> 00:38:26.766 A:middle
所以我们在进行捆绑的东西

00:38:27.006 --> 00:38:30.656 A:middle
比如幻灯片页

00:38:30.656 --> 00:38:33.466 A:middle
以及在那个特定实体里访问任何属性

00:38:34.186 --> 00:38:36.076 A:middle
这里返回的不是一个值

00:38:36.076 --> 00:38:39.146 A:middle
不是引用一些东西

00:38:39.396 --> 00:38:41.256 A:middle
我们返回的是一个新的捆绑

00:38:41.666 --> 00:38:43.426 A:middle
它的焦点在于外部捆绑的

00:38:43.426 --> 00:38:45.976 A:middle
某一个特定的属性

00:38:45.976 --> 00:38:48.936 A:middle
仍然保持着数据依赖

00:38:52.806 --> 00:38:54.356 A:middle
那么 在实际操作中这是怎么样的呢

00:38:54.356 --> 00:38:56.556 A:middle
好吧 我们有 slide

00:38:56.556 --> 00:38:58.206 A:middle
捆绑在我们的 Slide 类型上

00:38:58.916 --> 00:39:00.696 A:middle
基本上 我们将其

00:39:00.696 --> 00:39:01.526 A:middle
视作是一个值

00:39:01.526 --> 00:39:02.636 A:middle
所以我们可以引用 slide

00:39:02.636 --> 00:39:03.496 A:middle
我们得到了一个 slide 实例

00:39:03.496 --> 00:39:04.986 A:middle
我们可以引用 slide.title 并且

00:39:04.986 --> 00:39:06.406 A:middle
获得那个字符串的实例

00:39:06.676 --> 00:39:07.626 A:middle
同时在后台

00:39:08.186 --> 00:39:10.176 A:middle
追踪所有修改

00:39:10.756 --> 00:39:13.376 A:middle
如果我们输入 $Slide 好的

00:39:13.436 --> 00:39:15.336 A:middle
我们将那个捆绑的实例放到了 slide 中

00:39:15.946 --> 00:39:19.506 A:middle
当我们输入 $slide.title 好的

00:39:19.506 --> 00:39:20.626 A:middle
现在我们在查找一个属性

00:39:20.626 --> 00:39:22.316 A:middle
它并不在捆绑中

00:39:22.316 --> 00:39:24.056 A:middle
所以编译器将其进行了重写

00:39:24.126 --> 00:39:26.266 A:middle
将其变成使用动态数字下标

00:39:26.266 --> 00:39:28.696 A:middle
将一个关键路径

00:39:29.216 --> 00:39:30.276 A:middle
放进 slide.title

00:39:31.536 --> 00:39:33.126 A:middle
这解析的方式是

00:39:33.126 --> 00:39:34.586 A:middle
将一个焦点捆绑点

00:39:34.866 --> 00:39:37.846 A:middle
变成字符串属性

00:39:37.956 --> 00:39:39.776 A:middle
它位于之前的捆绑中

00:39:39.806 --> 00:39:40.826 A:middle
并且遵循所有的

00:39:40.826 --> 00:39:41.706 A:middle
数据依赖

00:39:42.656 --> 00:39:44.946 A:middle
那么 如果我们抛开

00:39:44.946 --> 00:39:46.246 A:middle
之前我们一直在关注的

00:39:46.246 --> 00:39:48.136 A:middle
语言机制然后

00:39:48.136 --> 00:39:49.286 A:middle
看一看我们在这里进行的

00:39:49.286 --> 00:39:51.246 A:middle
高级代码 会非常好

00:39:51.246 --> 00:39:52.416 A:middle
在属性包装器里

00:39:52.416 --> 00:39:54.096 A:middle
使用这个自定义属性

00:39:54.096 --> 00:39:55.216 A:middle
我们建立了数据依赖

00:39:55.976 --> 00:39:57.086 A:middle
我们有访问我们数据的

00:39:57.086 --> 00:39:59.276 A:middle
基础权限 很容易读取

00:39:59.276 --> 00:39:59.906 A:middle
或者进行修改

00:39:59.906 --> 00:40:01.546 A:middle
如果我们想要通过

00:40:01.546 --> 00:40:02.536 A:middle
我们的捆绑传递一个

00:40:02.536 --> 00:40:04.506 A:middle
高级引用 我们把这个前缀 $

00:40:04.506 --> 00:40:05.796 A:middle
放在它的前面

00:40:05.876 --> 00:40:06.806 A:middle
我们获得的影响是

00:40:06.806 --> 00:40:07.836 A:middle
我们总是可以向

00:40:07.836 --> 00:40:09.886 A:middle
一些其他视图传递一个捆绑

00:40:11.616 --> 00:40:15.416 A:middle
那么 我们已经讲到了一些

00:40:15.416 --> 00:40:16.146 A:middle
不同的主题

00:40:16.146 --> 00:40:17.586 A:middle
我们讲到了值语义

00:40:17.646 --> 00:40:19.556 A:middle
和引用语义

00:40:19.556 --> 00:40:21.096 A:middle
何时去使用两者以及如何

00:40:21.096 --> 00:40:21.936 A:middle
让它们协作运行

00:40:23.076 --> 00:40:24.116 A:middle
我们也谈到了

00:40:24.116 --> 00:40:25.596 A:middle
泛型和协议的使用

00:40:26.336 --> 00:40:28.476 A:middle
请记住 协议是极其强大的

00:40:28.596 --> 00:40:30.686 A:middle
但是用它们来进行代码重用

00:40:30.686 --> 00:40:31.716 A:middle
这就是它们的作用

00:40:32.086 --> 00:40:33.606 A:middle
而不是用来分类或者

00:40:33.606 --> 00:40:34.966 A:middle
构建庞大的继承结构

00:40:34.966 --> 00:40:35.906 A:middle
因为它们会阻碍你

00:40:35.986 --> 00:40:37.706 A:middle
你不需要这么做

00:40:37.996 --> 00:40:41.326 A:middle
最后 我们深入讲了讲

00:40:41.326 --> 00:40:43.526 A:middle
属性包装器语言功能

00:40:43.526 --> 00:40:45.746 A:middle
以及如何用它来

00:40:45.796 --> 00:40:47.186 A:middle
抽象访问数据

00:40:48.476 --> 00:40:48.776 A:middle
好的

00:40:48.876 --> 00:40:49.846 A:middle
非常感谢你们

00:40:50.416 --> 00:40:51.816 A:middle
如果你想要就任何这些话题进行讨论

00:40:51.816 --> 00:40:53.466 A:middle
欢迎来我们的实验室

00:40:54.516 --> 00:40:59.500 A:middle
[掌声]

