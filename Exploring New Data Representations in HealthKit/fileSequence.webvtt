WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:06.139 --> 00:00:09.843 align:middle line:0
（在HealthKit中
探究新数据表达）

00:00:12.212 --> 00:00:13.146 align:middle line:-1
下午好

00:00:13.914 --> 00:00:15.249 align:middle line:-1
我是Luke Spicer

00:00:15.315 --> 00:00:17.117 align:middle line:-1
今天我和我的同事Divya

00:00:17.184 --> 00:00:20.454 align:middle line:-1
要与大家分享HealthKit

00:00:20.521 --> 00:00:22.756 align:middle line:-1
如何在iOS 13中扩展数据表达

00:00:25.192 --> 00:00:26.660 align:middle line:-1
有许多人已经知道

00:00:27.027 --> 00:00:31.098 align:middle line:-2
HealthKit针对健康和健身
数据提供集中式数据存储

00:00:31.598 --> 00:00:35.235 align:middle line:-2
并且还为健康和健身app和体验
提供互操作性

00:00:36.370 --> 00:00:38.872 align:middle line:-2
如果你还不了解
HealthKit的使用

00:00:39.239 --> 00:00:42.476 align:middle line:-2
让我来提醒你一下
在App Store的

00:00:42.543 --> 00:00:44.578 align:middle line:-2
健康与健身类中
有七万多个app

00:00:44.978 --> 00:00:48.081 align:middle line:-2
并且它们均可
从HealthKit所提供的

00:00:48.148 --> 00:00:50.117 align:middle line:-1
互操作性和功能性中受益

00:00:51.652 --> 00:00:53.287 align:middle line:-2
今天我要讲一些
与HealthKit中的

00:00:53.353 --> 00:00:55.155 align:middle line:-1
数据表达相关的信息

00:00:55.889 --> 00:00:58.158 align:middle line:-2
从回顾HealthKit
数据模型开始

00:00:58.225 --> 00:00:59.059 align:middle line:-1
（HealthKit数据模型）

00:00:59.126 --> 00:01:02.329 align:middle line:-2
然后我要讲一些
主要应用于量化数据的特定API

00:01:03.664 --> 00:01:06.433 align:middle line:-2
稍后Divya会上台
来讲每搏测量、

00:01:06.834 --> 00:01:07.835 align:middle line:-1
心率事件

00:01:08.569 --> 00:01:11.572 align:middle line:-1
和有关听力健康的全新的API

00:01:13.207 --> 00:01:16.310 align:middle line:-2
让我们从HealthKit
数据模型开始讲

00:01:17.945 --> 00:01:19.646 align:middle line:-2
在HealthKit中
我们表达数据…

00:01:21.215 --> 00:01:23.317 align:middle line:-2
在HealthKit中
我们用样本表达数据

00:01:23.884 --> 00:01:26.186 align:middle line:-1
样本是在特定时间所进行的测量

00:01:26.553 --> 00:01:28.222 align:middle line:-1
有一定的时间跨度

00:01:29.656 --> 00:01:32.759 align:middle line:-1
绝大多数测量都是简单测量

00:01:33.160 --> 00:01:35.429 align:middle line:-2
比如通过
Apple Watch测量的心率

00:01:36.530 --> 00:01:40.300 align:middle line:-2
或通过已连接的Bluetooth
进行的身体质量测量

00:01:42.503 --> 00:01:44.605 align:middle line:-1
其它测量更加丰富和复杂

00:01:45.038 --> 00:01:47.207 align:middle line:-1
比如锻炼或临床病例

00:01:47.274 --> 00:01:49.176 align:middle line:-1
可直接下载到iPhone上

00:01:51.645 --> 00:01:55.215 align:middle line:-1
所有这些丰富的、复杂的数据表达

00:01:55.282 --> 00:01:56.350 align:middle line:-1
都共享一个通用结构

00:01:56.817 --> 00:02:00.087 align:middle line:-2
最高层级的样本
以一些专业数据表达为支撑

00:02:01.188 --> 00:02:02.222 align:middle line:-1
比如…

00:02:03.557 --> 00:02:06.960 align:middle line:-1
血压测量可以表达为一个相关样本

00:02:07.528 --> 00:02:09.830 align:middle line:-1
过敏资源来自病例

00:02:10.564 --> 00:02:13.567 align:middle line:-1
健身路线来自一系列样本

00:02:14.134 --> 00:02:16.737 align:middle line:-1
这些都是专业样本类型的示例

00:02:17.137 --> 00:02:19.540 align:middle line:-1
都有各自独特的备份数据格式

00:02:20.641 --> 00:02:22.509 align:middle line:-1
比如血压相关样本

00:02:22.576 --> 00:02:24.011 align:middle line:-1
是一组血压测量

00:02:24.578 --> 00:02:26.947 align:middle line:-1
过敏资源依赖于文件资源

00:02:28.282 --> 00:02:30.817 align:middle line:-1
健身路线是CL位置数据的一个数组

00:02:31.618 --> 00:02:34.988 align:middle line:-2
正因为HealthKit
对这些特殊的测量类型

00:02:35.055 --> 00:02:36.557 align:middle line:-1
提供这些专业数据表达

00:02:37.191 --> 00:02:39.893 align:middle line:-1
我们也针对最常见的测量类型

00:02:39.960 --> 00:02:41.461 align:middle line:-1
对数据表达进行了扩展

00:02:41.828 --> 00:02:42.796 align:middle line:-1
适用于量化数据

00:02:43.430 --> 00:02:45.933 align:middle line:-1
我们继续讲一下量化数据

00:02:45.999 --> 00:02:47.301 align:middle line:-1
（新的量化系列API）

00:02:48.502 --> 00:02:49.570 align:middle line:-1
快速回顾一下

00:02:49.937 --> 00:02:53.540 align:middle line:-2
HealthKit中的量化数据
适用于一些很常见的测量概念

00:02:54.908 --> 00:02:56.176 align:middle line:-1
比如步行距离、

00:02:56.543 --> 00:02:58.145 align:middle line:-1
身体质量和心率

00:02:59.046 --> 00:03:02.015 align:middle line:-2
我们把所有这些概念
都看作是量化类型

00:03:02.816 --> 00:03:04.785 align:middle line:-1
它们的测量看起来类似这样

00:03:06.720 --> 00:03:10.357 align:middle line:-2
每个测量都包含一个量化数据
它是一个值

00:03:10.724 --> 00:03:13.160 align:middle line:-1
和一个单位 以及一个时间区间

00:03:13.227 --> 00:03:15.629 align:middle line:-1
那表明测量所发生的时间区间

00:03:16.496 --> 00:03:18.732 align:middle line:-2
我们把每一个这样的测量
都叫做量化样本

00:03:20.400 --> 00:03:22.536 align:middle line:-1
根据这个描述 我们要讲

00:03:23.303 --> 00:03:25.005 align:middle line:-1
量化类型和量化样本

00:03:25.305 --> 00:03:27.908 align:middle line:-1
特别是如何有效地表达

00:03:27.975 --> 00:03:29.142 align:middle line:-1
大量的量化数据

00:03:29.676 --> 00:03:31.712 align:middle line:-2
但如果你想了解
关于这些概念的更多介绍

00:03:32.045 --> 00:03:34.581 align:middle line:-1
请参看我们2014年的演讲

00:03:34.982 --> 00:03:36.049 align:middle line:-1
关于HealthKit的介绍

00:03:37.317 --> 00:03:38.886 align:middle line:-1
为了继续推进我们对量化数据的讨论

00:03:38.952 --> 00:03:40.020 align:middle line:-1
我想描述一个情境

00:03:40.988 --> 00:03:43.090 align:middle line:-1
如果可以 请你想象一下

00:03:43.156 --> 00:03:45.092 align:middle line:-1
我们正在做一个全新的app

00:03:45.926 --> 00:03:48.762 align:middle line:-2
这个app连接了一个
以前从未见过的心率传感器

00:03:49.029 --> 00:03:51.131 align:middle line:-1
它被嵌入了一个视频游戏控制器中

00:03:52.132 --> 00:03:54.835 align:middle line:-2
我们的任务是
从这个心率传感器获取测量数据

00:03:54.902 --> 00:03:56.069 align:middle line:-2
并把它们保存到
HealthKit中

00:03:56.136 --> 00:03:58.138 align:middle line:-1
从而用户可以了解他们的心率是多少

00:03:58.205 --> 00:03:59.806 align:middle line:-1
当他们玩任意一款游戏时

00:04:03.810 --> 00:04:05.179 align:middle line:0
看起来就像这样

00:04:05.245 --> 00:04:07.548 align:middle line:0
一系列测量数据
会随时间进入我们的app

00:04:07.814 --> 00:04:09.149 align:middle line:0
当用户玩游戏时

00:04:09.816 --> 00:04:11.952 align:middle line:0
我们需要决定如何表达这个数据

00:04:12.219 --> 00:04:13.353 align:middle line:0
我们可以把它
保存到HealthKit中

00:04:14.655 --> 00:04:15.956 align:middle line:-1
我们可以采用的一种方法是

00:04:16.023 --> 00:04:18.125 align:middle line:-1
使用单一量化样本

00:04:18.825 --> 00:04:20.327 align:middle line:-1
看起来就像这样

00:04:21.394 --> 00:04:24.198 align:middle line:-2
这个单一量化样本
跨越了整个测量间隔

00:04:24.631 --> 00:04:26.667 align:middle line:-1
就是游戏的整个时长

00:04:27.067 --> 00:04:29.002 align:middle line:-1
并通过单一量化来表达

00:04:29.069 --> 00:04:30.571 align:middle line:-1
我们从传感器中接收的全部测量数据

00:04:30.938 --> 00:04:31.905 align:middle line:-1
也许是平均值

00:04:33.273 --> 00:04:35.142 align:middle line:-1
这个表达为我们提供了一个对象

00:04:35.742 --> 00:04:38.545 align:middle line:-2
来表达我们所获取的测量数据
即这个游戏过程中的心率

00:04:39.213 --> 00:04:42.282 align:middle line:-2
但如果稍后我们想了解
游戏结束后心率的变化

00:04:42.349 --> 00:04:44.785 align:middle line:-1
我们就没办法通过这种表达来实现

00:04:46.420 --> 00:04:47.955 align:middle line:-1
我们可以采取的另一种表达是

00:04:48.322 --> 00:04:51.859 align:middle line:-1
使用多个量化样本 看起来就像这样

00:04:52.459 --> 00:04:55.629 align:middle line:-1
每一个测量都表达不同的量化样本

00:04:56.697 --> 00:04:59.566 align:middle line:-1
这种表达允许我们保留

00:04:59.633 --> 00:05:00.701 align:middle line:-1
由传感器测量的全部数据

00:05:01.201 --> 00:05:05.339 align:middle line:-2
但这种数据表达并没有那么有效率
因为我们有冗余数据

00:05:05.973 --> 00:05:07.441 align:middle line:-1
全部这些量化样本

00:05:07.508 --> 00:05:09.943 align:middle line:-1
都有相同的元数据和设备信息

00:05:10.844 --> 00:05:13.480 align:middle line:-1
我们不再拥有那个便利的单一对象了

00:05:13.547 --> 00:05:15.616 align:middle line:-2
就是那个表达我们实际上
所获取的测量数据的单一对象

00:05:15.682 --> 00:05:17.317 align:middle line:-1
在游戏过程中是心率

00:05:18.752 --> 00:05:21.121 align:middle line:-1
谢天谢地 我们可以采用第三种方法

00:05:21.455 --> 00:05:23.090 align:middle line:-1
我们把它叫做量化系列

00:05:24.091 --> 00:05:26.894 align:middle line:-1
量化系列表达看起来像这样

00:05:28.028 --> 00:05:29.796 align:middle line:-1
单一量化样本

00:05:29.863 --> 00:05:31.598 align:middle line:-1
跨越了整个测量时间

00:05:32.432 --> 00:05:34.735 align:middle line:-2
但在这种情况下
我们不获取单一量化数据

00:05:35.035 --> 00:05:37.037 align:middle line:-1
而是多个量化数据

00:05:38.372 --> 00:05:41.808 align:middle line:-1
这种表达利用了以上两种方法的优点

00:05:42.109 --> 00:05:43.944 align:middle line:-1
用单一对象表达测量数据

00:05:44.611 --> 00:05:47.514 align:middle line:-2
会保留从传感器中获取的
全部测量数据

00:05:48.615 --> 00:05:52.085 align:middle line:-1
请注意我们移除了

00:05:52.152 --> 00:05:54.688 align:middle line:-2
之前存在于
单个量化样本上的冗余信息

00:05:54.755 --> 00:05:57.724 align:middle line:-2
因此我们在量化系列样本层级
我们只存储单一副本

00:05:58.625 --> 00:06:01.328 align:middle line:-1
我们都想尊重用户的设备存储

00:06:01.828 --> 00:06:03.130 align:middle line:-1
和设备性能

00:06:03.197 --> 00:06:05.132 align:middle line:-1
这种表达就可以让我们实现这个目的

00:06:07.000 --> 00:06:09.336 align:middle line:-1
因为量化系列样本是一种量化样本

00:06:10.037 --> 00:06:14.508 align:middle line:-2
我们需要一种方式来表达
有单一值的量化数据的顺序

00:06:15.242 --> 00:06:17.778 align:middle line:-2
并且在HealthKit中
我们通过一种叫做聚合的技术来实现

00:06:19.079 --> 00:06:22.783 align:middle line:-2
我们有两个主要的聚合类型：
积累和离散

00:06:23.550 --> 00:06:24.818 align:middle line:-1
积累聚合类型

00:06:25.152 --> 00:06:27.955 align:middle line:-2
适用于一些很常见的量化类型
比如距离、

00:06:28.021 --> 00:06:29.156 align:middle line:-1
卡路里和步数

00:06:30.090 --> 00:06:32.726 align:middle line:-2
全部这些量化类型
都被用户持续地累积

00:06:32.793 --> 00:06:35.596 align:middle line:-2
他们走更多的步数
燃烧更多的卡路里

00:06:35.662 --> 00:06:36.830 align:middle line:-1
和移动更远的距离

00:06:37.865 --> 00:06:41.134 align:middle line:-2
执行累积的最自然的方式—
针对这些类型

00:06:41.201 --> 00:06:42.936 align:middle line:-2
聚合多个量化数据的最自然的方式
是用合计

00:06:44.872 --> 00:06:45.939 align:middle line:-1
另一方面

00:06:46.240 --> 00:06:49.376 align:middle line:-2
我们还有一些其它常见的量化类型
不适用合计

00:06:50.277 --> 00:06:52.846 align:middle line:-1
比如心率、身体质量和身高

00:06:53.914 --> 00:06:55.883 align:middle line:-1
如果合计在一起没有任何意义

00:06:55.949 --> 00:06:58.218 align:middle line:-2
如果你一天量好几次心率
并把它们加在一起

00:06:58.886 --> 00:06:59.953 align:middle line:-1
你会得到一个荒谬的值

00:07:04.324 --> 00:07:07.294 align:middle line:-1
取平均值 也许是其它聚合统计

00:07:07.661 --> 00:07:10.063 align:middle line:-1
比如最小值、最大值和最新值

00:07:12.533 --> 00:07:17.037 align:middle line:-2
再一次 我们可以看到
一系列的累积量化数据

00:07:17.337 --> 00:07:19.306 align:middle line:-1
可以通过合计来表达和聚合

00:07:20.207 --> 00:07:22.709 align:middle line:-1
而一系列的离散量化数据比如心率

00:07:23.177 --> 00:07:26.513 align:middle line:-1
将被聚合来产生一些统计数据

00:07:26.580 --> 00:07:29.316 align:middle line:-2
比如最小值、最大值、
平均值和最新值

00:07:31.385 --> 00:07:33.787 align:middle line:-2
在HealthKit中
我们使用量化聚合类型

00:07:33.854 --> 00:07:36.356 align:middle line:-1
来提供指定量化类型的聚合类型

00:07:37.291 --> 00:07:38.425 align:middle line:-1
并且在iOS 13中

00:07:39.026 --> 00:07:41.695 align:middle line:-1
我们决定不使用离散聚合类型

00:07:41.762 --> 00:07:46.333 align:middle line:-1
而使用一种新的离散算法聚合类型

00:07:47.067 --> 00:07:49.603 align:middle line:-2
我们之所以这样做是为了明确
根据这种聚合类型

00:07:49.670 --> 00:07:52.606 align:middle line:-2
所计算出来的平均值
是简单的算数平均数

00:07:53.674 --> 00:07:56.610 align:middle line:-1
我们还引入了一些新的聚合类型

00:07:56.977 --> 00:07:59.179 align:middle line:-2
让我们从
discreteTemporallyWeighted开始讲

00:07:59.580 --> 00:08:02.616 align:middle line:-2
它是一种特殊的聚合类型
使用时间加权平均值

00:08:03.016 --> 00:08:05.085 align:middle line:-1
应用于当我们聚合心率量化数据时

00:08:06.420 --> 00:08:09.456 align:middle line:-2
我们还添加了
discreteEquivalent ContinuousLevel

00:08:10.023 --> 00:08:13.460 align:middle line:-2
它是一种特殊的聚合类型
适用于音频暴露量化数据

00:08:14.361 --> 00:08:17.264 align:middle line:-1
Divya稍后会具体讲音频暴露

00:08:19.633 --> 00:08:22.503 align:middle line:-2
现在我们了解了如何聚合
多个量化数据

00:08:23.203 --> 00:08:24.571 align:middle line:-1
来生产统计数据

00:08:24.938 --> 00:08:27.774 align:middle line:-2
我们需要一个地方来存储
量化样本上的这个信息

00:08:28.909 --> 00:08:30.210 align:middle line:-2
我们在iOS 13中
实现了这个功能

00:08:30.277 --> 00:08:32.980 align:middle line:-1
通过引入两个新量化样本子类实现

00:08:33.046 --> 00:08:34.881 align:middle line:-1
从累积量化样本开始

00:08:34.948 --> 00:08:36.149 align:middle line:-1
它有一个合计属性

00:08:36.549 --> 00:08:37.885 align:middle line:-1
并且离散量化样本

00:08:38.352 --> 00:08:39.419 align:middle line:-1
它有

00:08:39.919 --> 00:08:42.890 align:middle line:-2
平均值、最小值、最大值
和最新值量化属性

00:08:43.991 --> 00:08:47.427 align:middle line:-1
我们还把量化样本作为抽象基类

00:08:47.895 --> 00:08:50.898 align:middle line:-1
意思是从现在起

00:08:50.964 --> 00:08:52.065 align:middle line:-1
你所交互的量化样本的全部实体

00:08:52.366 --> 00:08:55.302 align:middle line:-1
都将是这两个量化样本子类中的一个

00:08:55.369 --> 00:08:57.704 align:middle line:-1
取决于量化类型的聚合类型

00:08:58.972 --> 00:09:00.407 align:middle line:-1
并且我还想提醒一下

00:09:00.474 --> 00:09:03.577 align:middle line:-2
全部量化样本都可以被看作是
量化系列

00:09:03.944 --> 00:09:06.647 align:middle line:-2
只不过其中有些恰好只有一个
量化样本

00:09:07.948 --> 00:09:10.751 align:middle line:-1
我们还为这两个新样本类型

00:09:11.018 --> 00:09:12.486 align:middle line:-2
引入了相应的
Predicate键径

00:09:14.188 --> 00:09:17.324 align:middle line:-1
你可以查询这两种样本的相应属性

00:09:18.892 --> 00:09:20.894 align:middle line:-1
返回到我们的量化系列样本例子中

00:09:21.695 --> 00:09:23.797 align:middle line:-1
我们可以看到量化系列样本

00:09:23.864 --> 00:09:25.999 align:middle line:-1
可以通过我们的聚合统计进行合计

00:09:26.066 --> 00:09:27.668 align:middle line:-1
平均值、最小值、最大值和最新值

00:09:29.203 --> 00:09:32.039 align:middle line:-1
现在我要讲如何创建这种量化系列

00:09:33.140 --> 00:09:34.241 align:middle line:0
（创建量化系列）

00:09:34.308 --> 00:09:35.843 align:middle line:0
我们要从测量开始时

00:09:35.909 --> 00:09:37.377 align:middle line:0
讲量化系列

00:09:37.878 --> 00:09:39.580 align:middle line:0
在这个情境中是指游戏开始

00:09:40.814 --> 00:09:43.150 align:middle line:0
然后我们将收到
来自传感器的测量数据

00:09:43.217 --> 00:09:45.052 align:middle line:0
我们可以把它们插入到
这个量化系列中

00:09:45.485 --> 00:09:47.654 align:middle line:0
我们继续从传感器中获取测量数据

00:09:47.721 --> 00:09:49.256 align:middle line:0
并继续把它们插入到量化系列中

00:09:49.690 --> 00:09:51.158 align:middle line:0
一直到游戏结束

00:09:52.593 --> 00:09:54.127 align:middle line:0
最后当我们完成测量后

00:09:54.194 --> 00:09:55.796 align:middle line:-1
我们就可以结束量化系列

00:09:55.863 --> 00:09:58.799 align:middle line:-1
并返回合计的量化系列样本

00:10:05.772 --> 00:10:07.975 align:middle line:-2
所有HealthKit交互的
第一步

00:10:08.509 --> 00:10:12.045 align:middle line:-2
都是请求
计划要读取的数据类型的授权

00:10:12.446 --> 00:10:15.182 align:middle line:-1
在这个例子中我们要请求心率的授权

00:10:16.083 --> 00:10:17.484 align:middle line:-1
一旦我们请求了授权

00:10:18.519 --> 00:10:21.555 align:middle line:-2
我们就可以通过healthStore
创建量化系列样本创建器

00:10:21.622 --> 00:10:22.589 align:middle line:-1
数据类型

00:10:22.956 --> 00:10:25.526 align:middle line:-1
开始测量的时间和可选的HK设备

00:10:27.895 --> 00:10:30.197 align:middle line:-2
然后 只要我们收到
来自传感器的测量数据

00:10:30.264 --> 00:10:32.966 align:middle line:-2
我们就可以把它们插入到
量化系列样本创建器中

00:10:33.734 --> 00:10:35.536 align:middle line:-1
最后在游戏结束时

00:10:35.903 --> 00:10:37.704 align:middle line:-1
我们可以完成量化系列样本创建器

00:10:38.405 --> 00:10:40.807 align:middle line:-1
通过可选的元数据和测量结束时间

00:10:42.910 --> 00:10:46.246 align:middle line:-2
现在我们已经了解
如何有效率地表达量化数据

00:10:46.313 --> 00:10:47.814 align:middle line:-2
并把它作为量化系列
保存到HealthKit中

00:10:48.315 --> 00:10:51.084 align:middle line:-2
我们还可以思考通过数据
可以给app带来哪些体验

00:10:51.151 --> 00:10:52.819 align:middle line:-2
一旦数据被保存到
HealthKit中

00:10:53.887 --> 00:10:57.457 align:middle line:-1
也许我们想让app能记录

00:10:57.524 --> 00:10:58.458 align:middle line:-1
除心率以外的卡路里信息

00:10:58.926 --> 00:11:02.262 align:middle line:-2
因此我们可以给用户显示在某个时间
间隔内他们总共燃烧了多少卡路里

00:11:02.329 --> 00:11:05.933 align:middle line:-1
或只呈现一些很漂亮的图表

00:11:06.233 --> 00:11:08.035 align:middle line:-1
突显数据并帮助他们将数据可视化

00:11:08.101 --> 00:11:09.102 align:middle line:-2
（量化数据的查询
所燃烧的卡路里总量）

00:11:09.169 --> 00:11:10.437 align:middle line:-1
或者我们想指出平均值

00:11:10.504 --> 00:11:12.339 align:middle line:-1
是在某一个时间段内记录的平均值

00:11:12.406 --> 00:11:13.373 align:middle line:-2
（图表的数据
每天所燃烧的平均卡路里数）

00:11:13.440 --> 00:11:14.341 align:middle line:-1
（最小和最大心率）

00:11:14.408 --> 00:11:16.610 align:middle line:-2
或帮助用户了解
他们在某个特定游戏中

00:11:16.677 --> 00:11:18.045 align:middle line:-1
所达到的最小和最大心率值

00:11:19.146 --> 00:11:22.983 align:middle line:-1
或我们只想保持UI活跃并在收到

00:11:23.050 --> 00:11:25.586 align:middle line:-2
来自传感器的数据时
更新所记录的新数据

00:11:25.652 --> 00:11:26.787 align:middle line:-1
（最新心率）

00:11:27.554 --> 00:11:30.958 align:middle line:-2
我们可以实现这个功能并做得更好
通过单一HealthKit查询

00:11:33.427 --> 00:11:35.162 align:middle line:-1
HKStatisticsCollectionQuery

00:11:36.597 --> 00:11:39.266 align:middle line:-2
很多人已经熟悉
StatisticsCollectionQuery了

00:11:39.833 --> 00:11:41.401 align:middle line:-1
它非常棒

00:11:41.468 --> 00:11:43.837 align:middle line:-1
因此我只想重申它的功能

00:11:44.872 --> 00:11:48.709 align:middle line:-2
StatisticsCollectionQuery
可以帮助你计算多个统计

00:11:49.109 --> 00:11:50.878 align:middle line:-1
可以通过资料来源分隔开

00:11:51.745 --> 00:11:54.014 align:middle line:-2
并且只要有新数据
保存到HealthKit中

00:11:54.081 --> 00:11:55.782 align:middle line:-1
你就可以收到那些统计的更新数据

00:11:55.849 --> 00:11:57.351 align:middle line:-2
（生产多个统计
每个源可用的统计）

00:11:57.417 --> 00:11:58.585 align:middle line:-1
如果那还不够

00:11:58.652 --> 00:12:01.154 align:middle line:-2
我们还更新了
StatisticsCollectionQuery

00:12:01.221 --> 00:12:03.590 align:middle line:-1
用于支持新的聚合类型

00:12:04.157 --> 00:12:07.394 align:middle line:-2
并自动包含
存储在量化系列样本中的

00:12:07.461 --> 00:12:08.762 align:middle line:-1
（支持全部聚合类型）

00:12:09.062 --> 00:12:10.864 align:middle line:-1
全部备份量化数据

00:12:10.931 --> 00:12:11.832 align:middle line:-1
（自动包含量化系列数据）

00:12:12.165 --> 00:12:15.202 align:middle line:-2
如果你想获得关于
StatisticsCollectionQuery

00:12:15.269 --> 00:12:16.403 align:middle line:-2
和HKStatistics的
更多信息

00:12:16.837 --> 00:12:18.839 align:middle line:-2
你可以参考关于
HealthKit的介绍

00:12:21.842 --> 00:12:23.544 align:middle line:-1
虽然StatisticsCollectionQuery

00:12:24.044 --> 00:12:27.181 align:middle line:-2
应该是我们的首选工具
用于有效率地

00:12:27.247 --> 00:12:28.482 align:middle line:-2
与保存在HealthKit中的
量化数据进行交互

00:12:29.616 --> 00:12:33.287 align:middle line:-1
有时我们真的想枚举

00:12:33.353 --> 00:12:34.688 align:middle line:-2
存储在量化系列中的
每一个单一量化数据

00:12:35.589 --> 00:12:38.192 align:middle line:-1
比如 如果我们想做一些比如绘制

00:12:38.458 --> 00:12:40.827 align:middle line:-1
用户玩游戏时

00:12:40.894 --> 00:12:41.895 align:middle line:-1
通过我们的app测量的每一个心率

00:12:43.096 --> 00:12:46.934 align:middle line:-2
我们可以通过
QuantitySeriesSampleQuery实现

00:12:48.068 --> 00:12:51.038 align:middle line:-2
在iOS 13中我们改进了
QuantitySeriesSampleQuery

00:12:51.104 --> 00:12:54.374 align:middle line:-2
通过把NSPredicate中的
量化样本参数

00:12:54.842 --> 00:12:56.210 align:middle line:-1
替换为量化类型

00:12:58.111 --> 00:13:01.982 align:middle line:-2
现在不再简单地枚举
单一量化样本的量化数据

00:13:02.282 --> 00:13:04.351 align:middle line:-1
而是枚举多个量化样本

00:13:04.418 --> 00:13:05.886 align:middle line:-1
及其全部备份量化数据

00:13:07.521 --> 00:13:10.457 align:middle line:-1
我们还把时间参数升级为时间间隔

00:13:10.524 --> 00:13:12.893 align:middle line:-2
从而你可以在每个单一量化数据
被枚举时

00:13:12.960 --> 00:13:13.861 align:middle line:-1
获得它的完整时间间隔

00:13:14.828 --> 00:13:17.364 align:middle line:-1
我们还有一个可选的量化样本参数

00:13:17.664 --> 00:13:21.401 align:middle line:-1
可以提供当前被枚举的量化系列样本

00:13:24.371 --> 00:13:26.139 align:middle line:-2
这个查询通过可视化数据
做出了最好的表达

00:13:26.440 --> 00:13:27.574 align:middle line:0
因此我要给你们展示一下

00:13:28.442 --> 00:13:30.444 align:middle line:-1
在这里我们有两个量化系列样本

00:13:31.111 --> 00:13:32.646 align:middle line:-1
第一个量化系列样本

00:13:32.713 --> 00:13:35.415 align:middle line:0
包含由嵌入到
我们的视频游戏控制器中的

00:13:35.482 --> 00:13:36.917 align:middle line:0
心率传感器测量的量化数据

00:13:38.218 --> 00:13:41.522 align:middle line:0
第二个量化系列包含
由Apple Watch测量的量化数据

00:13:42.189 --> 00:13:45.092 align:middle line:0
因为我们的用户恰好同时
使用这两个设备

00:13:45.859 --> 00:13:47.728 align:middle line:0
这两个量化系列适时地相互重叠

00:13:48.996 --> 00:13:51.131 align:middle line:0
默认情况下
QuantitySeriesSampleQuery

00:13:51.198 --> 00:13:52.866 align:middle line:0
将以量化数据的开始时间为顺序

00:13:53.267 --> 00:13:56.303 align:middle line:0
枚举来自这两个量化系列的
全部量化数据

00:13:56.670 --> 00:13:57.604 align:middle line:-1
就像这样

00:13:58.338 --> 00:14:00.507 align:middle line:0
请注意在量化系列的末端

00:14:01.875 --> 00:14:03.210 align:middle line:-1
完成参数被设为真

00:14:05.312 --> 00:14:08.882 align:middle line:0
如果你需要获取
量化系列样本自身的参数

00:14:08.949 --> 00:14:11.552 align:middle line:-2
比如设备信息、来源、版本号
或元数据

00:14:11.919 --> 00:14:15.489 align:middle line:0
你可以在执行查询之前
把包含样本设置为真

00:14:16.156 --> 00:14:19.126 align:middle line:-2
请注意 在这个例子中
当枚举这些量化系列时

00:14:19.760 --> 00:14:23.197 align:middle line:-2
你可以在量化数据处理器中
获取相应的量化系列样本

00:14:26.967 --> 00:14:29.303 align:middle line:-1
现在我们已经了解如何使用量化系列

00:14:29.369 --> 00:14:31.171 align:middle line:-1
与量化数据进行有效地交互

00:14:31.238 --> 00:14:33.540 align:middle line:-1
我想告诉你们在游戏中添加

00:14:33.807 --> 00:14:35.976 align:middle line:-2
我们在本场演讲中所讲到的这种支持
有多么简单

00:14:36.677 --> 00:14:39.046 align:middle line:-2
跟着我一起进入Xcode
我会给你做一个简短的演示

00:14:44.484 --> 00:14:47.588 align:middle line:-1
这是游戏现在的形式

00:14:48.789 --> 00:14:50.891 align:middle line:-1
我实际上没有

00:14:50.958 --> 00:14:52.826 align:middle line:-2
嵌入到视频游戏控制器中的
心率传感器

00:14:52.893 --> 00:14:55.195 align:middle line:-2
但如果有人想做一个
稍后请给我打电话

00:14:56.330 --> 00:14:58.131 align:middle line:-1
但我有另一个外部心率传感器

00:14:58.198 --> 00:15:00.501 align:middle line:-1
我可以用来获取信息

00:15:01.034 --> 00:15:02.703 align:middle line:-1
请记住量化系列

00:15:02.769 --> 00:15:04.438 align:middle line:-1
可适用于任意量化类型

00:15:04.505 --> 00:15:05.506 align:middle line:-1
而不只是心率

00:15:05.839 --> 00:15:07.808 align:middle line:-1
并且数据可以来自于外部传感器、

00:15:07.875 --> 00:15:10.110 align:middle line:-1
外部数据库、磁盘上的文件

00:15:10.544 --> 00:15:13.046 align:middle line:-1
或由app直接输入

00:15:14.381 --> 00:15:15.916 align:middle line:-1
这个游戏有两个标签

00:15:16.917 --> 00:15:19.319 align:middle line:-2
第一个是Play标签 它会提出
PlayViewController

00:15:19.386 --> 00:15:20.387 align:middle line:-1
我们可以开始游戏

00:15:21.221 --> 00:15:23.090 align:middle line:-1
第二个标签是上一次游戏标签

00:15:23.156 --> 00:15:24.858 align:middle line:-2
它会提出
ResultsViewController

00:15:24.925 --> 00:15:26.527 align:middle line:-1
显示在上一次玩游戏时

00:15:26.593 --> 00:15:28.128 align:middle line:-1
所测量的心率

00:15:31.198 --> 00:15:33.000 align:middle line:-2
我要继续并切换回
PlayViewController

00:15:33.066 --> 00:15:35.068 align:middle line:-1
给你演示一局游戏该怎么玩

00:15:37.437 --> 00:15:39.473 align:middle line:-1
在这个游戏中我要击中热狗

00:15:39.540 --> 00:15:40.607 align:middle line:-1
而放过西兰花

00:15:41.141 --> 00:15:42.876 align:middle line:-2
也许对于健康类app来说
有点落伍了

00:15:43.477 --> 00:15:44.378 align:middle line:-1
但是我只有这个

00:15:45.479 --> 00:15:47.981 align:middle line:-1
每收获一个热狗就增加一分

00:15:48.048 --> 00:15:50.317 align:middle line:-1
当我玩游戏时 我的心率会增加

00:15:51.652 --> 00:15:52.719 align:middle line:-1
如果我切换回上一次游戏标签

00:15:52.786 --> 00:15:54.788 align:middle line:-1
我可以看到我还没有收到

00:15:54.855 --> 00:15:56.390 align:middle line:-2
在玩刚才的游戏时
所测量的任何心率数据

00:15:56.857 --> 00:15:58.458 align:middle line:-1
现在我们想给app添加那个支持

00:15:59.626 --> 00:16:01.328 align:middle line:-1
我们的第一步是…

00:16:01.962 --> 00:16:03.830 align:middle line:-1
让app请求授权

00:16:03.897 --> 00:16:05.232 align:middle line:-1
就像我们在PPT中所看到的那样

00:16:06.099 --> 00:16:09.636 align:middle line:-1
因为app总是会在用户玩游戏时

00:16:09.703 --> 00:16:10.671 align:middle line:-1
读写心率数据

00:16:10.737 --> 00:16:12.773 align:middle line:-1
我希望只要app启动完毕

00:16:13.774 --> 00:16:15.275 align:middle line:-1
就请求授权

00:16:15.342 --> 00:16:17.110 align:middle line:-1
那么我要在app中添加这个

00:16:17.177 --> 00:16:19.446 align:middle line:-2
在app委托中添加
didFinishLaunchingWithOptions

00:16:22.883 --> 00:16:24.117 align:middle line:-1
在这里我正在请求…

00:16:24.484 --> 00:16:27.554 align:middle line:-2
我正在创建一组专用于心率的
量化类型

00:16:28.021 --> 00:16:30.891 align:middle line:-2
我可以在
HK healthStore内

00:16:30.958 --> 00:16:32.025 align:middle line:-1
请求这些样本类型的授权

00:16:33.727 --> 00:16:35.229 align:middle line:-1
请求授权后

00:16:35.295 --> 00:16:37.030 align:middle line:-1
我们会获取来自传感器的测量数据

00:16:37.097 --> 00:16:39.032 align:middle line:-1
并把那个数据保存到量化系列中

00:16:40.200 --> 00:16:42.703 align:middle line:-1
我已经创建了一个类

00:16:43.103 --> 00:16:44.137 align:middle line:-1
用于压缩对外部传感器的连接

00:16:44.204 --> 00:16:45.606 align:middle line:-1
并且如果你想了解它是如何运作的

00:16:45.672 --> 00:16:48.375 align:middle line:-1
请参考与本场演讲相关联的示例项目

00:16:49.910 --> 00:16:51.979 align:middle line:-2
我现在要转到
PlayViewController

00:16:52.246 --> 00:16:54.648 align:middle line:-1
因为我们想添加连接

00:16:54.948 --> 00:16:56.116 align:middle line:-1
用于记录用户玩游戏时的心率

00:16:56.850 --> 00:16:58.085 align:middle line:-1
我要打开项目导航器

00:16:58.151 --> 00:16:59.887 align:middle line:-2
转到
PlayViewController

00:17:03.557 --> 00:17:06.260 align:middle line:-2
每当按下app中的开始游戏按钮时
就调用它

00:17:06.926 --> 00:17:08.896 align:middle line:-1
这里正适合我们创建

00:17:08.962 --> 00:17:10.163 align:middle line:-1
对外部心率传感器的连接

00:17:10.464 --> 00:17:12.199 align:middle line:-1
并开始量化系列…

00:17:12.266 --> 00:17:13.733 align:middle line:-1
量化系列样本创建器

00:17:14.601 --> 00:17:16.603 align:middle line:-1
首先我要创建对传感器的连接

00:17:20.574 --> 00:17:23.143 align:middle line:-2
HeartSensorSession
是我刚才提到过的那个类

00:17:23.210 --> 00:17:25.512 align:middle line:-1
它会压缩对传感器的连接

00:17:25.811 --> 00:17:27.580 align:middle line:-1
我把PlayViewController自身

00:17:27.915 --> 00:17:29.650 align:middle line:-1
作为HeartSensorSession的委托

00:17:31.051 --> 00:17:34.154 align:middle line:-2
现在我可以开始
心率的量化系列样本创建器了

00:17:37.057 --> 00:17:39.059 align:middle line:-2
在这里我创建了一个
量化系列样本创建器

00:17:39.126 --> 00:17:40.994 align:middle line:-2
healthStore
存储心率类型

00:17:41.328 --> 00:17:42.996 align:middle line:-1
测量的开始时间为当前时间

00:17:43.497 --> 00:17:46.600 align:middle line:-2
我要从HeartSensorSession中
获取HK设备信息

00:17:47.734 --> 00:17:50.304 align:middle line:-2
HeartSensorSession
通过它的委托协议

00:17:50.370 --> 00:17:52.339 align:middle line:-1
与PlayViewController通讯

00:17:53.273 --> 00:17:54.374 align:middle line:-1
HeartSensorSessionDelegate

00:17:54.675 --> 00:17:56.043 align:middle line:-1
有以下两个方法：

00:17:56.643 --> 00:17:58.745 align:middle line:-2
sessionDidReceiveHeartRate
和sessionDidEnd

00:18:02.316 --> 00:18:05.919 align:middle line:-2
HeartSensorSession
给它的委托提供心率测量数据

00:18:06.253 --> 00:18:08.088 align:middle line:-1
这正是我们获取测量数据的好地方

00:18:08.155 --> 00:18:10.324 align:middle line:-2
并且把它们插入到
量化系列样本创建器中

00:18:16.930 --> 00:18:18.999 align:middle line:-2
在这里我把从HeartSensorSession中
接收的心率

00:18:19.066 --> 00:18:21.368 align:middle line:-1
和时间间隔插入到

00:18:21.435 --> 00:18:22.903 align:middle line:-1
量化系列样本创建器中

00:18:24.805 --> 00:18:28.509 align:middle line:-2
最后当游戏结束时
HeartSensorSession结束时

00:18:28.876 --> 00:18:30.878 align:middle line:-2
由HeartSensorSession调用
sessionDidEnd

00:18:31.578 --> 00:18:34.481 align:middle line:-2
这是我们结束量化系列样本创建器的
完美场所

00:18:34.781 --> 00:18:38.018 align:middle line:-2
从而存留我们插入到HealthKit中的
心率量化数据

00:18:38.785 --> 00:18:40.754 align:middle line:-1
我们还可以关联

00:18:40.821 --> 00:18:42.322 align:middle line:-1
用元数据所创建的量化系列

00:18:42.723 --> 00:18:44.525 align:middle line:-1
在这个例子中 我要使用元数据

00:18:44.591 --> 00:18:47.828 align:middle line:-2
把这些心率与我们刚刚玩的
游戏会话关联起来

00:18:47.895 --> 00:18:49.830 align:middle line:-1
从而在ResultsViewController中

00:18:49.897 --> 00:18:53.000 align:middle line:-2
我们可以查询
与上一次游戏所关联的心率

00:18:57.905 --> 00:19:01.975 align:middle line:-2
在这里我要使用MetadataKey
ExternalUUID创建元数据词典

00:19:02.543 --> 00:19:04.845 align:middle line:-2
我在心率传感器的UUID字符串中
设置了MetadataKeyExternalUUID

00:19:05.646 --> 00:19:07.881 align:middle line:-1
我终于完成了量化系列

00:19:07.948 --> 00:19:09.983 align:middle line:-1
通过元数据

00:19:10.050 --> 00:19:11.718 align:middle line:-2
和从HeartSensorSession中
接收的结束测量的时间

00:19:14.154 --> 00:19:16.590 align:middle line:-2
现在我们已经把心率数据
保存到HealthKit中

00:19:16.890 --> 00:19:19.927 align:middle line:-1
我们想…

00:19:19.993 --> 00:19:21.128 align:middle line:-2
我们想在ResultsViewController中
给用户显示数据

00:19:21.195 --> 00:19:22.863 align:middle line:-2
那么让我们现在转到
ResultsViewController

00:19:28.969 --> 00:19:31.171 align:middle line:-2
在ResultsViewController
viewDidLoad函数中

00:19:31.238 --> 00:19:32.272 align:middle line:-1
我有一个应用函数

00:19:32.773 --> 00:19:33.941 align:middle line:-1
loadHeartRateQuanitites

00:19:34.274 --> 00:19:36.009 align:middle line:-1
它会查询

00:19:36.076 --> 00:19:38.278 align:middle line:-1
与上一次游戏会话相关联的心率数据

00:19:38.745 --> 00:19:41.982 align:middle line:-2
并在表视图中生成一个
可以显示出来的

00:19:42.049 --> 00:19:43.483 align:middle line:-1
每个量化数据的字符串表达

00:19:44.918 --> 00:19:49.089 align:middle line:-1
让我们继续并从添加量化系列样本

00:19:49.156 --> 00:19:51.658 align:middle line:-2
使其查询
与上一次游戏相关联的心率开始

00:19:51.725 --> 00:19:52.759 align:middle line:-1
如果玩过游戏的话

00:19:56.463 --> 00:19:59.166 align:middle line:-2
在这里要防范
没有玩过游戏的情况

00:20:01.869 --> 00:20:04.371 align:middle line:-1
我们可以继续并使用游戏识别器

00:20:04.438 --> 00:20:08.075 align:middle line:-2
为MetadataExternalKeyUUID
创建一个查询谓词

00:20:08.642 --> 00:20:10.177 align:middle line:-1
请记住 我们使用了这个元数据

00:20:10.244 --> 00:20:12.713 align:middle line:-1
从而稍后可以进行查询

00:20:12.779 --> 00:20:14.381 align:middle line:-1
与上一次游戏相关联的心率数据

00:20:16.717 --> 00:20:19.052 align:middle line:-1
然后我可以创建量化系列样本

00:20:19.119 --> 00:20:21.421 align:middle line:-2
使用我们上边创建的谓词
查询心率类型

00:20:22.890 --> 00:20:24.324 align:middle line:-1
在查询处理器内

00:20:24.391 --> 00:20:26.693 align:middle line:-1
我要枚举

00:20:26.760 --> 00:20:27.961 align:middle line:-2
与这个上一次游戏相关联的
量化数据和时间间隔

00:20:29.029 --> 00:20:31.465 align:middle line:-1
并且我要为每一个

00:20:31.532 --> 00:20:32.900 align:middle line:-1
都创建一个字符串表达

00:20:33.333 --> 00:20:35.102 align:middle line:-1
让我们继续并创建一组字符串

00:20:35.169 --> 00:20:38.005 align:middle line:-1
用于存储这些结果字符串

00:20:41.508 --> 00:20:44.545 align:middle line:-1
然后我们可以把它用在查询处理器中

00:20:48.248 --> 00:20:49.816 align:middle line:-1
首先我要防范枚举过程中

00:20:49.883 --> 00:20:51.919 align:middle line:-1
可能会返回的错误

00:20:52.553 --> 00:20:53.787 align:middle line:-1
如果没有任何错误

00:20:53.854 --> 00:20:56.323 align:middle line:-2
我就可以继续并使用
所枚举的量化数据

00:20:56.623 --> 00:20:58.892 align:middle line:-2
和时间间隔创建一个
heartRateDetailsStrings

00:20:59.359 --> 00:21:01.094 align:middle line:-1
并且我要把这些详情字符串分配给

00:21:01.161 --> 00:21:02.529 align:middle line:-2
heartRateStrings
数组

00:21:03.597 --> 00:21:06.300 align:middle line:-1
最后当枚举完成后

00:21:06.366 --> 00:21:07.935 align:middle line:-1
完成参数将被设为真

00:21:08.368 --> 00:21:11.338 align:middle line:-1
这正是取回主队列的好地方

00:21:11.638 --> 00:21:14.641 align:middle line:-2
从而重新加载ResultsViewController
以显示这些字符串

00:21:16.977 --> 00:21:19.613 align:middle line:-2
现在我想重新运行app
让你看看它现在看起来怎么样

00:21:19.680 --> 00:21:22.649 align:middle line:-2
现在我们已经添加了
对读写心率数据的支持

00:21:24.051 --> 00:21:26.520 align:middle line:-2
请记住 当app启动时
我们看到的第一件事

00:21:26.587 --> 00:21:27.955 align:middle line:-1
将是请求授权

00:21:30.891 --> 00:21:32.793 align:middle line:-1
我要继续并打开授权

00:21:33.160 --> 00:21:34.294 align:middle line:-1
从而读写心率数据

00:21:35.796 --> 00:21:37.431 align:middle line:-1
现在我要再玩一局游戏

00:21:39.032 --> 00:21:41.301 align:middle line:-1
请记住 我要击中热狗而放过西兰花

00:21:41.902 --> 00:21:43.770 align:middle line:-1
哦 零分 再来一局

00:21:49.476 --> 00:21:52.045 align:middle line:-1
哦 两分 但我仍可以看到心率如何

00:21:52.746 --> 00:21:53.714 align:middle line:-1
好了

00:21:53.780 --> 00:21:56.550 align:middle line:-2
我们拥有了一些心率数据
是在刚玩的那局游戏中测量的

00:22:05.392 --> 00:22:08.662 align:middle line:-2
刚才我们了解的是
如何通过量化系列样本创建器

00:22:09.296 --> 00:22:11.632 align:middle line:-1
有效率地保存量化数据

00:22:12.299 --> 00:22:15.702 align:middle line:-2
以及如何使用QuantitySeries
SampleQuery对其进行查询

00:22:16.603 --> 00:22:18.906 align:middle line:-2
现在我要邀请我的同事
Divya上台来

00:22:19.273 --> 00:22:22.743 align:middle line:-2
她会讲HealthKit
如何在心率方面

00:22:22.809 --> 00:22:24.178 align:middle line:-1
对表达进行了扩展

00:22:24.444 --> 00:22:26.513 align:middle line:-2
以及我们如何迁入到
全新的听力健康的健康域

00:22:26.580 --> 00:22:28.215 align:middle line:-1
谢谢大家

00:22:35.389 --> 00:22:37.424 align:middle line:-1
那么我的同事Luke刚给你们讲了

00:22:37.491 --> 00:22:41.595 align:middle line:-2
在iOS 13中存储HK
量化数据的有效率的新方式

00:22:42.496 --> 00:22:45.866 align:middle line:-2
并且HealthKit
越来越多地成为了一个

00:22:45.933 --> 00:22:47.634 align:middle line:-1
保存用户每日健康数据的仓库

00:22:48.468 --> 00:22:51.038 align:middle line:-1
除了存储越来越多的数据

00:22:51.305 --> 00:22:53.207 align:middle line:-1
我们还存储各种各样的数据

00:22:54.174 --> 00:22:57.578 align:middle line:-2
今年 我们在现有的支持中
添加了听力健康

00:22:57.644 --> 00:22:59.479 align:middle line:-1
并对听力健康添加了新支持

00:22:59.780 --> 00:23:01.248 align:middle line:-2
（新的健康类型
心脏和听力健康）

00:23:01.915 --> 00:23:06.086 align:middle line:-2
我们的用户自iOS 8起
就与心脏相关的功能进行交互

00:23:06.687 --> 00:23:09.056 align:middle line:-2
他们可以从
Apple Watch获取心率

00:23:09.356 --> 00:23:13.460 align:middle line:-2
或从由你们开发人员创建的
连接到传感器的app中获取心率

00:23:13.861 --> 00:23:16.163 align:middle line:-1
并在健康app中浏览全部数据

00:23:18.432 --> 00:23:20.901 align:middle line:0
HealthKit一直支持心率

00:23:21.568 --> 00:23:24.071 align:middle line:0
因此如果你的心率读数是这个

00:23:24.538 --> 00:23:27.241 align:middle line:0
你可以决定在五秒内

00:23:27.774 --> 00:23:30.978 align:middle line:0
平均心率是每分钟68次

00:23:32.112 --> 00:23:35.282 align:middle line:-2
并且在HealthKit中
你可以把它作为HK量化样本保存

00:23:37.918 --> 00:23:41.722 align:middle line:0
在iOS 11中
我们引入了心率变量SDNN

00:23:41.788 --> 00:23:42.623 align:middle line:0
（心率变量SDNN）

00:23:42.689 --> 00:23:45.692 align:middle line:0
心率变量是心跳和心跳之间

00:23:45.759 --> 00:23:47.995 align:middle line:0
在时间间隔内的测量的变化

00:23:48.529 --> 00:23:51.732 align:middle line:0
并且SDNN代表的是
正常心跳间隔的标准差

00:23:52.699 --> 00:23:55.435 align:middle line:0
因此Apple Watch
可以获取同样的心率读数

00:23:56.236 --> 00:23:58.739 align:middle line:0
并获取每次心跳之间的时间间隔

00:23:59.339 --> 00:24:01.241 align:middle line:0
来计算一个标准差

00:24:01.308 --> 00:24:03.977 align:middle line:-2
并把它作为量化样本
保存到HealthKit中

00:24:05.179 --> 00:24:07.014 align:middle line:-1
心率和心率变量

00:24:07.080 --> 00:24:10.517 align:middle line:-2
对于心血管健康来说
都是非常重要的度量

00:24:10.984 --> 00:24:13.620 align:middle line:-2
并且用户们也喜欢看一眼
就能了解这些信息

00:24:13.687 --> 00:24:15.756 align:middle line:-1
在日常工作生活中或更具体地

00:24:15.822 --> 00:24:16.890 align:middle line:-1
比如当他们健身时

00:24:19.026 --> 00:24:21.395 align:middle line:-1
那么让我们再看一次

00:24:21.461 --> 00:24:22.296 align:middle line:-1
这同一个心率读数

00:24:22.930 --> 00:24:26.633 align:middle line:-1
目前 我描述了我们可以总结

00:24:26.700 --> 00:24:27.734 align:middle line:-1
这个心率数据的方式

00:24:28.235 --> 00:24:31.171 align:middle line:-1
但有时候你想获得真实的底层数据

00:24:32.072 --> 00:24:34.308 align:middle line:0
那么假如我想获得时间…

00:24:34.775 --> 00:24:36.944 align:middle line:0
了解每次心跳所发生的时间

00:24:37.711 --> 00:24:39.546 align:middle line:0
返回到我们的情境中

00:24:39.880 --> 00:24:42.416 align:middle line:0
假如我们的游戏控制器有一个传感器

00:24:42.482 --> 00:24:45.419 align:middle line:0
可以在用户在玩游戏时

00:24:45.686 --> 00:24:46.854 align:middle line:0
有新的心跳进入时告诉我们

00:24:47.721 --> 00:24:51.158 align:middle line:0
那么在这里 第一次心跳发生在

00:24:51.558 --> 00:24:53.160 align:middle line:0
从数据收集开始的起始点
之后的0.5秒

00:24:53.594 --> 00:24:56.063 align:middle line:0
第二次发生在第1.49秒

00:24:56.430 --> 00:24:59.132 align:middle line:0
并且我们可以得到——
我们可以继续获得

00:24:59.399 --> 00:25:01.869 align:middle line:0
自数据收集开始起
这些心跳发生的其余的时间点

00:25:02.936 --> 00:25:06.273 align:middle line:0
那么你可以注意到
每次心跳都发生在一定的时间点

00:25:06.607 --> 00:25:09.643 align:middle line:0
把它们放在一起就组成了
一系列的心跳

00:25:10.511 --> 00:25:12.246 align:middle line:0
要把这个数据
保存到HealthKit中

00:25:12.513 --> 00:25:15.182 align:middle line:-2
我们有一个
HKHeartbeatSeriesSample

00:25:15.582 --> 00:25:18.385 align:middle line:-1
它会按照心跳发生的时间戳

00:25:18.452 --> 00:25:19.319 align:middle line:-1
来保存一系列的心跳

00:25:20.587 --> 00:25:24.091 align:middle line:-1
现在你可能注意到

00:25:24.157 --> 00:25:25.459 align:middle line:-2
这与Luke之前讲过的系列API
感觉很相似

00:25:26.260 --> 00:25:29.363 align:middle line:-2
但有一个重点需要注意
即心跳系列样本

00:25:29.429 --> 00:25:31.565 align:middle line:-1
压缩衍生自HealthKit中

00:25:31.632 --> 00:25:34.301 align:middle line:-1
其它样本类型的数据类型

00:25:35.068 --> 00:25:38.472 align:middle line:-1
没有值或单位 比如HK量化数据

00:25:38.539 --> 00:25:41.241 align:middle line:-1
它是量化系列背后的底层数据

00:25:41.675 --> 00:25:45.779 align:middle line:-2
因此我们可以更有效地
保存一系列时间戳

00:25:46.113 --> 00:25:47.614 align:middle line:-1
来表达一个心跳系列

00:25:47.681 --> 00:25:49.116 align:middle line:-2
（健康系列VS量化系列
没有值或单位 比如HK量化数据）

00:25:49.183 --> 00:25:50.117 align:middle line:-1
（一系列时间戳）

00:25:50.184 --> 00:25:52.819 align:middle line:-1
但因为我们仍然存储一系列数据

00:25:52.886 --> 00:25:55.455 align:middle line:-1
那可能会非常大 我们有…

00:25:55.522 --> 00:25:59.560 align:middle line:-1
我们设计了API来熟悉量化系列

00:26:02.863 --> 00:26:04.698 align:middle line:-1
有它自己的创建器和自定义查询

00:26:07.000 --> 00:26:08.435 align:middle line:-1
与量化系列样本一样

00:26:08.702 --> 00:26:11.305 align:middle line:-1
心跳系列样本也是由创建器所创建

00:26:11.371 --> 00:26:12.873 align:middle line:-1
并当你完成保存数据后结束

00:26:13.740 --> 00:26:14.908 align:middle line:-1
那么让我们用代码来创建一个

00:26:16.510 --> 00:26:18.011 align:middle line:-1
第一步一如既往

00:26:18.078 --> 00:26:20.180 align:middle line:-1
是请求恰当的授权

00:26:21.114 --> 00:26:24.585 align:middle line:-2
对于这个例子
你需要请求新的心跳系列类型

00:26:24.918 --> 00:26:28.322 align:middle line:-1
以及我们从iOS 11中

00:26:28.388 --> 00:26:29.990 align:middle line:-2
重新引入的量化类型
heartRateVariabilitySDNN

00:26:30.891 --> 00:26:32.593 align:middle line:-1
你需要请求

00:26:32.659 --> 00:26:33.927 align:middle line:-1
这两种类型的授权

00:26:33.994 --> 00:26:37.464 align:middle line:-1
因为心率变量是一个

00:26:37.731 --> 00:26:39.099 align:middle line:-1
可直接衍生自心跳系列的度量

00:26:39.166 --> 00:26:41.635 align:middle line:-1
这样你的用户就清楚地了解

00:26:41.702 --> 00:26:43.937 align:middle line:-1
他们到底与你分享了哪种数据

00:26:45.472 --> 00:26:47.407 align:middle line:-1
一旦我们请求了授权

00:26:47.474 --> 00:26:51.078 align:middle line:-2
我们可通过heathStore、
gameDevice

00:26:51.144 --> 00:26:52.913 align:middle line:-2
和gameStartDate
初始化一个心跳系列创建器

00:26:52.980 --> 00:26:55.282 align:middle line:-1
那会表明何时开始数据收集

00:26:56.950 --> 00:27:00.053 align:middle line:-2
当游戏正在进行时
并且当用户正在玩游戏时

00:27:00.454 --> 00:27:02.489 align:middle line:-2
我们将向创建器中添加
带有时间间隔的心跳

00:27:02.556 --> 00:27:04.558 align:middle line:-1
自系列开始的时间起

00:27:06.627 --> 00:27:08.662 align:middle line:0
但你可能会遇到这样的情况

00:27:08.929 --> 00:27:12.699 align:middle line:0
传感器当掉了
在这里有一个数据收集的缺口

00:27:12.766 --> 00:27:14.334 align:middle line:-1
在第二秒和第三秒之间

00:27:15.369 --> 00:27:18.572 align:middle line:0
现在看起来
在第二个和第三个心跳之间

00:27:18.639 --> 00:27:20.174 align:middle line:0
有一个1.99秒的缺口

00:27:20.240 --> 00:27:24.311 align:middle line:0
那会导致
对用户的心跳数据的错误翻译

00:27:25.579 --> 00:27:26.980 align:middle line:-1
考虑到这个问题

00:27:27.047 --> 00:27:29.149 align:middle line:-2
我们要把
precededByGap设为是

00:27:29.416 --> 00:27:31.718 align:middle line:-2
你可以对你所添加的每一个心跳
进行设置

00:27:31.785 --> 00:27:34.221 align:middle line:-1
如果你注意到数据收集中

00:27:34.288 --> 00:27:35.455 align:middle line:-1
由于传感器当掉而存在缺口的话

00:27:37.724 --> 00:27:41.929 align:middle line:-2
现在我可以在创建器中添加元数据
与其它HK样本中的操作一样

00:27:43.063 --> 00:27:44.831 align:middle line:-1
当我完成数据保存之后

00:27:44.898 --> 00:27:48.869 align:middle line:-2
我会结束系列 那将把心跳系列样本
保存到HealthKit中

00:27:51.305 --> 00:27:54.775 align:middle line:-2
现在我已经在游戏中添加了
对逐拍测量的支持

00:27:54.842 --> 00:27:58.045 align:middle line:-2
并且我们已经准备好开始查询
底层心跳测量数据了

00:28:02.749 --> 00:28:05.719 align:middle line:-1
我们可以与标准的HK查询进行交互

00:28:06.086 --> 00:28:10.490 align:middle line:-2
以获取高层及样本
然后使用自定义查询

00:28:10.557 --> 00:28:12.159 align:middle line:-1
与更精细的数据进行交互

00:28:13.627 --> 00:28:17.164 align:middle line:-2
那么我的第一步就是
运行一个标准的HK样本查询

00:28:17.231 --> 00:28:19.499 align:middle line:-1
以获取我感兴趣的心跳系列样本

00:28:20.834 --> 00:28:21.835 align:middle line:-1
一旦完成

00:28:21.902 --> 00:28:24.738 align:middle line:-1
我将用那个样本初始化心跳系列查询

00:28:25.005 --> 00:28:27.908 align:middle line:-1
那会让我随时间枚举每一次心跳

00:28:29.977 --> 00:28:31.612 align:middle line:-1
最后我要执行查询

00:28:34.014 --> 00:28:36.917 align:middle line:-2
心跳系列对HealthKit来说
是个新添加的强大功能

00:28:36.984 --> 00:28:39.620 align:middle line:-2
但这并不是我们拥有的
与心脏相关的全部功能

00:28:40.754 --> 00:28:42.122 align:middle line:-1
自iOS 12起

00:28:42.189 --> 00:28:45.092 align:middle line:-2
Apple Watch
就开始通过心脏警告通知用户

00:28:46.426 --> 00:28:50.197 align:middle line:-2
当Apple Watch
检测到心率

00:28:50.264 --> 00:28:52.199 align:middle line:-2
低于指定BPM临界值时
会发出低心率警告

00:28:52.266 --> 00:28:53.100 align:middle line:-1
（心率事件）

00:28:53.166 --> 00:28:55.536 align:middle line:-1
当心率高于指定BPM临界值时

00:28:55.602 --> 00:28:57.471 align:middle line:-1
发出高心率警告

00:28:58.639 --> 00:29:01.241 align:middle line:-2
当Apple Watch检测到
可能象征房颤的节律时

00:29:01.308 --> 00:29:04.011 align:middle line:-1
发出心律不齐警告

00:29:05.879 --> 00:29:06.980 align:middle line:-1
嗯 在HealthKit中

00:29:07.047 --> 00:29:10.317 align:middle line:-1
这些警告的形式是三个新的类别类型

00:29:10.817 --> 00:29:14.354 align:middle line:-2
当Apple Watch检测到警告时
将被保存到HealthKit中

00:29:17.090 --> 00:29:19.359 align:middle line:-1
除了全部这些强大的心脏支持

00:29:19.660 --> 00:29:23.397 align:middle line:-2
我们在iOS 13中
还披露了这个新区域

00:29:24.131 --> 00:29:27.467 align:middle line:-1
我非常激动地与你们一起分享

00:29:27.534 --> 00:29:28.669 align:middle line:-2
听力健康在HealthKit中
找到了一席之地

00:29:28.735 --> 00:29:29.970 align:middle line:-1
（听力健康）

00:29:30.237 --> 00:29:31.605 align:middle line:-1
在你生命中的某个时间点

00:29:31.672 --> 00:29:33.574 align:middle line:-1
你可能记得做过听力测试

00:29:33.841 --> 00:29:35.676 align:middle line:-1
戴上耳机

00:29:36.043 --> 00:29:39.713 align:middle line:-1
并听一系列的声音

00:29:39.780 --> 00:29:41.949 align:middle line:-2
当某个声音大到你能听到它时
就举起手

00:29:42.883 --> 00:29:45.485 align:middle line:-1
嗯 这是纯音听力测试的一个例子

00:29:45.886 --> 00:29:48.422 align:middle line:-1
纯音是指一个具有单一频率的声音

00:29:50.724 --> 00:29:53.794 align:middle line:-1
纯音测试可以帮助识别

00:29:53.861 --> 00:29:56.129 align:middle line:-2
在一组频率不同的声音中
你所能听到的最轻的声音

00:29:56.196 --> 00:29:57.231 align:middle line:-1
（纯音测试）

00:29:57.297 --> 00:30:00.133 align:middle line:-1
并且它可以提供你可能具有的

00:30:00.200 --> 00:30:01.468 align:middle line:-1
听觉障碍或听力丧失的评估

00:30:03.036 --> 00:30:04.972 align:middle line:-1
纯音测试的结果

00:30:05.038 --> 00:30:08.175 align:middle line:-2
最常见的是显示在一个叫做
听力图的图表上

00:30:10.077 --> 00:30:12.346 align:middle line:-1
这是一个有轻微听觉障碍的人的

00:30:12.412 --> 00:30:14.748 align:middle line:-1
听力图的示例

00:30:15.382 --> 00:30:18.418 align:middle line:-1
让我们放大这个图表 更清楚地了解

00:30:18.485 --> 00:30:21.021 align:middle line:-1
听力图中所储存的数据

00:30:22.723 --> 00:30:24.324 align:middle line:0
那么在这里你可以看到两条线

00:30:24.758 --> 00:30:28.629 align:middle line:0
一条对应于左耳的纯音测试结果

00:30:28.896 --> 00:30:29.997 align:middle line:0
另一条对应的是右耳

00:30:30.531 --> 00:30:32.533 align:middle line:0
让我们先来看看

00:30:32.599 --> 00:30:34.034 align:middle line:0
位于125赫兹线上的前两个数据值

00:30:35.469 --> 00:30:39.907 align:middle line:0
这表示对于这个用户来说
要听到125赫兹频率的声音

00:30:40.274 --> 00:30:43.810 align:middle line:0
他们的左耳需要大概
11分贝听力单位

00:30:44.111 --> 00:30:45.279 align:middle line:0
而右耳需要31分贝

00:30:46.246 --> 00:30:49.550 align:middle line:0
分贝听力单位测量的是

00:30:49.917 --> 00:30:52.920 align:middle line:0
相对于一个年轻、健康的个体
所能听到的最轻的声音

00:30:52.986 --> 00:30:53.954 align:middle line:0
所能听到的声音的密度

00:30:55.222 --> 00:30:57.558 align:middle line:0
因此我们可以获得

00:30:57.624 --> 00:30:59.159 align:middle line:0
与这个听力图相关联的其余数据值

00:30:59.626 --> 00:31:01.862 align:middle line:0
为了把这个数据存储到
HealthKit中

00:31:02.129 --> 00:31:06.500 align:middle line:-1
我们引入了 它会存储一组

00:31:06.567 --> 00:31:09.536 align:middle line:-1
与听力测试相关联的听力敏度值

00:31:10.337 --> 00:31:12.472 align:middle line:-1
那么让我们创建听力图样本和代码

00:31:14.408 --> 00:31:18.145 align:middle line:-2
第一步是创建
HKAudiogramSensitivityPoint

00:31:18.579 --> 00:31:20.814 align:middle line:-1
压缩双耳所能听到的

00:31:20.881 --> 00:31:23.717 align:middle line:-1
指定频率的声音的密度

00:31:24.718 --> 00:31:29.556 align:middle line:-2
那么我要用新的HK单位赫兹单位
来创建频率量化数据

00:31:30.257 --> 00:31:32.726 align:middle line:-1
并用新的分贝听力单位来创建

00:31:32.793 --> 00:31:34.728 align:middle line:-1
左耳和右耳敏度量化数据

00:31:36.230 --> 00:31:38.832 align:middle line:-2
现在我已经准备好
创建听力图敏度值了

00:31:39.800 --> 00:31:43.203 align:middle line:-1
一旦你创建好一组听力图敏度值

00:31:43.670 --> 00:31:45.772 align:middle line:-2
你就可以把它保存到
audiogramSample中

00:31:46.607 --> 00:31:49.576 align:middle line:-1
现在一定要确保敏度值

00:31:49.643 --> 00:31:51.678 align:middle line:-1
都是唯一的并且是按顺序排列的

00:31:52.079 --> 00:31:53.947 align:middle line:-1
因为这是你稍后在分析或图表中

00:31:54.014 --> 00:31:56.717 align:middle line:-1
与这个数据进行交互的方式

00:31:58.151 --> 00:32:01.188 align:middle line:-2
最后我已经准备好把那个数据
存储到HealthKit中了

00:32:02.289 --> 00:32:05.626 align:middle line:-1
开始创建听力图样本

00:32:05.692 --> 00:32:07.895 align:middle line:-2
以及用HealthKit创建
听力健康app 就是这么简单

00:32:08.929 --> 00:32:12.633 align:middle line:-1
但听力图样本只代表

00:32:12.699 --> 00:32:15.102 align:middle line:-2
当你做听力测试时的指定时间点的
耳朵的健康程度

00:32:16.203 --> 00:32:19.506 align:middle line:-2
一天中的绝大多数时间
我们都暴露在各种声音之中

00:32:19.573 --> 00:32:22.309 align:middle line:-2
这些声音来自耳机
或来自我们在路上行走时的周围环境

00:32:22.776 --> 00:32:25.479 align:middle line:-1
那都会影响我们的听力健康

00:32:27.347 --> 00:32:30.918 align:middle line:-1
为了保持追踪来自耳机的音频暴露

00:32:31.218 --> 00:32:34.321 align:middle line:-2
我们有一个读写量化类型
headphoneAudioExposure

00:32:36.256 --> 00:32:37.457 align:middle line:-1
在一天中剩下的时间

00:32:37.524 --> 00:32:41.562 align:middle line:-2
当我们走在充斥着建筑工作声音
或交通声音的路上时

00:32:42.329 --> 00:32:46.400 align:middle line:-2
Apple Watch可以捕捉
环境中的音频暴露数据

00:32:46.466 --> 00:32:47.701 align:middle line:-1
并把它保存到HealthKit中

00:32:48.035 --> 00:32:50.637 align:middle line:-1
为此我们有一个类似的读写量化类型

00:32:50.971 --> 00:32:52.306 align:middle line:-1
environmentalAudioExposure

00:32:53.707 --> 00:32:57.311 align:middle line:-1
如果环境中的音频暴露太高

00:32:57.978 --> 00:33:00.581 align:middle line:-2
Apple Watch会生成一个
音频暴露警告

00:33:00.647 --> 00:33:03.217 align:middle line:-1
以确保你了解

00:33:03.283 --> 00:33:05.219 align:middle line:-2
那可能对你的耳朵健康
所产生的可能的影响

00:33:05.986 --> 00:33:08.722 align:middle line:-2
并且它会使用新audioExposureEvent
类别类型识别器

00:33:08.789 --> 00:33:12.059 align:middle line:-1
把这个保存为类别样本

00:33:14.595 --> 00:33:17.598 align:middle line:-1
那么我们讲了许多

00:33:17.664 --> 00:33:20.167 align:middle line:-2
在HealthKit和
iOS 13中可用的新的数据表达

00:33:20.901 --> 00:33:25.072 align:middle line:-2
从新的、有效率的系列表达
到对听力健康的新支持

00:33:26.707 --> 00:33:30.577 align:middle line:-2
现在你可以正式存储
大量的HK量化数据了

00:33:30.911 --> 00:33:33.614 align:middle line:-2
大多数冗余数据
保存在HealthKit中

00:33:33.680 --> 00:33:34.848 align:middle line:-1
（总结）

00:33:34.915 --> 00:33:37.818 align:middle line:-1
并且你可以表达更丰富的

00:33:38.352 --> 00:33:41.388 align:middle line:-1
关于心脏和听力健康的数据的表达

00:33:41.455 --> 00:33:42.623 align:middle line:-1
（有效率地存储大量HK量化数据）

00:33:42.990 --> 00:33:46.627 align:middle line:-2
要获取更多信息以及你在这里
所看到的示例代码项目

00:33:46.994 --> 00:33:51.532 align:middle line:-2
你可以访问我们的演讲链接
或在本场演讲结束后

00:33:51.598 --> 00:33:53.433 align:middle line:-2
与我们在健康与
健身技术实验室中沟通

00:33:54.902 --> 00:33:57.471 align:middle line:-1
谢谢大家 祝你们WWDC过得愉快

