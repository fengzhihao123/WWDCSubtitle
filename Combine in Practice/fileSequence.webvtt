WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:01.176 --> 00:00:04.500 A:middle
[音乐]

00:00:10.286 --> 00:00:10.636 A:middle
&gt;&gt; 大家好

00:00:11.516 --> 00:00:16.546 A:middle
[掌声]

00:00:17.046 --> 00:00:18.896 A:middle
大家好 我是 Michael LeHew

00:00:19.376 --> 00:00:21.046 A:middle
在 Apple Foundation 团队工作

00:00:21.326 --> 00:00:23.286 A:middle
今天 我很激动地

00:00:23.286 --> 00:00:24.656 A:middle
向大家介绍

00:00:24.656 --> 00:00:25.756 A:middle
今年即将发布的

00:00:25.756 --> 00:00:26.776 A:middle
Combine 框架

00:00:27.686 --> 00:00:28.796 A:middle
先澄清一点

00:00:28.796 --> 00:00:29.976 A:middle
我们要说的不是联合收割机

00:00:32.136 --> 00:00:33.336 A:middle
深入探讨之前 我想

00:00:33.336 --> 00:00:35.056 A:middle
先总体简单介绍一下

00:00:35.166 --> 00:00:36.606 A:middle
Combine 是什么

00:00:36.606 --> 00:00:40.446 A:middle
代码中 常见的

00:00:40.476 --> 00:00:41.536 A:middle
情况是 我们有

00:00:41.536 --> 00:00:44.866 A:middle
值或事件的发布者

00:00:44.866 --> 00:00:46.236 A:middle
还有想要从发布者处

00:00:46.236 --> 00:00:49.796 A:middle
接收值的订阅者

00:00:50.386 --> 00:00:51.946 A:middle
有一些相关方

00:00:51.946 --> 00:00:52.956 A:middle
会在这两者

00:00:52.956 --> 00:00:54.706 A:middle
之间建立连接

00:00:56.336 --> 00:00:58.626 A:middle
连接建立后 订阅者

00:00:59.006 --> 00:01:00.676 A:middle
会声明

00:01:00.676 --> 00:01:02.176 A:middle
想要从发布者处

00:01:02.176 --> 00:01:05.135 A:middle
接收值 之后

00:01:05.135 --> 00:01:06.946 A:middle
发布者便可以

00:01:07.276 --> 00:01:08.736 A:middle
向下游发送值

00:01:09.726 --> 00:01:12.196 A:middle
这一过程会持续下去

00:01:12.196 --> 00:01:13.546 A:middle
直到发布者因为值发送完毕

00:01:13.546 --> 00:01:15.326 A:middle
或出现发送失败

00:01:15.326 --> 00:01:16.826 A:middle
决定停止发送值

00:01:16.826 --> 00:01:18.826 A:middle
或者有人

00:01:18.826 --> 00:01:20.726 A:middle
选择取消订阅

00:01:22.276 --> 00:01:23.916 A:middle
如大家所见

00:01:23.916 --> 00:01:26.006 A:middle
这样的通信模式在我们的

00:01:26.006 --> 00:01:27.826 A:middle
软件中随处可见

00:01:27.826 --> 00:01:30.126 A:middle
形式可以是回调 闭包

00:01:30.126 --> 00:01:31.976 A:middle
或者其他出现异步通信的情况

00:01:34.046 --> 00:01:35.266 A:middle
Combine 正与这种模式

00:01:35.266 --> 00:01:36.676 A:middle
密切相关

00:01:39.046 --> 00:01:41.166 A:middle
Combine 定义了一个

00:01:41.166 --> 00:01:42.856 A:middle
统一的抽象

00:01:42.856 --> 00:01:44.316 A:middle
用来描述 API

00:01:44.316 --> 00:01:45.326 A:middle
这类 API 可以在一段时间内处理值

00:01:45.986 --> 00:01:48.476 A:middle
我们来看看

00:01:48.476 --> 00:01:50.736 A:middle
值发布者有哪些具体特征

00:01:53.046 --> 00:01:53.876 A:middle
我们已经在介绍会议中

00:01:53.876 --> 00:01:55.096 A:middle
谈论过这方面的内容

00:01:55.096 --> 00:01:58.286 A:middle
但我们再回顾一下

00:01:58.286 --> 00:02:00.296 A:middle
Combine 中的值发布者遵循

00:02:01.376 --> 00:02:02.426 A:middle
Publisher 协议

00:02:02.986 --> 00:02:06.586 A:middle
协议规定了两种 associatedtype

00:02:06.586 --> 00:02:09.606 A:middle
即发布者

00:02:09.606 --> 00:02:10.716 A:middle
发布的值

00:02:10.716 --> 00:02:13.166 A:middle
以及发布能否失败

00:02:13.756 --> 00:02:15.976 A:middle
稍后 我会详细介绍失败

00:02:18.156 --> 00:02:20.626 A:middle
Publisher 也要描述

00:02:20.626 --> 00:02:22.326 A:middle
如何将 Subscriber

00:02:22.846 --> 00:02:23.736 A:middle
附加于自身

00:02:23.736 --> 00:02:25.346 A:middle
限制条件是 associatedtype 必须匹配

00:02:26.766 --> 00:02:28.706 A:middle
就是这样

00:02:28.946 --> 00:02:31.506 A:middle
好了 我觉得理论部分足够了

00:02:31.806 --> 00:02:34.556 A:middle
此次会议名为 Combine in Practice

00:02:34.556 --> 00:02:39.076 A:middle
我们就来关注实践 我有一个巫师朋友

00:02:39.296 --> 00:02:41.596 A:middle
他非常酷

00:02:41.706 --> 00:02:43.786 A:middle
想跟我一起

00:02:43.966 --> 00:02:45.516 A:middle
为他正在筹办的新巫师学校开发一款 App

00:02:45.516 --> 00:02:49.986 A:middle
App 中有一项功能是

00:02:49.986 --> 00:02:51.446 A:middle
提供法术下载

00:02:51.446 --> 00:02:52.366 A:middle
这些法术

00:02:52.366 --> 00:02:54.046 A:middle
是由和他一样的巫师分享的

00:02:54.436 --> 00:02:55.526 A:middle
他不是 App 开发者

00:02:55.526 --> 00:02:57.346 A:middle
他是个巫师 所以他给了我

00:02:57.346 --> 00:03:00.376 A:middle
一张草图 这就是我要使用的 UI 组件

00:03:01.826 --> 00:03:03.496 A:middle
虽然他是个巫师

00:03:03.496 --> 00:03:04.566 A:middle
但他确实会写代码

00:03:04.566 --> 00:03:07.396 A:middle
起码足够帮我下载法术

00:03:07.396 --> 00:03:08.586 A:middle
于是 他就开始忙自己的

00:03:08.586 --> 00:03:09.546 A:middle
我要做的则是

00:03:09.546 --> 00:03:10.716 A:middle
讨论我们要如何

00:03:10.716 --> 00:03:13.596 A:middle
使用 Combine 获取

00:03:13.596 --> 00:03:15.076 A:middle
必要的 App 值

00:03:15.426 --> 00:03:17.976 A:middle
在这个标签中填充法术名

00:03:21.366 --> 00:03:23.166 A:middle
Combine 中 NotificationCenter

00:03:23.166 --> 00:03:24.646 A:middle
支持将通知

00:03:24.646 --> 00:03:26.316 A:middle
提供给发布者

00:03:26.606 --> 00:03:28.166 A:middle
我们就来创建

00:03:28.166 --> 00:03:29.976 A:middle
一个 Publisher

00:03:29.976 --> 00:03:31.806 A:middle
让我的巫师朋友传递通知

00:03:32.396 --> 00:03:35.056 A:middle
这个函数的

00:03:35.056 --> 00:03:36.096 A:middle
返回类型将是 Publisher

00:03:36.096 --> 00:03:38.426 A:middle
但 Combine 中

00:03:38.426 --> 00:03:39.716 A:middle
对发布者重要的是

00:03:39.936 --> 00:03:41.876 A:middle
它的输出和失败类型

00:03:44.046 --> 00:03:45.596 A:middle
NotificationCenter Publisher

00:03:45.656 --> 00:03:47.436 A:middle
传递通知

00:03:47.436 --> 00:03:48.166 A:middle
并且不可以失败

00:03:48.166 --> 00:03:50.046 A:middle
既然我们要

00:03:50.046 --> 00:03:51.876 A:middle
详细探讨发布者

00:03:52.286 --> 00:03:53.446 A:middle
接下来的讨论中 

00:03:53.446 --> 00:03:54.536 A:middle
我就会一直

00:03:54.536 --> 00:03:56.516 A:middle
把发布者的输出

00:03:56.516 --> 00:03:57.836 A:middle
放在上面

00:03:57.836 --> 00:04:01.726 A:middle
把失败放在下面 那么我们就有了一个

00:04:01.726 --> 00:04:04.056 A:middle
通知发布者

00:04:04.056 --> 00:04:06.096 A:middle
但我们真正想要的是

00:04:06.096 --> 00:04:07.976 A:middle
其中描述刚刚下载的法术的数据

00:04:10.216 --> 00:04:11.836 A:middle
我的朋友告诉我

00:04:11.836 --> 00:04:13.296 A:middle
他把数据放在了 userInfo 字典中

00:04:13.496 --> 00:04:15.536 A:middle
幸运的是 Combine 提供了

00:04:15.536 --> 00:04:17.016 A:middle
很有帮助的 map 函数

00:04:17.016 --> 00:04:19.206 A:middle
让我们可以深入内部

00:04:19.866 --> 00:04:21.866 A:middle
将通知转换为我们需要的形式

00:04:22.096 --> 00:04:23.246 A:middle
这与 Sequence 中

00:04:23.246 --> 00:04:25.946 A:middle
已有的操作很相似

00:04:26.766 --> 00:04:28.906 A:middle
可以看到 我们使用的发布者

00:04:28.906 --> 00:04:30.606 A:middle
输出是数据

00:04:30.606 --> 00:04:36.956 A:middle
不会产生错误 我们调用 map 这样的函数

00:04:36.956 --> 00:04:38.936 A:middle
作用于 Publisher 且返回

00:04:38.936 --> 00:04:40.426 A:middle
新 Publisher 操作符

00:04:40.956 --> 00:04:42.526 A:middle
它们在 Combine 中会经常那个出现

00:04:43.186 --> 00:04:45.866 A:middle
我的朋友还告诉我

00:04:45.866 --> 00:04:47.826 A:middle
JSON 负载 或者将要

00:04:47.826 --> 00:04:49.926 A:middle
成为 JSON 负载类型的数据

00:04:49.926 --> 00:04:51.706 A:middle
已经在我们的 App 中定义了

00:04:52.256 --> 00:04:53.656 A:middle
所以 我就可以用另一个 Combine 操作符

00:04:53.656 --> 00:04:55.196 A:middle
尝试解码数据

00:04:55.196 --> 00:04:56.746 A:middle
我们调用这个

00:04:56.746 --> 00:04:57.596 A:middle
tryMap 操作符

00:04:58.626 --> 00:05:00.716 A:middle
它和 map 很类似

00:05:00.716 --> 00:05:02.106 A:middle
但它多了一个功能

00:05:02.156 --> 00:05:05.116 A:middle
可以将错误抛出转换为流中的失败

00:05:06.146 --> 00:05:07.926 A:middle
确实 这个操作符的输出

00:05:08.016 --> 00:05:09.926 A:middle
是 MagicTrick 的发布者

00:05:09.926 --> 00:05:12.246 A:middle
它的失败

00:05:12.246 --> 00:05:13.976 A:middle
遵循 Swift Error 协议

00:05:16.566 --> 00:05:18.476 A:middle
从数据中解码自定义类型

00:05:18.476 --> 00:05:20.246 A:middle
是常见任务

00:05:20.286 --> 00:05:21.606 A:middle
我们也提供了一个操作符

00:05:21.606 --> 00:05:22.836 A:middle
专门帮你处理

00:05:23.966 --> 00:05:25.356 A:middle
仅需要简单的调用 .decode

00:05:28.076 --> 00:05:28.736 A:middle
发布者的输出

00:05:29.516 --> 00:05:32.546 A:middle
[掌声]

00:05:33.046 --> 00:05:33.916 A:middle
发布者的输出和

00:05:33.916 --> 00:05:35.856 A:middle
失败类型没有变化

00:05:36.916 --> 00:05:38.246 A:middle
既然我们有了可以

00:05:38.246 --> 00:05:39.546 A:middle
失败的发布者

00:05:39.546 --> 00:05:40.576 A:middle
我想多谈一谈我们

00:05:40.576 --> 00:05:43.116 A:middle
能做的事情

00:05:43.356 --> 00:05:45.616 A:middle
Combine 中 对潜在的失败

00:05:45.616 --> 00:05:48.326 A:middle
作出反应至关重要

00:05:48.886 --> 00:05:50.536 A:middle
每个发布者和订阅者

00:05:50.536 --> 00:05:51.836 A:middle
都有机会描述

00:05:51.836 --> 00:05:53.096 A:middle
它们生成或允许的

00:05:53.096 --> 00:05:54.486 A:middle
失败类型

00:05:55.096 --> 00:05:56.896 A:middle
我们将其内置于 Combine

00:05:57.456 --> 00:05:58.986 A:middle
因为就像 Swift 一样

00:05:58.986 --> 00:06:00.176 A:middle
我们不想让错误处理

00:06:00.176 --> 00:06:01.116 A:middle
成为一件完全

00:06:01.116 --> 00:06:02.666 A:middle
基于惯例的事情

00:06:03.636 --> 00:06:05.216 A:middle
我们在其他语言中进行了尝试

00:06:05.216 --> 00:06:06.236 A:middle
效果不太好

00:06:06.986 --> 00:06:08.846 A:middle
所以 许多类型会将其

00:06:08.846 --> 00:06:10.256 A:middle
失败类型描述为 never

00:06:10.256 --> 00:06:11.496 A:middle
这就表明

00:06:11.496 --> 00:06:12.966 A:middle
它们可能失败

00:06:12.966 --> 00:06:15.166 A:middle
或预期失败在上游得到解决

00:06:15.686 --> 00:06:18.546 A:middle
但除此之外

00:06:18.546 --> 00:06:20.906 A:middle
我们还提供了许多操作符

00:06:20.906 --> 00:06:23.456 A:middle
失败发生时

00:06:23.456 --> 00:06:24.836 A:middle
你可以借助它们作出反应或恢复

00:06:25.336 --> 00:06:28.186 A:middle
其中最简单的 就是

00:06:28.186 --> 00:06:29.726 A:middle
预设失败永远不会发生

00:06:30.816 --> 00:06:32.646 A:middle
自然 此时返回的发布者

00:06:32.646 --> 00:06:33.816 A:middle
失败类型

00:06:33.816 --> 00:06:34.696 A:middle
就是 never

00:06:35.426 --> 00:06:38.006 A:middle
但我们来看看为什么

00:06:38.226 --> 00:06:39.426 A:middle
想象一下

00:06:39.426 --> 00:06:40.576 A:middle
我们有一个上游的发布者

00:06:41.216 --> 00:06:42.686 A:middle
它与下游的

00:06:42.856 --> 00:06:44.906 A:middle
订阅者通过中间的

00:06:44.906 --> 00:06:46.766 A:middle
assertNoFailure 这一操作符连接

00:06:47.706 --> 00:06:49.496 A:middle
这个操作符只会

00:06:49.496 --> 00:06:51.576 A:middle
在收到值时直接将其向下传递

00:06:52.616 --> 00:06:54.676 A:middle
但假如上游

00:06:54.676 --> 00:06:56.766 A:middle
传来错误 我们的程序

00:06:56.766 --> 00:06:58.636 A:middle
就会卡住

00:06:58.636 --> 00:07:00.956 A:middle
这对于我们的巫师用户来说 不是理想中的结果

00:07:04.046 --> 00:07:05.666 A:middle
幸运的是 我们在 Combine 中

00:07:05.666 --> 00:07:06.906 A:middle
有许多其他操作符

00:07:06.906 --> 00:07:07.736 A:middle
来处理失败

00:07:08.586 --> 00:07:10.256 A:middle
除了预设之外

00:07:10.256 --> 00:07:11.506 A:middle
你还可以尝试

00:07:11.506 --> 00:07:13.626 A:middle
重新连接至上游

00:07:13.626 --> 00:07:15.086 A:middle
发布者或将错误

00:07:15.086 --> 00:07:16.276 A:middle
转换为其他类型

00:07:16.276 --> 00:07:19.476 A:middle
有一个操作符特别有用

00:07:19.476 --> 00:07:20.146 A:middle
那就是 catch

00:07:20.756 --> 00:07:23.126 A:middle
catch 允许你提供一个闭包

00:07:23.126 --> 00:07:24.386 A:middle
其中定义一个恢复性

00:07:24.386 --> 00:07:26.476 A:middle
发布者 它适用于

00:07:26.476 --> 00:07:29.506 A:middle
原先的上游发布者发生失败的情形

00:07:29.926 --> 00:07:32.146 A:middle
我们来看看它如何生效

00:07:32.966 --> 00:07:33.806 A:middle
我们先来看看与之前

00:07:33.806 --> 00:07:35.176 A:middle
类似的情形

00:07:35.176 --> 00:07:36.806 A:middle
这次我们不用 assertNoFailure 而是

00:07:36.806 --> 00:07:37.916 A:middle
使用 catch 操作符

00:07:38.876 --> 00:07:41.326 A:middle
和先前一样

00:07:41.326 --> 00:07:42.406 A:middle
值会无障碍转发至

00:07:42.406 --> 00:07:43.586 A:middle
下游的订阅者

00:07:44.096 --> 00:07:46.756 A:middle
但错误抵达时

00:07:47.516 --> 00:07:50.206 A:middle
现有的上游连接将被终止

00:07:52.266 --> 00:07:53.286 A:middle
我们之后会调用提供的

00:07:53.286 --> 00:07:54.716 A:middle
恢复性闭包 它可以

00:07:54.716 --> 00:07:56.566 A:middle
产生一个新的发布者

00:07:56.566 --> 00:07:58.446 A:middle
供我们订阅 之后也可以

00:07:58.446 --> 00:07:59.866 A:middle
从它那里接收值

00:08:03.146 --> 00:08:04.406 A:middle
就可以用新的发布者

00:08:04.406 --> 00:08:05.846 A:middle
替换原有的发布者

00:08:05.846 --> 00:08:06.476 A:middle
让我们从错误中恢复

00:08:07.436 --> 00:08:08.386 A:middle
我们这就把它用在

00:08:08.386 --> 00:08:09.596 A:middle
我们的代码里

00:08:11.046 --> 00:08:12.256 A:middle
catch 的使用和

00:08:12.256 --> 00:08:13.516 A:middle
其他操作符很类似

00:08:13.916 --> 00:08:14.736 A:middle
但这里的闭包

00:08:14.736 --> 00:08:16.266 A:middle
希望我们返回一个发布者

00:08:17.636 --> 00:08:19.136 A:middle
Combine 定义了一种特殊

00:08:19.136 --> 00:08:20.656 A:middle
发布者供已有

00:08:20.656 --> 00:08:22.116 A:middle
想要发布的值时使用

00:08:22.426 --> 00:08:25.576 A:middle
我们称其为 Just 意为直接发布这个值

00:08:25.706 --> 00:08:26.466 A:middle
这是 Combine 初始

00:08:26.466 --> 00:08:28.346 A:middle
自带的诸多发布者

00:08:28.346 --> 00:08:31.186 A:middle
中的一个例子

00:08:32.626 --> 00:08:34.395 A:middle
使用它的时候 

00:08:34.395 --> 00:08:36.336 A:middle
返回的发布者类型不能失败

00:08:39.046 --> 00:08:40.616 A:middle
现在 我来回顾一下我们

00:08:40.616 --> 00:08:41.936 A:middle
执行过的各种转换

00:08:42.486 --> 00:08:45.016 A:middle
最开始 我们有通知发布者

00:08:45.016 --> 00:08:47.536 A:middle
之后 我们对其映射

00:08:47.536 --> 00:08:49.206 A:middle
获取我们

00:08:49.206 --> 00:08:50.786 A:middle
想要解码的数据

00:08:52.136 --> 00:08:53.786 A:middle
之后 我们利用

00:08:53.786 --> 00:08:56.346 A:middle
.decode 操作符将数据

00:08:56.346 --> 00:08:57.996 A:middle
转换成用户定义的类型

00:08:59.366 --> 00:09:00.756 A:middle
但由于各种原因

00:09:00.876 --> 00:09:03.926 A:middle
解码可能失败

00:09:03.926 --> 00:09:05.086 A:middle
我们就要在失败发生时

00:09:05.086 --> 00:09:06.576 A:middle
将上游替换成占位符

00:09:06.736 --> 00:09:07.966 A:middle
来解决问题

00:09:10.276 --> 00:09:13.496 A:middle
但等一下 如果我们改用

00:09:13.496 --> 00:09:15.106 A:middle
恢复性发布者的话

00:09:15.106 --> 00:09:15.696 A:middle
我们就再也看不到

00:09:15.696 --> 00:09:16.606 A:middle
另一个通知了

00:09:16.976 --> 00:09:18.416 A:middle
我们终止了订阅

00:09:18.416 --> 00:09:20.916 A:middle
我们真正想要的

00:09:20.916 --> 00:09:22.456 A:middle
是能够尝试解码

00:09:22.456 --> 00:09:23.786 A:middle
并在失败时使用占位符

00:09:23.946 --> 00:09:25.086 A:middle
且同时与先前的上游

00:09:25.086 --> 00:09:26.236 A:middle
保持联系

00:09:26.716 --> 00:09:29.586 A:middle
自然 Combine 为此

00:09:29.586 --> 00:09:30.916 A:middle
也提供了一个操作符

00:09:30.996 --> 00:09:32.046 A:middle
它叫做 flatMap

00:09:33.836 --> 00:09:35.626 A:middle
flatMap 和 map 原理很像

00:09:36.076 --> 00:09:36.666 A:middle
名称也类似

00:09:37.696 --> 00:09:38.646 A:middle
你从上游发布者

00:09:38.646 --> 00:09:40.226 A:middle
获得值

00:09:40.226 --> 00:09:41.376 A:middle
但同时预期为获得的值

00:09:41.376 --> 00:09:44.196 A:middle
生成新的发布者

00:09:45.226 --> 00:09:46.356 A:middle
flatMap 便可处理

00:09:46.356 --> 00:09:47.876 A:middle
订阅这个嵌套

00:09:47.876 --> 00:09:49.866 A:middle
发布者的细节

00:09:49.866 --> 00:09:50.896 A:middle
并将值传递给下游

00:09:52.346 --> 00:09:53.366 A:middle
我们先来看看它的工作原理

00:09:53.366 --> 00:09:55.926 A:middle
之后再看代码

00:09:58.176 --> 00:09:59.656 A:middle
和以前一样

00:09:59.656 --> 00:10:00.906 A:middle
值从上游进入我们的

00:10:00.906 --> 00:10:01.936 A:middle
flatMap 操作符

00:10:03.246 --> 00:10:04.856 A:middle
值到达后 flatMap 会调用

00:10:04.856 --> 00:10:07.136 A:middle
一个闭包 将值转换为

00:10:07.466 --> 00:10:09.416 A:middle
一个新的发布者

00:10:09.416 --> 00:10:10.896 A:middle
此时 这个新的发布者是

00:10:10.896 --> 00:10:14.886 A:middle
一个 Just 一个 decode 以及一个 catch

00:10:15.176 --> 00:10:16.056 A:middle
和之前相似

00:10:17.206 --> 00:10:18.946 A:middle
flatMap 之后会订阅

00:10:18.946 --> 00:10:20.576 A:middle
这个新发布者将

00:10:20.576 --> 00:10:21.906 A:middle
结果值传到下游

00:10:25.046 --> 00:10:25.686 A:middle
我想在这个 flatMap 中

00:10:25.686 --> 00:10:27.356 A:middle
追溯另一个值

00:10:27.866 --> 00:10:31.116 A:middle
但这次 请想象

00:10:31.116 --> 00:10:32.706 A:middle
解码在运行中生成

00:10:32.706 --> 00:10:33.326 A:middle
一个错误

00:10:33.906 --> 00:10:35.926 A:middle
当失败抵达

00:10:35.926 --> 00:10:37.656 A:middle
catch 时 它会被

00:10:37.656 --> 00:10:38.656 A:middle
恢复性发布者取代

00:10:39.466 --> 00:10:41.086 A:middle
这个发布者

00:10:41.086 --> 00:10:42.206 A:middle
会被返回至 flatMap

00:10:43.276 --> 00:10:44.976 A:middle
这就可以确保

00:10:44.976 --> 00:10:45.976 A:middle
该操作永远不会失败

00:10:49.046 --> 00:10:50.116 A:middle
现在我们来看看

00:10:50.116 --> 00:10:51.046 A:middle
代码中该怎么用

00:10:51.426 --> 00:10:52.706 A:middle
我们从先前停下的地方继续

00:10:53.566 --> 00:10:56.246 A:middle
也就是我们处理

00:10:56.246 --> 00:10:57.186 A:middle
流中第一个错误的地方

00:10:57.666 --> 00:10:59.506 A:middle
但现在 我们来使用

00:10:59.506 --> 00:11:00.356 A:middle
flatMap 操作符

00:11:00.476 --> 00:11:02.276 A:middle
更改真的很容易

00:11:03.326 --> 00:11:04.766 A:middle
和用 catch 一样

00:11:04.766 --> 00:11:06.296 A:middle
我们用 Just 从收到的数据

00:11:06.296 --> 00:11:08.376 A:middle
创建新的发布者

00:11:08.376 --> 00:11:09.356 A:middle
这就是我们刚从

00:11:09.356 --> 00:11:10.476 A:middle
map 操作符中解码的数据

00:11:11.176 --> 00:11:12.666 A:middle
借助 flatMap 操作符的

00:11:12.666 --> 00:11:15.096 A:middle
嵌套域 我们就可以

00:11:15.096 --> 00:11:16.596 A:middle
依次 return .decode

00:11:16.596 --> 00:11:18.276 A:middle
.catch 并将结果返回给 flatMap

00:11:18.276 --> 00:11:19.606 A:middle
此时 flatMap 会

00:11:19.606 --> 00:11:21.666 A:middle
订阅这个发布者

00:11:21.666 --> 00:11:24.106 A:middle
产生的发布者就会是

00:11:24.106 --> 00:11:25.846 A:middle
MagicTrick 的发布者

00:11:25.846 --> 00:11:30.256 A:middle
且不会失败 我们处理完

00:11:30.256 --> 00:11:31.736 A:middle
上游失败后

00:11:31.736 --> 00:11:33.086 A:middle
需要继续完成

00:11:33.086 --> 00:11:34.846 A:middle
既定目标 也就是尝试

00:11:34.846 --> 00:11:36.926 A:middle
发布法术的名字

00:11:37.416 --> 00:11:40.266 A:middle
有了 Combine 这非常简单

00:11:40.266 --> 00:11:42.146 A:middle
使用另一个操作符

00:11:42.146 --> 00:11:43.376 A:middle
publisher(for:) 操作符即可

00:11:44.136 --> 00:11:45.366 A:middle
我们用它来进入

00:11:45.366 --> 00:11:46.686 A:middle
MagicTrick

00:11:46.736 --> 00:11:48.976 A:middle
通过一个类型安全的关键路径

00:11:48.976 --> 00:11:50.516 A:middle
并生成一个新的发布者 本例中是

00:11:50.556 --> 00:11:51.706 A:middle
发布者返回的类型为字符串

00:11:55.046 --> 00:11:56.636 A:middle
现在 我想谈谈  

00:11:56.636 --> 00:11:58.166 A:middle
最后一种操作符

00:11:58.256 --> 00:11:59.166 A:middle
它能提供一些

00:11:59.166 --> 00:12:00.206 A:middle
强大的功能

00:12:00.766 --> 00:12:03.476 A:middle
我们称其为定时操作符

00:12:03.896 --> 00:12:05.106 A:middle
就像在现实生活中

00:12:05.106 --> 00:12:06.576 A:middle
给东西定时一样

00:12:06.576 --> 00:12:08.726 A:middle
定时操作符可以描述

00:12:08.726 --> 00:12:10.766 A:middle
特定事件何时何地传递

00:12:13.196 --> 00:12:14.326 A:middle
这类操作符受到

00:12:14.326 --> 00:12:15.866 A:middle
RunLoop 和 DispatchQueues 的

00:12:15.866 --> 00:12:18.016 A:middle
原生支持 定时操作符的

00:12:18.016 --> 00:12:19.406 A:middle
例子包括

00:12:20.466 --> 00:12:22.616 A:middle
delay 操作符 可以将

00:12:22.616 --> 00:12:24.976 A:middle
事件传递延后至未来时间

00:12:27.066 --> 00:12:28.066 A:middle
还有 throttle 可以

00:12:28.066 --> 00:12:29.376 A:middle
确保事件传递

00:12:29.376 --> 00:12:30.536 A:middle
不超过某个

00:12:30.536 --> 00:12:31.496 A:middle
特定速率

00:12:33.026 --> 00:12:34.186 A:middle
其他操作符 包括

00:12:34.186 --> 00:12:35.676 A:middle
receive(on:) 可以确保

00:12:35.676 --> 00:12:37.456 A:middle
下游接收的事件

00:12:37.456 --> 00:12:38.216 A:middle
可按照特定的

00:12:38.216 --> 00:12:39.686 A:middle
线程或队列传递

00:12:39.686 --> 00:12:42.936 A:middle
我们就来使用这个操作符

00:12:42.936 --> 00:12:44.506 A:middle
确保法术的名字

00:12:44.506 --> 00:12:46.586 A:middle
始终在主队列中传递

00:12:47.746 --> 00:12:48.986 A:middle
可以看到输出

00:12:48.986 --> 00:12:50.636 A:middle
和失败的类型没有变化

00:12:51.146 --> 00:12:52.116 A:middle
这其实对定时操作符

00:12:52.116 --> 00:12:53.476 A:middle
来说很常见

00:12:54.436 --> 00:12:55.836 A:middle
我们再来研究一下

00:12:55.836 --> 00:12:56.616 A:middle
发布者链剩下的代码

00:12:58.056 --> 00:12:59.686 A:middle
我们之前说到 flatMap

00:13:03.206 --> 00:13:04.726 A:middle
深入 MagicTrick 内部

00:13:04.726 --> 00:13:06.426 A:middle
提取法术的名称

00:13:07.796 --> 00:13:10.646 A:middle
最后 我们把工作

00:13:10.646 --> 00:13:11.446 A:middle
转移到主线程上 用的是

00:13:11.446 --> 00:13:13.376 A:middle
receive(on:) 操作符

00:13:13.816 --> 00:13:14.806 A:middle
如果我们使用的是

00:13:14.806 --> 00:13:16.156 A:middle
AppKit 或 UIKit

00:13:16.156 --> 00:13:17.646 A:middle
其中 UI 依据主线程上下文更新

00:13:17.646 --> 00:13:18.966 A:middle
那现在就实现了

00:13:18.966 --> 00:13:21.306 A:middle
发布的值已经处在

00:13:21.306 --> 00:13:22.546 A:middle
正确的线程上了

00:13:24.036 --> 00:13:25.576 A:middle
如你所见 我们现在

00:13:25.576 --> 00:13:26.626 A:middle
已经能用发布者和

00:13:26.626 --> 00:13:28.236 A:middle
其操作符做很多事情了

00:13:29.206 --> 00:13:30.446 A:middle
我们在最初的

00:13:30.446 --> 00:13:32.546 A:middle
方案上 不断添加操作符

00:13:32.546 --> 00:13:34.516 A:middle
依次进行修改

00:13:34.626 --> 00:13:36.856 A:middle
最终循序渐进 产生了强类型值

00:13:37.396 --> 00:13:39.736 A:middle
我们看到发布者

00:13:39.736 --> 00:13:40.606 A:middle
能同步产生值

00:13:40.606 --> 00:13:42.806 A:middle
正如在 Just 的例子中

00:13:43.156 --> 00:13:45.226 A:middle
同时 它还能异步运作 例如使用

00:13:45.226 --> 00:13:46.126 A:middle
NotificationCenter

00:13:46.676 --> 00:13:48.936 A:middle
但现在 我想关注

00:13:48.936 --> 00:13:49.856 A:middle
值发布的

00:13:49.856 --> 00:13:50.846 A:middle
另一面

00:13:51.336 --> 00:13:52.996 A:middle
也就是值的接收

00:13:54.306 --> 00:13:55.836 A:middle
现在我想谈谈订阅者

00:13:58.246 --> 00:13:59.306 A:middle
和发布者一样

00:13:59.586 --> 00:14:01.166 A:middle
Combine 中的订阅者有两个

00:14:01.166 --> 00:14:03.326 A:middle
associatedtype 即它们的输入

00:14:04.106 --> 00:14:05.836 A:middle
和它们容许的失败

00:14:07.576 --> 00:14:09.416 A:middle
它们也描述了三个

00:14:09.416 --> 00:14:10.596 A:middle
事件函数 分别对应

00:14:10.596 --> 00:14:13.606 A:middle
接收订阅 接收值 以及结束

00:14:14.176 --> 00:14:16.516 A:middle
这三个函数调用的

00:14:16.516 --> 00:14:18.186 A:middle
顺序经过严格定义

00:14:18.416 --> 00:14:19.486 A:middle
总结起来 遵循

00:14:19.576 --> 00:14:20.416 A:middle
三条规则

00:14:20.906 --> 00:14:24.426 A:middle
规则一 回应

00:14:24.426 --> 00:14:26.246 A:middle
订阅调用时 发布者

00:14:26.246 --> 00:14:28.476 A:middle
只会调用一次 receive(subscription:)

00:14:28.566 --> 00:14:29.696 A:middle
不多不少

00:14:33.066 --> 00:14:36.216 A:middle
规则二 发布者之后

00:14:36.216 --> 00:14:38.246 A:middle
可以提供零个或更多值

00:14:38.246 --> 00:14:39.786 A:middle
传递给下游的订阅者

00:14:39.786 --> 00:14:41.766 A:middle
以回应订阅者的请求

00:14:44.346 --> 00:14:46.196 A:middle
规则三 发布者

00:14:46.196 --> 00:14:47.596 A:middle
至多只能发送一个结束信号

00:14:47.596 --> 00:14:49.356 A:middle
这个结束

00:14:49.356 --> 00:14:50.566 A:middle
可以表明发布者

00:14:50.566 --> 00:14:52.946 A:middle
已经完成 或者

00:14:52.946 --> 00:14:53.526 A:middle
发生了失败

00:14:54.476 --> 00:14:55.646 A:middle
这个结束信号一旦发出

00:14:55.646 --> 00:14:58.826 A:middle
便不会有其他值被传出

00:14:59.406 --> 00:15:01.406 A:middle
这三条规则可以

00:15:01.406 --> 00:15:02.656 A:middle
归纳如下

00:15:03.176 --> 00:15:05.806 A:middle
订阅者只会收到

00:15:05.806 --> 00:15:08.956 A:middle
一个订阅 之后是

00:15:09.116 --> 00:15:11.606 A:middle
零个或多个值

00:15:11.606 --> 00:15:12.616 A:middle
可能由一个结束终止

00:15:12.616 --> 00:15:16.146 A:middle
表明发布完成或失败

00:15:17.306 --> 00:15:19.086 A:middle
我之所以说 可能

00:15:19.086 --> 00:15:20.276 A:middle
是因为结束是可选的

00:15:20.866 --> 00:15:22.366 A:middle
许多特定流理论上

00:15:22.366 --> 00:15:23.576 A:middle
可以无限进行

00:15:23.576 --> 00:15:25.346 A:middle
例如先前的 NotificationCenter 示例

00:15:28.356 --> 00:15:30.476 A:middle
Combine 中 我们支持

00:15:30.476 --> 00:15:31.856 A:middle
各种各样的订阅者

00:15:32.176 --> 00:15:33.856 A:middle
我想向大家展示一下它们如何工作

00:15:36.516 --> 00:15:37.596 A:middle
我们回到之前的发布者示例

00:15:37.596 --> 00:15:40.046 A:middle
但我们现在

00:15:40.046 --> 00:15:42.006 A:middle
想要了解的是

00:15:42.006 --> 00:15:43.486 A:middle
我们正在使用的发布者

00:15:44.096 --> 00:15:45.316 A:middle
我们就先腾出点儿地方来

00:15:47.316 --> 00:15:48.676 A:middle
然后添加一个订阅者

00:15:50.206 --> 00:15:52.336 A:middle
这里 我添加了 Combine 中最简单的订阅类型

00:15:52.336 --> 00:15:55.376 A:middle
关键路径赋值

00:15:56.216 --> 00:15:58.406 A:middle
使用的是 assign(to: on:)这个操作符

00:15:58.826 --> 00:16:00.766 A:middle
它可以确保

00:16:00.766 --> 00:16:02.226 A:middle
上游发布者释放的

00:16:02.226 --> 00:16:03.466 A:middle
任何值都会赋值给

00:16:03.466 --> 00:16:04.846 A:middle
特定关键路径

00:16:04.846 --> 00:16:05.876 A:middle
下的特定对象

00:16:06.316 --> 00:16:08.266 A:middle
而就是从现在起

00:16:08.266 --> 00:16:09.636 A:middle
我们几乎可以随意

00:16:09.636 --> 00:16:10.716 A:middle
使用任何发布者并为

00:16:10.716 --> 00:16:11.886 A:middle
任何属性赋值

00:16:11.926 --> 00:16:12.656 A:middle
功能非常强大

00:16:13.106 --> 00:16:15.886 A:middle
这个操作符还会产生一个

00:16:15.886 --> 00:16:17.386 A:middle
取消令牌

00:16:17.386 --> 00:16:18.656 A:middle
你可以之后调用它

00:16:18.656 --> 00:16:19.256 A:middle
从而终止订阅

00:16:19.256 --> 00:16:23.356 A:middle
我想多谈谈取消

00:16:23.856 --> 00:16:26.386 A:middle
我们在 Combine 中

00:16:26.386 --> 00:16:28.196 A:middle
构建了取消

00:16:28.196 --> 00:16:29.836 A:middle
因为它便于在发布者

00:16:29.836 --> 00:16:31.666 A:middle
结束传递事件之前

00:16:31.666 --> 00:16:34.096 A:middle
终止订阅

00:16:35.156 --> 00:16:36.336 A:middle
如果你想释放

00:16:36.336 --> 00:16:37.366 A:middle
与此订阅相关的资源

00:16:37.366 --> 00:16:38.816 A:middle
这一点尤其有用

00:16:39.996 --> 00:16:41.796 A:middle
当然 取消是一种

00:16:41.796 --> 00:16:43.646 A:middle
尽力服务

00:16:43.646 --> 00:16:44.686 A:middle
但它可以满足你的需求

00:16:44.686 --> 00:16:45.976 A:middle
为订阅者取消订阅

00:16:48.236 --> 00:16:49.546 A:middle
我们引入了新协议

00:16:49.546 --> 00:16:50.566 A:middle
用以描述

00:16:50.566 --> 00:16:52.546 A:middle
可以取消或被取消的事物

00:16:53.326 --> 00:16:55.306 A:middle
我们引入了

00:16:55.306 --> 00:16:56.926 A:middle
一个极为便利的类

00:16:57.086 --> 00:16:58.866 A:middle
叫做 AnyCancellable

00:16:58.866 --> 00:17:00.146 A:middle
它带来的好处是

00:17:00.356 --> 00:17:01.476 A:middle
它可以自动

00:17:01.476 --> 00:17:02.706 A:middle
在清理阶段时调用 cancel

00:17:04.036 --> 00:17:05.465 A:middle
这可以显著减少

00:17:05.465 --> 00:17:06.376 A:middle
你需要专门调用

00:17:06.376 --> 00:17:08.246 A:middle
cancel 的次数

00:17:09.056 --> 00:17:10.586 A:middle
你只需要依靠 Swift

00:17:10.586 --> 00:17:12.136 A:middle
提供的强大

00:17:12.136 --> 00:17:13.646 A:middle
内存管理能力即可

00:17:15.296 --> 00:17:16.846 A:middle
我们接下来看看

00:17:16.846 --> 00:17:18.336 A:middle
第二种订阅形式

00:17:18.846 --> 00:17:21.366 A:middle
这里用到了 sink 操作符

00:17:21.796 --> 00:17:23.445 A:middle
这种方法很棒

00:17:23.445 --> 00:17:24.906 A:middle
你只要提供一个闭包

00:17:24.906 --> 00:17:26.236 A:middle
对收到的任何值

00:17:26.236 --> 00:17:27.316 A:middle
这个闭包都会被调用

00:17:27.316 --> 00:17:28.465 A:middle
你就可以对它进行

00:17:28.465 --> 00:17:30.476 A:middle
你想要的任何额外修改

00:17:31.236 --> 00:17:34.366 A:middle
和 assign 一样 sink 会返回

00:17:34.436 --> 00:17:36.476 A:middle
一个 canceller

00:17:36.476 --> 00:17:37.856 A:middle
之后你可以用它来终止订阅

00:17:41.046 --> 00:17:42.076 A:middle
第三种订阅方式是

00:17:42.116 --> 00:17:43.276 A:middle
两者的结合

00:17:43.956 --> 00:17:45.996 A:middle
我们称它们为主题

00:17:45.996 --> 00:17:46.826 A:middle
它们的行为既有点像

00:17:46.826 --> 00:17:48.756 A:middle
发布者也有点儿像订阅者

00:17:50.096 --> 00:17:50.966 A:middle
它们一般支持

00:17:50.966 --> 00:17:52.466 A:middle
将收到的值发送给多个目标

00:17:52.466 --> 00:17:54.326 A:middle
格外重要的是

00:17:54.326 --> 00:17:56.316 A:middle
你可以用它们

00:17:56.316 --> 00:17:57.406 A:middle
命令式的发送值

00:17:57.776 --> 00:17:59.156 A:middle
这一点极其重要

00:17:59.156 --> 00:18:00.596 A:middle
特别是当你在已有的

00:18:00.596 --> 00:18:01.926 A:middle
代码基础上工作的时候

00:18:03.396 --> 00:18:04.356 A:middle
我们来看看它们是

00:18:04.356 --> 00:18:06.556 A:middle
如何工作的 之后再展示

00:18:06.556 --> 00:18:07.416 A:middle
如何在实践中运用

00:18:07.936 --> 00:18:10.536 A:middle
我之前提到 使用主题

00:18:10.706 --> 00:18:12.276 A:middle
便可以向多个

00:18:12.276 --> 00:18:13.326 A:middle
下游订阅者广播

00:18:13.326 --> 00:18:15.686 A:middle
也可以

00:18:15.906 --> 00:18:17.196 A:middle
命令式发送值

00:18:18.276 --> 00:18:20.196 A:middle
任何收到的值都会

00:18:20.196 --> 00:18:21.976 A:middle
广播给所有下游订阅者

00:18:24.156 --> 00:18:25.916 A:middle
如果值都是由上游

00:18:25.916 --> 00:18:26.976 A:middle
发布者产生的 也会如此广播

00:18:30.046 --> 00:18:31.616 A:middle
Combine 中 我们支持两种主题

00:18:31.916 --> 00:18:34.046 A:middle
一种是 Passthrough

00:18:34.046 --> 00:18:36.156 A:middle
其中不存储值

00:18:36.466 --> 00:18:37.716 A:middle
只有你订阅这个主题的时候

00:18:37.716 --> 00:18:38.976 A:middle
你才能看到值

00:18:41.616 --> 00:18:43.716 A:middle
我们还支持 CurrentValue 主题

00:18:44.526 --> 00:18:46.016 A:middle
它保留了收到的

00:18:46.016 --> 00:18:47.186 A:middle
最后一个值的历史记录

00:18:47.766 --> 00:18:49.056 A:middle
这样新的订阅者

00:18:49.056 --> 00:18:50.906 A:middle
就能很好的交接

00:18:53.066 --> 00:18:54.306 A:middle
现在 来看看它们在实际操作中的样子

00:18:54.306 --> 00:18:55.706 A:middle
和之前一样 我们先来看发布者

00:18:57.256 --> 00:18:58.986 A:middle
创建主题非常简单

00:18:58.986 --> 00:19:00.326 A:middle
只需选取你需要的主题

00:19:00.606 --> 00:19:01.826 A:middle
指明输出和

00:19:01.826 --> 00:19:03.956 A:middle
失败类型并调用构造函数

00:19:08.336 --> 00:19:09.916 A:middle
主题的行为和订阅者类似

00:19:10.126 --> 00:19:11.416 A:middle
因为它们都要订阅

00:19:11.416 --> 00:19:12.346 A:middle
上游发布者

00:19:12.926 --> 00:19:15.906 A:middle
同时 它也类似发布者

00:19:15.906 --> 00:19:17.126 A:middle
需要调用我今天

00:19:17.126 --> 00:19:18.356 A:middle
提到过的操作符

00:19:18.576 --> 00:19:20.276 A:middle
比如 sink 等

00:19:20.276 --> 00:19:22.076 A:middle
来形成订阅自己的订阅者

00:19:22.596 --> 00:19:24.876 A:middle
你甚至还可以命令式的发送值

00:19:24.876 --> 00:19:26.896 A:middle
比如这个有魔力的词语

00:19:28.516 --> 00:19:30.586 A:middle
事实上 主题非常常用

00:19:30.586 --> 00:19:32.016 A:middle
我们甚至定义了

00:19:32.016 --> 00:19:33.456 A:middle
操作符 来向流中

00:19:33.456 --> 00:19:35.176 A:middle
注入主题 例如 Share

00:19:35.516 --> 00:19:36.636 A:middle
它可以将 Passthrough 主题

00:19:36.636 --> 00:19:39.666 A:middle
注入流中

00:19:39.856 --> 00:19:41.256 A:middle
主题的功能非常非常强大

00:19:41.256 --> 00:19:43.796 A:middle
你会发现很多

00:19:43.796 --> 00:19:44.776 A:middle
有趣的使用方法

00:19:44.776 --> 00:19:46.846 A:middle
接下来 我想

00:19:46.846 --> 00:19:47.876 A:middle
换个话题 谈谈

00:19:47.876 --> 00:19:49.236 A:middle
第四种 也是最后一种订阅者

00:19:49.236 --> 00:19:53.396 A:middle
就是与 SwiftUI 集成

00:19:55.156 --> 00:19:56.876 A:middle
SwiftUI 了不起的一点

00:19:56.876 --> 00:19:58.656 A:middle
就是你只需要

00:19:58.656 --> 00:20:00.526 A:middle
在 App 中

00:20:00.526 --> 00:20:01.656 A:middle
描述依赖

00:20:01.656 --> 00:20:03.226 A:middle
剩下的就可交给框架代劳

00:20:04.526 --> 00:20:05.866 A:middle
就 Combine 而言

00:20:06.146 --> 00:20:07.266 A:middle
这意味着你只需要

00:20:07.266 --> 00:20:08.786 A:middle
提供发布者

00:20:08.786 --> 00:20:11.526 A:middle
描述数据何时改变 如何改变

00:20:13.056 --> 00:20:15.306 A:middle
为此 你只需要

00:20:15.306 --> 00:20:16.626 A:middle
让自定义类型遵从

00:20:16.626 --> 00:20:18.016 A:middle
BindableObject 协议

00:20:19.406 --> 00:20:21.176 A:middle
SwiftUI 中的 BindableObjects

00:20:21.176 --> 00:20:22.286 A:middle
只有一个 associatedtype

00:20:22.976 --> 00:20:26.596 A:middle
这个发布者

00:20:26.596 --> 00:20:27.926 A:middle
限制为永远不失败

00:20:27.926 --> 00:20:29.566 A:middle
这可以与 UI 框架

00:20:29.566 --> 00:20:31.436 A:middle
配合得天衣无缝

00:20:31.466 --> 00:20:32.786 A:middle
因为这种语言的

00:20:32.786 --> 00:20:34.076 A:middle
类型系统强制要求你

00:20:34.076 --> 00:20:35.826 A:middle
先处理上游错误

00:20:35.986 --> 00:20:37.766 A:middle
再接触发布者

00:20:40.096 --> 00:20:41.456 A:middle
最后 你指定

00:20:41.456 --> 00:20:43.156 A:middle
一个名为

00:20:43.446 --> 00:20:45.026 A:middle
didChange 的属性

00:20:45.026 --> 00:20:46.536 A:middle
产生实际发布者来通知你

00:20:46.536 --> 00:20:48.226 A:middle
你的类型何时改变

00:20:48.226 --> 00:20:49.196 A:middle
就这样

00:20:50.476 --> 00:20:52.096 A:middle
要想进一步了解 SwiftUI 中

00:20:52.176 --> 00:20:53.736 A:middle
数据流的工作原理 我强烈建议

00:20:53.736 --> 00:20:54.876 A:middle
大家观看 Data Flow Through SwiftUI 会议

00:20:54.876 --> 00:20:56.606 A:middle
我们在其中

00:20:56.606 --> 00:20:57.816 A:middle
深入探讨了许多

00:20:57.816 --> 00:20:59.416 A:middle
可以实现的细节

00:21:02.176 --> 00:21:03.676 A:middle
我来向大家展示它的实际表现

00:21:05.166 --> 00:21:06.426 A:middle
首先 我们从

00:21:06.426 --> 00:21:08.146 A:middle
巫师学校 App 中的

00:21:08.146 --> 00:21:09.216 A:middle
现有模型开始

00:21:09.866 --> 00:21:12.176 A:middle
之后 我们添加

00:21:12.176 --> 00:21:12.986 A:middle
遵循 BindableObject

00:21:13.326 --> 00:21:14.326 A:middle
现在 我们用

00:21:14.326 --> 00:21:15.676 A:middle
主题来描述我们的

00:21:15.676 --> 00:21:17.066 A:middle
模型对象如何改变

00:21:18.146 --> 00:21:19.006 A:middle
我们真的不需要

00:21:19.006 --> 00:21:20.656 A:middle
主题传递任何

00:21:20.656 --> 00:21:23.806 A:middle
特定种类的值

00:21:23.806 --> 00:21:25.146 A:middle
因为这个框架可以根据我们

00:21:25.146 --> 00:21:26.266 A:middle
对主体方法的调用

00:21:26.266 --> 00:21:26.586 A:middle
自行处理

00:21:26.586 --> 00:21:27.936 A:middle
我们就选 void 作为

00:21:27.936 --> 00:21:29.506 A:middle
主题输出的类型

00:21:32.296 --> 00:21:33.666 A:middle
像这样使用主题

00:21:33.666 --> 00:21:35.636 A:middle
十分灵活 因为现在

00:21:35.636 --> 00:21:36.716 A:middle
我们可以在对象变化时

00:21:36.716 --> 00:21:38.976 A:middle
命令式发送信息

00:21:41.256 --> 00:21:43.546 A:middle
但现在 我们就先使用一些

00:21:43.546 --> 00:21:45.346 A:middle
属性观察器

00:21:45.346 --> 00:21:47.326 A:middle
直接在主题中调用 send

00:21:47.326 --> 00:21:48.796 A:middle
当任一属性变化时

00:21:48.796 --> 00:21:49.966 A:middle
表明我们的

00:21:49.966 --> 00:21:51.226 A:middle
模型对象也变化了

00:21:51.646 --> 00:21:54.616 A:middle
接下来 我们要将这个模型

00:21:54.616 --> 00:21:57.326 A:middle
与 SwiftUI 视图挂钩

00:21:57.326 --> 00:22:00.486 A:middle
操作如下 我们声明一个

00:22:00.486 --> 00:22:02.036 A:middle
ObjectBinding 类型的模型 这样

00:22:02.036 --> 00:22:03.346 A:middle
SwiftUI 就能自动

00:22:03.346 --> 00:22:05.206 A:middle
发现并订阅我们的发布者

00:22:05.936 --> 00:22:10.336 A:middle
之后 我们在 body 属性引用

00:22:10.336 --> 00:22:12.796 A:middle
模型的属性 就这样

00:22:13.886 --> 00:22:15.346 A:middle
SwiftUI 会自动

00:22:15.346 --> 00:22:17.166 A:middle
在你表明模型发生变化时

00:22:17.166 --> 00:22:18.686 A:middle
生成新的主体

00:22:22.046 --> 00:22:22.876 A:middle
我想大家展示了 Combine

00:22:22.876 --> 00:22:24.036 A:middle
有非常多的内置

00:22:24.036 --> 00:22:25.186 A:middle
功能 大家可以

00:22:25.186 --> 00:22:26.696 A:middle
自己组织 合成许多

00:22:26.696 --> 00:22:27.436 A:middle
强大的功能

00:22:28.536 --> 00:22:30.146 A:middle
我们非常兴奋 

00:22:30.246 --> 00:22:31.576 A:middle
因为有了新框架

00:22:31.576 --> 00:22:32.686 A:middle
你就能够大幅

00:22:32.686 --> 00:22:34.376 A:middle
简化异步数据流

00:22:34.916 --> 00:22:36.876 A:middle
要展示这一点

00:22:36.876 --> 00:22:37.946 A:middle
我的同事 Ben 会上台

00:22:37.946 --> 00:22:38.826 A:middle
告诉大家 如何

00:22:38.826 --> 00:22:40.226 A:middle
进一步将这些

00:22:40.226 --> 00:22:41.546 A:middle
强大功能整合进

00:22:41.546 --> 00:22:43.686 A:middle
你现有的 App 中 谢谢大家

00:22:44.516 --> 00:22:50.316 A:middle
[掌声]

00:22:50.816 --> 00:22:51.346 A:middle
&gt;&gt; 谢谢 Michael

00:22:51.456 --> 00:22:52.806 A:middle
我很高兴今天在这里

00:22:52.806 --> 00:22:53.976 A:middle
见到大家

00:22:56.066 --> 00:22:57.646 A:middle
设计 Combine 时

00:22:57.646 --> 00:22:58.746 A:middle
我们高度重视构成

00:22:59.166 --> 00:23:00.126 A:middle
如大家在 Michael 的

00:23:00.126 --> 00:23:02.696 A:middle
示例中所见 我们从一个

00:23:02.696 --> 00:23:04.646 A:middle
简单的发布者开始 经过

00:23:04.646 --> 00:23:05.776 A:middle
各种转换后

00:23:06.206 --> 00:23:08.736 A:middle
创造了最终的发布者实现了目标

00:23:08.736 --> 00:23:12.346 A:middle
我们来看个例子

00:23:12.956 --> 00:23:14.936 A:middle
我们要在

00:23:14.936 --> 00:23:16.326 A:middle
App 中提供注册功能

00:23:16.326 --> 00:23:17.856 A:middle
这样 巫师就能在我们的

00:23:17.856 --> 00:23:18.446 A:middle
巫师学校注册了

00:23:18.446 --> 00:23:20.676 A:middle
我们有一些要求

00:23:22.116 --> 00:23:23.236 A:middle
首先 我们要保证

00:23:23.236 --> 00:23:25.266 A:middle
用户名通过服务器验证

00:23:25.766 --> 00:23:30.076 A:middle
第二 我们有密码字段

00:23:30.146 --> 00:23:31.636 A:middle
和密码验证

00:23:31.676 --> 00:23:33.136 A:middle
我们要保证二者相同

00:23:33.936 --> 00:23:34.976 A:middle
且长度都大于八个字符

00:23:37.046 --> 00:23:38.176 A:middle
最后 我们要保证

00:23:38.176 --> 00:23:39.836 A:middle
如果这些条件

00:23:39.836 --> 00:23:41.926 A:middle
都满足 我们就能启用或禁用 UI

00:23:43.306 --> 00:23:44.966 A:middle
所以 这个例子中 我们有

00:23:44.966 --> 00:23:46.636 A:middle
异步行为

00:23:46.636 --> 00:23:48.076 A:middle
有一些设备本地的

00:23:48.076 --> 00:23:49.646 A:middle
同步行为 我们

00:23:49.646 --> 00:23:50.506 A:middle
还要能够把它们

00:23:50.506 --> 00:23:51.016 A:middle
组合起来

00:23:51.016 --> 00:23:52.616 A:middle
我们来看看 Combine 能

00:23:52.616 --> 00:23:53.806 A:middle
提供什么帮助

00:23:56.106 --> 00:23:58.156 A:middle
首先 我要用 Interface

00:23:58.156 --> 00:23:59.606 A:middle
Builder 为密码字段

00:23:59.606 --> 00:24:00.996 A:middle
在值变化属性上

00:24:00.996 --> 00:24:02.466 A:middle
创建目标动作

00:24:05.046 --> 00:24:06.246 A:middle
在代码中使用后

00:24:07.126 --> 00:24:08.536 A:middle
只要用户在这些字段中输入

00:24:08.536 --> 00:24:10.146 A:middle
我们就能收到信号

00:24:10.676 --> 00:24:12.076 A:middle
我们会获取当前值的

00:24:12.076 --> 00:24:14.116 A:middle
文本属性

00:24:14.116 --> 00:24:15.836 A:middle
并将其存入实例变量

00:24:16.876 --> 00:24:18.456 A:middle
但我们想把它们

00:24:18.456 --> 00:24:19.816 A:middle
和其他行为组合

00:24:19.816 --> 00:24:20.676 A:middle
特别是我们先前

00:24:20.676 --> 00:24:23.376 A:middle
提到的同步行为该怎么做

00:24:24.676 --> 00:24:27.776 A:middle
很简单 只要将 Published

00:24:27.776 --> 00:24:29.266 A:middle
添加至每个属性 我们就能

00:24:29.266 --> 00:24:30.946 A:middle
对他们添加发布者

00:24:34.066 --> 00:24:35.536 A:middle
Published 是一个属性包装器

00:24:35.536 --> 00:24:37.206 A:middle
它使用 Swift 5.1

00:24:37.206 --> 00:24:39.706 A:middle
中的新特性 将发布者添加到

00:24:39.706 --> 00:24:40.546 A:middle
任何给定属性

00:24:42.106 --> 00:24:43.376 A:middle
我们通过几个简单例子

00:24:43.376 --> 00:24:44.516 A:middle
来看看如何使用它

00:24:47.216 --> 00:24:48.946 A:middle
Published 属性包装器

00:24:48.946 --> 00:24:50.546 A:middle
按你的需求

00:24:50.546 --> 00:24:51.936 A:middle
添加在属性前

00:24:53.326 --> 00:24:54.926 A:middle
在代码中使用时

00:24:54.926 --> 00:24:55.966 A:middle
就和以前一样

00:24:56.556 --> 00:25:00.056 A:middle
我们也可以储存它

00:25:00.056 --> 00:25:00.886 A:middle
得到字符串值

00:25:00.886 --> 00:25:02.196 A:middle
这个例子中 currentPassword

00:25:02.196 --> 00:25:03.976 A:middle
现在是字符串 1234

00:25:06.166 --> 00:25:07.486 A:middle
它的特殊之处在于

00:25:07.486 --> 00:25:08.776 A:middle
我们要用 $

00:25:08.776 --> 00:25:09.426 A:middle
作前缀引用它

00:25:09.786 --> 00:25:11.096 A:middle
这样 我们就在访问

00:25:11.096 --> 00:25:11.916 A:middle
被包装的值

00:25:12.616 --> 00:25:14.966 A:middle
我们之后就能使用

00:25:14.966 --> 00:25:16.426 A:middle
平常对发布者

00:25:16.426 --> 00:25:18.186 A:middle
使用的操作符或订阅它

00:25:18.186 --> 00:25:20.216 A:middle
此时要用 sink

00:25:20.216 --> 00:25:23.756 A:middle
之后 如果我们要

00:25:23.756 --> 00:25:25.826 A:middle
再将属性设定成另一个

00:25:25.826 --> 00:25:27.436 A:middle
伟大的密码 password

00:25:28.136 --> 00:25:30.726 A:middle
我们的订阅者就会在变化时收到值

00:25:31.626 --> 00:25:32.796 A:middle
显然 这个人没有

00:25:32.796 --> 00:25:33.966 A:middle
关注密码安全

00:25:37.196 --> 00:25:38.366 A:middle
我们谈到 要对

00:25:38.366 --> 00:25:40.436 A:middle
我们的两个发布者

00:25:40.436 --> 00:25:41.776 A:middle
同时进行判断

00:25:44.086 --> 00:25:45.506 A:middle
我们为它们添加了

00:25:45.586 --> 00:25:46.866 A:middle
Published 属性 并添加了

00:25:46.866 --> 00:25:47.946 A:middle
两个发布者也就是

00:25:47.946 --> 00:25:49.186 A:middle
被发布的字符串 不会失败

00:25:49.906 --> 00:25:52.506 A:middle
我们想要的结果是

00:25:52.506 --> 00:25:54.216 A:middle
只发布一个

00:25:54.216 --> 00:25:56.306 A:middle
验证过的密码

00:25:58.116 --> 00:25:59.726 A:middle
我们为此有一个操作符

00:25:59.726 --> 00:26:01.496 A:middle
叫做 CombineLatest

00:26:05.046 --> 00:26:06.106 A:middle
这里是我们之前

00:26:06.386 --> 00:26:07.446 A:middle
提到的两个属性

00:26:08.096 --> 00:26:09.766 A:middle
借助 CombineLatest 我们就能

00:26:09.766 --> 00:26:11.366 A:middle
引用带美元符号

00:26:11.456 --> 00:26:13.486 A:middle
前缀的属性包装器

00:26:14.176 --> 00:26:16.096 A:middle
之后 当任何一个改变时

00:26:16.166 --> 00:26:17.476 A:middle
我们就能收到信号

00:26:17.856 --> 00:26:19.176 A:middle
比方说 如果用户

00:26:19.176 --> 00:26:21.066 A:middle
已经在密码字段输入了

00:26:21.136 --> 00:26:22.486 A:middle
现在开始在

00:26:22.486 --> 00:26:24.166 A:middle
密码确认字段中输入内容

00:26:24.686 --> 00:26:25.976 A:middle
PasswordAgain 就会改变

00:26:25.976 --> 00:26:27.016 A:middle
而 Password 仍是

00:26:27.016 --> 00:26:29.166 A:middle
原先输入第一个字段的值

00:26:29.656 --> 00:26:32.156 A:middle
之后 我们就能用闭包

00:26:32.156 --> 00:26:33.636 A:middle
确保我们符合

00:26:33.636 --> 00:26:34.716 A:middle
行业要求 也就是

00:26:34.716 --> 00:26:36.246 A:middle
二者要相同 且长度

00:26:36.246 --> 00:26:38.856 A:middle
都大于八个字符

00:26:38.896 --> 00:26:40.496 A:middle
否则 我们就返回 nil

00:26:40.496 --> 00:26:41.496 A:middle
因为我们要将

00:26:41.496 --> 00:26:42.676 A:middle
这个信号与其他信号

00:26:42.676 --> 00:26:43.886 A:middle
共同使用 判断我们的

00:26:43.886 --> 00:26:44.816 A:middle
表单是否有效

00:26:45.616 --> 00:26:47.636 A:middle
为此 我们将 nil 作为我们的信号

00:26:50.206 --> 00:26:52.596 A:middle
所以 和类型一样

00:26:52.716 --> 00:26:54.946 A:middle
类型反映了我们采取的措施

00:26:55.716 --> 00:26:56.726 A:middle
我们可以直接在

00:26:56.726 --> 00:26:57.726 A:middle
代码中读出

00:26:58.226 --> 00:27:00.106 A:middle
我们有两个 Pulished 的字符串

00:27:00.616 --> 00:27:02.116 A:middle
我们组合了它们最新的值

00:27:02.376 --> 00:27:04.276 A:middle
最后获得了可选字符串

00:27:07.076 --> 00:27:08.216 A:middle
但如果我们的要求是

00:27:08.216 --> 00:27:09.146 A:middle
想要确保

00:27:09.146 --> 00:27:10.046 A:middle
人们不去用那些糟糕的密码

00:27:10.046 --> 00:27:12.206 A:middle
并添加一个 Map 呢

00:27:13.256 --> 00:27:14.586 A:middle
可以看到 类型在这里发生了变化

00:27:15.206 --> 00:27:16.846 A:middle
可以看出 我们组合了

00:27:16.846 --> 00:27:18.156 A:middle
两个 Published 字符串的

00:27:18.156 --> 00:27:20.076 A:middle
最新值

00:27:20.076 --> 00:27:21.536 A:middle
用 map 处理 得到可选字符串

00:27:23.006 --> 00:27:24.596 A:middle
这很棒 可以在

00:27:24.596 --> 00:27:25.896 A:middle
几乎所有用例中

00:27:25.896 --> 00:27:26.676 A:middle
帮助调试

00:27:27.076 --> 00:27:28.406 A:middle
但这个例子中 我们就

00:27:28.516 --> 00:27:29.706 A:middle
把它作为 API 边界

00:27:29.826 --> 00:27:31.256 A:middle
希望将它

00:27:31.256 --> 00:27:32.106 A:middle
与其他发布者组合

00:27:32.106 --> 00:27:33.996 A:middle
所以 如果我们

00:27:33.996 --> 00:27:35.626 A:middle
能只关注重点的话 岂不美哉

00:27:35.626 --> 00:27:37.236 A:middle
这里的重点是 这是一个

00:27:37.236 --> 00:27:39.126 A:middle
可选字符串发布者不会失败

00:27:40.576 --> 00:27:43.416 A:middle
为此 我们有一个操作符

00:27:43.416 --> 00:27:45.466 A:middle
叫做 eraseToAnyPublisher

00:27:45.466 --> 00:27:47.226 A:middle
可以返回可选字符串或 never 的

00:27:47.226 --> 00:27:48.856 A:middle
AnyPublisher

00:27:49.346 --> 00:27:51.556 A:middle
可以看到 类型

00:27:51.556 --> 00:27:53.016 A:middle
并没有变化 但

00:27:53.016 --> 00:27:54.366 A:middle
我们确实可以把它

00:27:54.366 --> 00:27:55.706 A:middle
当作我们想要的 API

00:27:55.836 --> 00:27:57.306 A:middle
边界推广 还能顺便

00:27:57.306 --> 00:27:58.856 A:middle
隐藏所有的实现细节

00:28:02.246 --> 00:28:04.376 A:middle
都做了什么 我们的

00:28:04.376 --> 00:28:05.816 A:middle
初始属性是字符串

00:28:05.816 --> 00:28:07.386 A:middle
为它添加了字符串发布者

00:28:07.676 --> 00:28:09.506 A:middle
其中使用了 Published 属性包装器

00:28:10.056 --> 00:28:12.486 A:middle
我们之后使用了 CombineLatest

00:28:12.486 --> 00:28:13.606 A:middle
组合了这两个发布者的

00:28:13.606 --> 00:28:15.986 A:middle
的最新值 并添加了

00:28:15.986 --> 00:28:16.926 A:middle
我们的业务逻辑

00:28:17.436 --> 00:28:21.376 A:middle
之后我们使用 map 来过滤

00:28:21.376 --> 00:28:24.696 A:middle
糟糕的密码 最后

00:28:24.696 --> 00:28:26.046 A:middle
我们用了 eraseToAnyPublishser

00:28:26.166 --> 00:28:27.566 A:middle
因为这是 API 边界

00:28:27.566 --> 00:28:28.976 A:middle
我们要将它和别的东西组合起来

00:28:32.276 --> 00:28:33.756 A:middle
真了不起 我们有了第一个发布者

00:28:38.046 --> 00:28:40.716 A:middle
接下来 我们还想

00:28:40.716 --> 00:28:42.146 A:middle
为一些异步活动

00:28:42.146 --> 00:28:43.056 A:middle
构建模型

00:28:43.626 --> 00:28:45.606 A:middle
我们要保证用户名通过

00:28:45.606 --> 00:28:46.926 A:middle
服务器验证 这需要

00:28:46.926 --> 00:28:48.546 A:middle
快速处理用户输入

00:28:49.176 --> 00:28:51.706 A:middle
和之前一样 我们给

00:28:52.296 --> 00:28:54.096 A:middle
字符串属性存储添加 Pulished 属性

00:28:54.356 --> 00:28:55.706 A:middle
再给 valueChanged

00:28:55.706 --> 00:28:58.336 A:middle
属性挂上一个目标动作

00:28:58.796 --> 00:28:59.726 A:middle
但这里有点特殊

00:28:59.726 --> 00:29:01.846 A:middle
因为我们不想

00:29:01.846 --> 00:29:02.906 A:middle
用户每输入

00:29:02.906 --> 00:29:04.296 A:middle
一个字符 就

00:29:04.296 --> 00:29:05.576 A:middle
发起一次网络运行

00:29:05.976 --> 00:29:07.276 A:middle
不然 服务器会被挤爆的

00:29:07.276 --> 00:29:08.986 A:middle
我们要让信号

00:29:08.986 --> 00:29:10.706 A:middle
发送更顺畅

00:29:11.516 --> 00:29:13.066 A:middle
为此 我们有函数防抖

00:29:13.826 --> 00:29:16.326 A:middle
你可以用函数防抖

00:29:16.326 --> 00:29:17.786 A:middle
制定你想接收值的窗口

00:29:17.786 --> 00:29:19.056 A:middle
且接收值

00:29:19.056 --> 00:29:20.926 A:middle
不早于这个窗口

00:29:20.926 --> 00:29:23.126 A:middle
我们来看个实例

00:29:24.486 --> 00:29:25.986 A:middle
这是我们的上游发布者

00:29:26.536 --> 00:29:27.496 A:middle
这个例子中 这是一个

00:29:27.496 --> 00:29:29.596 A:middle
文本字段 中间

00:29:29.596 --> 00:29:30.526 A:middle
是函数防抖

00:29:30.856 --> 00:29:32.396 A:middle
如果用户打字很快

00:29:33.436 --> 00:29:34.646 A:middle
你就会看到 信号发送很快

00:29:35.566 --> 00:29:36.616 A:middle
但我们可以使信号发送平滑

00:29:36.616 --> 00:29:38.136 A:middle
在窗口中只传递一个信号

00:29:41.096 --> 00:29:42.456 A:middle
这很好 但我们还能

00:29:42.456 --> 00:29:43.416 A:middle
做得更好

00:29:45.026 --> 00:29:46.286 A:middle
如果用户在窗口中打字

00:29:46.286 --> 00:29:48.516 A:middle
而值最终

00:29:48.516 --> 00:29:49.576 A:middle
一直都是相同的

00:29:49.576 --> 00:29:50.606 A:middle
就没有理由再

00:29:50.606 --> 00:29:51.546 A:middle
呼叫服务器

00:29:51.546 --> 00:29:53.116 A:middle
看用户名是否有效

00:29:53.116 --> 00:29:55.786 A:middle
所以 如果用户输入 Merlin

00:29:55.786 --> 00:29:58.806 A:middle
我们会获取值 如果删除最后的 n

00:29:58.806 --> 00:30:00.726 A:middle
再输入 n 就又成了 Merlin

00:30:00.726 --> 00:30:01.626 A:middle
但我们也不用再次

00:30:01.626 --> 00:30:02.206 A:middle
呼叫服务器

00:30:02.836 --> 00:30:04.276 A:middle
removeDuplicates 操作符就是

00:30:04.276 --> 00:30:04.536 A:middle
实现这个的

00:30:05.206 --> 00:30:06.356 A:middle
它可以确保我们不用

00:30:06.356 --> 00:30:07.746 A:middle
在窗口内一遍

00:30:07.746 --> 00:30:11.296 A:middle
又一遍地发布同一个值

00:30:11.426 --> 00:30:12.986 A:middle
再来看代码 我们给

00:30:12.986 --> 00:30:14.656 A:middle
用户名属性添加了

00:30:14.656 --> 00:30:15.236 A:middle
Published

00:30:15.816 --> 00:30:18.126 A:middle
之后我们使用函数防抖

00:30:18.126 --> 00:30:19.206 A:middle
消除信号传输抖动

00:30:20.546 --> 00:30:22.176 A:middle
最后 我们移除了重复项

00:30:22.706 --> 00:30:25.506 A:middle
但我们还没有处理完

00:30:25.506 --> 00:30:26.586 A:middle
异步操作

00:30:26.586 --> 00:30:27.756 A:middle
我们刚刚平滑了信号

00:30:28.656 --> 00:30:29.646 A:middle
我们真正想要的是

00:30:29.646 --> 00:30:30.586 A:middle
查询服务器 看看

00:30:30.586 --> 00:30:31.566 A:middle
用户名是否有效

00:30:32.136 --> 00:30:34.546 A:middle
我们的 App 中

00:30:34.546 --> 00:30:35.786 A:middle
已经有了一个函数

00:30:35.886 --> 00:30:37.026 A:middle
叫做 usernameAvailable

00:30:38.106 --> 00:30:39.726 A:middle
接下来 我要将它作为

00:30:39.726 --> 00:30:40.916 A:middle
发布者引入

00:30:42.346 --> 00:30:44.226 A:middle
从 Michael 的例子中 我们

00:30:44.226 --> 00:30:45.496 A:middle
了解到 flatMap 能让你

00:30:45.496 --> 00:30:47.336 A:middle
从流中获取值

00:30:47.536 --> 00:30:48.836 A:middle
并返回新的发布者

00:30:49.416 --> 00:30:52.466 A:middle
我们该如何调用它呢

00:30:53.696 --> 00:30:55.296 A:middle
为此 我们有一个叫

00:30:55.296 --> 00:30:58.026 A:middle
Future 的东西 当你

00:30:58.026 --> 00:30:58.966 A:middle
构造的时候 你为它提供一个

00:30:58.966 --> 00:31:00.256 A:middle
闭包 其中包括一个 promise

00:31:01.006 --> 00:31:02.266 A:middle
promise 就是一个

00:31:02.266 --> 00:31:04.046 A:middle
闭包 其中包含结果

00:31:04.046 --> 00:31:05.936 A:middle
可能是成功或失败

00:31:09.046 --> 00:31:10.686 A:middle
它的使用非常直观

00:31:11.666 --> 00:31:13.466 A:middle
我们调用 usernameAvailable 函数

00:31:13.466 --> 00:31:14.916 A:middle
当它异步完成 我们

00:31:14.916 --> 00:31:17.026 A:middle
获得值之后 我们在

00:31:17.026 --> 00:31:18.996 A:middle
promise 中填充结果 这个例子里是 success

00:31:19.506 --> 00:31:21.006 A:middle
和之前一样 我们表明

00:31:21.006 --> 00:31:22.946 A:middle
如果不可用 结果是 nil

00:31:26.056 --> 00:31:28.146 A:middle
我们来回顾一下步骤 最初

00:31:28.146 --> 00:31:29.126 A:middle
我们有一个很简单的发布者

00:31:29.126 --> 00:31:31.136 A:middle
也就是用户名发布者

00:31:31.536 --> 00:31:32.466 A:middle
我们采用函数防抖

00:31:32.466 --> 00:31:34.286 A:middle
平滑信号 并移除了

00:31:34.286 --> 00:31:35.936 A:middle
窗口中的全部重复项

00:31:37.346 --> 00:31:39.236 A:middle
之后 我们使用 Future 包装

00:31:39.236 --> 00:31:41.006 A:middle
现有 API 来构造

00:31:41.006 --> 00:31:42.176 A:middle
异步网络调用

00:31:42.176 --> 00:31:45.426 A:middle
我们使用了 flatMap 来

00:31:45.426 --> 00:31:46.376 A:middle
构造流分支

00:31:47.846 --> 00:31:49.556 A:middle
之后 我们将它添加至任一

00:31:49.556 --> 00:31:51.196 A:middle
发布者因为它是 API 边界

00:31:52.076 --> 00:31:53.276 A:middle
现在我们就创造了

00:31:53.276 --> 00:31:54.696 A:middle
两个自定义发布者

00:31:54.696 --> 00:31:57.066 A:middle
分别是 validatedPassword 和

00:31:57.066 --> 00:31:58.036 A:middle
validatedUsername

00:31:58.576 --> 00:32:01.566 A:middle
接下来我们要组合它们

00:32:06.046 --> 00:32:07.086 A:middle
现在 我们要做的是

00:32:07.086 --> 00:32:08.436 A:middle
利用两个信号 一个是

00:32:08.436 --> 00:32:10.326 A:middle
设备本地信号

00:32:10.326 --> 00:32:11.406 A:middle
另一个是异步

00:32:11.406 --> 00:32:13.496 A:middle
网络调用 并使用它们

00:32:13.496 --> 00:32:14.536 A:middle
启用或禁用 UI

00:32:14.536 --> 00:32:16.876 A:middle
我们已经知道该怎么做了

00:32:18.276 --> 00:32:19.896 A:middle
我们使用 CombineLatest 操作符

00:32:20.386 --> 00:32:21.726 A:middle
我们要获取之前

00:32:21.726 --> 00:32:22.476 A:middle
创造的两个发布者

00:32:23.836 --> 00:32:24.796 A:middle
我们要检查它们是否可用

00:32:25.696 --> 00:32:26.886 A:middle
这个例子中 我们只

00:32:26.886 --> 00:32:29.026 A:middle
返回一个元组 其中以可选

00:32:29.026 --> 00:32:32.956 A:middle
包含全部证书 如果没有 则返回 nil

00:32:36.166 --> 00:32:37.236 A:middle
将这些与你的 UI

00:32:37.236 --> 00:32:38.436 A:middle
连接起来其实非常简单

00:32:39.636 --> 00:32:41.266 A:middle
我们为登录按钮编写一个

00:32:41.836 --> 00:32:43.496 A:middle
输出口

00:32:43.656 --> 00:32:46.666 A:middle
我们创建一个实例变量来储存

00:32:46.666 --> 00:32:48.416 A:middle
这个订阅 这样我们

00:32:48.416 --> 00:32:49.796 A:middle
就能在这个视图控制器的

00:32:49.846 --> 00:32:50.746 A:middle
全生命周期保留它

00:32:51.056 --> 00:32:52.036 A:middle
因为我们想要

00:32:52.036 --> 00:32:53.856 A:middle
在展示表单的全过程中

00:32:53.856 --> 00:32:54.706 A:middle
启用或禁用这个按钮

00:32:57.056 --> 00:32:57.746 A:middle
所以我们就存储它

00:32:58.546 --> 00:32:59.966 A:middle
我们将它映射到一个布尔值

00:33:02.216 --> 00:33:03.756 A:middle
赋值给按钮的 isEnabled 属性

00:33:06.156 --> 00:33:08.076 A:middle
最后 我们使用 receive(on:)

00:33:08.076 --> 00:33:09.006 A:middle
来切换到主线程

00:33:09.006 --> 00:33:10.206 A:middle
这是我们需要对

00:33:10.206 --> 00:33:11.296 A:middle
任何 UI 代码做的

00:33:11.296 --> 00:33:13.716 A:middle
之后 我们使用 assign

00:33:13.716 --> 00:33:15.146 A:middle
操作符 将它赋值给

00:33:15.146 --> 00:33:16.766 A:middle
给定关键路径的

00:33:16.766 --> 00:33:22.486 A:middle
signupButton 很了不起

00:33:22.486 --> 00:33:23.976 A:middle
我们有了一切需要的东西

00:33:26.046 --> 00:33:26.906 A:middle
总体来看 我们最初只有

00:33:26.906 --> 00:33:28.246 A:middle
三个非常简单的发布者

00:33:28.246 --> 00:33:30.746 A:middle
它们只能发布字符串

00:33:33.086 --> 00:33:35.386 A:middle
之后 我们使用组合

00:33:35.386 --> 00:33:37.036 A:middle
不断采取小改动

00:33:37.036 --> 00:33:38.706 A:middle
组建起了这些 创建了

00:33:38.706 --> 00:33:40.696 A:middle
最终的链条 之后

00:33:40.696 --> 00:33:42.446 A:middle
我们将它们组合起来 将它们赋值给按钮

00:33:43.456 --> 00:33:44.976 A:middle
这就是 Combine 的意义所在

00:33:48.076 --> 00:33:49.956 A:middle
所以 我建议大家马上上手

00:33:50.296 --> 00:33:52.576 A:middle
将你 App 的小部分

00:33:52.576 --> 00:33:53.606 A:middle
组合成自定义

00:33:53.606 --> 00:33:55.046 A:middle
发布者 找出

00:33:55.046 --> 00:33:56.526 A:middle
可以拆分成小型

00:33:56.576 --> 00:33:58.416 A:middle
发布者的小块逻辑 然后

00:33:58.416 --> 00:34:00.026 A:middle
不断使用组合 将它们

00:34:00.196 --> 00:34:01.836 A:middle
全部连接起来

00:34:02.656 --> 00:34:04.046 A:middle
你完全可以逐渐采用

00:34:04.046 --> 00:34:05.266 A:middle
你不需要马上

00:34:05.266 --> 00:34:07.276 A:middle
改变所有东西

00:34:07.276 --> 00:34:08.306 A:middle
可以有所选择

00:34:08.306 --> 00:34:09.346 A:middle
我们认为 你可以使用 Future

00:34:09.346 --> 00:34:14.085 A:middle
实现现在已有的功能

00:34:14.266 --> 00:34:15.596 A:middle
你可以使用 Future

00:34:15.596 --> 00:34:17.226 A:middle
组合回调和其他内容 如我们刚才所见

00:34:20.146 --> 00:34:21.676 A:middle
欲知更多信息 请观看

00:34:21.676 --> 00:34:24.176 A:middle
我们的介绍 Combine 会议

00:34:24.176 --> 00:34:26.456 A:middle
以及 SwiftUI 的数据流会议

00:34:26.456 --> 00:34:27.656 A:middle
今天晚些时候 我们 

00:34:27.656 --> 00:34:29.966 A:middle
也会在 AppKit 实验室 谢谢大家

00:34:30.516 --> 00:34:36.500 A:middle
[掌声]

