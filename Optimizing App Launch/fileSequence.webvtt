WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:00.506 --> 00:00:04.500 A:middle
[音乐]

00:00:07.516 --> 00:00:13.046 A:middle
[掌声]

00:00:13.546 --> 00:00:16.216 A:middle
&gt;&gt; 大家好 我是 Spencer Lewson

00:00:16.216 --> 00:00:17.876 A:middle
我是 Apple 公司 Performance Team 

00:00:18.046 --> 00:00:18.566 A:middle
的一名工程师

00:00:19.446 --> 00:00:21.116 A:middle
今天我很高兴告诉你们

00:00:21.116 --> 00:00:23.786 A:middle
如何优化你们 App 的启动

00:00:24.336 --> 00:00:27.196 A:middle
我们今天将讨论

00:00:27.196 --> 00:00:28.006 A:middle
这四个主要议题

00:00:28.746 --> 00:00:30.686 A:middle
首先 什么是启动

00:00:31.256 --> 00:00:32.076 A:middle
不同类型的启动有哪些

00:00:32.076 --> 00:00:33.516 A:middle
以及我们如何

00:00:33.516 --> 00:00:35.486 A:middle
将它们分解为不同的子阶段

00:00:36.576 --> 00:00:37.906 A:middle
接下来 我们将讨论

00:00:37.906 --> 00:00:39.626 A:middle
如何正确估测你们 App 的启动

00:00:40.646 --> 00:00:42.356 A:middle
生活中 iOS 设备

00:00:42.356 --> 00:00:43.366 A:middle
可能处于各种不同的

00:00:43.436 --> 00:00:46.226 A:middle
状态和情况 并且这些

00:00:46.226 --> 00:00:48.126 A:middle
状态和条件可能

00:00:48.126 --> 00:00:49.886 A:middle
产生不一致的启动结果

00:00:50.566 --> 00:00:51.656 A:middle
因此 了解这些状态

00:00:51.656 --> 00:00:53.136 A:middle
以及如何在进行测量时

00:00:53.176 --> 00:00:54.596 A:middle
减少其影响非常重要

00:00:55.266 --> 00:00:58.826 A:middle
在这时候

00:00:58.826 --> 00:00:59.866 A:middle
你们可以查看如何使用

00:01:02.106 --> 00:01:03.476 A:middle
你们的 App 以找到

00:01:03.476 --> 00:01:04.806 A:middle
改进它的机会

00:01:06.026 --> 00:01:07.296 A:middle
最后 我们将为你们提供

00:01:07.346 --> 00:01:09.406 A:middle
有关如何监控 App 启动的

00:01:09.406 --> 00:01:10.616 A:middle
一些可持续且适用于实战的

00:01:10.976 --> 00:01:12.856 A:middle
提示和技巧

00:01:13.316 --> 00:01:14.806 A:middle
以确保你们始终为

00:01:14.806 --> 00:01:17.866 A:middle
所有用户提供愉快的体验

00:01:17.866 --> 00:01:21.356 A:middle
那么 我正在谈论的

00:01:21.616 --> 00:01:22.466 A:middle
App 启动是什么

00:01:23.226 --> 00:01:26.626 A:middle
其实 App 启动是用户体验的中断

00:01:27.966 --> 00:01:28.996 A:middle
这是什么意思呢

00:01:29.536 --> 00:01:30.076 A:middle
让我们来看看

00:01:31.126 --> 00:01:34.136 A:middle
好的 准备 开始

00:01:38.186 --> 00:01:40.546 A:middle
哇 在这台 iPhone 6S Plus 上

00:01:41.176 --> 00:01:43.366 A:middle
启动时间差不多 2.5 秒

00:01:44.176 --> 00:01:45.736 A:middle
这并不像我们用户期望的

00:01:45.736 --> 00:01:46.946 A:middle
那样令人愉快

00:01:48.326 --> 00:01:49.736 A:middle
你们知道 令人愉悦的启动

00:01:49.736 --> 00:01:50.676 A:middle
是非常重要的

00:01:51.326 --> 00:01:52.396 A:middle
因为它经常发生

00:01:53.276 --> 00:01:55.746 A:middle
事实上 在所有 iOS 设备中

00:01:56.316 --> 00:01:58.436 A:middle
它每天都会发生数十亿次

00:01:59.666 --> 00:02:00.336 A:middle
所以 我们做了一些

00:02:00.336 --> 00:02:02.286 A:middle
简单计算 发现

00:02:02.286 --> 00:02:03.916 A:middle
如果每次启动时我们

00:02:03.916 --> 00:02:05.476 A:middle
节省一毫秒

00:02:05.476 --> 00:02:07.586 A:middle
我们将节省共惊人的

00:02:07.586 --> 00:02:12.186 A:middle
162 天启动时间

00:02:13.196 --> 00:02:15.026 A:middle
是的 换句话说

00:02:16.506 --> 00:02:18.236 A:middle
[掌声] 谢谢你们

00:02:18.236 --> 00:02:19.916 A:middle
换句话说 这就是将火箭

00:02:19.916 --> 00:02:22.886 A:middle
发送到火星所需的时间

00:02:23.626 --> 00:02:26.246 A:middle
但由于其他一些原因 

00:02:26.246 --> 00:02:27.236 A:middle
这同样很重要

00:02:27.926 --> 00:02:31.626 A:middle
首先 你们 App 的启动是

00:02:31.706 --> 00:02:33.176 A:middle
你们用户对你们 App

00:02:33.176 --> 00:02:35.216 A:middle
的第一印象 

00:02:35.216 --> 00:02:35.946 A:middle
因此它应该是愉悦的

00:02:37.236 --> 00:02:38.646 A:middle
现在重要的是要记住

00:02:38.646 --> 00:02:40.326 A:middle
作为开发者

00:02:40.326 --> 00:02:41.796 A:middle
我们倾向于被更新的设备吸引

00:02:42.706 --> 00:02:43.766 A:middle
因此 重要的是要确保

00:02:43.906 --> 00:02:45.126 A:middle
你们在眼前

00:02:45.126 --> 00:02:46.876 A:middle
看到的体验与

00:02:46.876 --> 00:02:48.146 A:middle
你们的用户

00:02:48.626 --> 00:02:50.386 A:middle
在不同 iOS 设备

00:02:50.386 --> 00:02:52.506 A:middle
和不同条件下拥有的

00:02:53.016 --> 00:02:55.606 A:middle
用户体验相同

00:02:57.356 --> 00:02:59.726 A:middle
此外 启动涵盖了

00:02:59.726 --> 00:03:01.026 A:middle
你们代码库的很大一部分

00:03:01.716 --> 00:03:02.736 A:middle
从底层加工到初始化

00:03:02.736 --> 00:03:05.646 A:middle
再到视图创建等等

00:03:06.316 --> 00:03:08.076 A:middle
因此 如果你们发现

00:03:08.076 --> 00:03:09.976 A:middle
你们的启动并不像

00:03:10.196 --> 00:03:11.546 A:middle
用户期望的那样愉悦

00:03:12.226 --> 00:03:13.436 A:middle
那么这也可能表明

00:03:13.436 --> 00:03:14.496 A:middle
你们的代码库的

00:03:14.496 --> 00:03:17.896 A:middle
其他部分也并不那么令人愉悦

00:03:18.066 --> 00:03:19.686 A:middle
最后 启动是一个对于手机是

00:03:19.686 --> 00:03:20.726 A:middle
非常紧张的时间

00:03:21.456 --> 00:03:23.326 A:middle
会涉及大量 CPU 工作和

00:03:23.326 --> 00:03:24.046 A:middle
大量内存工作

00:03:24.956 --> 00:03:25.846 A:middle
因此 你们应该尝试减缓它

00:03:25.906 --> 00:03:27.486 A:middle
因为它会影响系统性能

00:03:27.486 --> 00:03:30.306 A:middle
当然还有你们用户的电池寿命

00:03:30.736 --> 00:03:33.496 A:middle
那么 让我们来看看

00:03:33.696 --> 00:03:34.886 A:middle
我之前谈过的那些启动

00:03:35.386 --> 00:03:40.386 A:middle
有冷启动 暖启动

00:03:40.696 --> 00:03:42.056 A:middle
继续运行通常被称为启动 

00:03:42.056 --> 00:03:43.216 A:middle
但其实它不是一个启动

00:03:45.616 --> 00:03:47.166 A:middle
重启后或你们的 App 

00:03:47.166 --> 00:03:49.316 A:middle
很长时间未启动时

00:03:49.316 --> 00:03:50.666 A:middle
会发生冷启动

00:03:52.116 --> 00:03:54.106 A:middle
为了启动 App

00:03:54.106 --> 00:03:57.666 A:middle
我们需要将它从磁盘带入内存

00:03:57.666 --> 00:03:58.906 A:middle
启动支持你们 App 的系统端服务

00:03:58.906 --> 00:04:00.816 A:middle
然后生成你们的进程

00:04:02.266 --> 00:04:03.616 A:middle
正如你们所预料的那样

00:04:03.616 --> 00:04:05.886 A:middle
这可能需要一点时间

00:04:05.916 --> 00:04:07.546 A:middle
但幸运的是

00:04:07.546 --> 00:04:09.006 A:middle
一旦发生一次 你们都将体验到暖启动

00:04:09.576 --> 00:04:12.496 A:middle
在这种情况下 你们的 App 仍然

00:04:12.496 --> 00:04:14.516 A:middle
需要被唤醒

00:04:14.516 --> 00:04:15.916 A:middle
但我们已经将你们的 App 

00:04:15.916 --> 00:04:17.565 A:middle
带入内存并启动了

00:04:17.565 --> 00:04:18.896 A:middle
那些系统端服务

00:04:19.426 --> 00:04:20.255 A:middle
所以 这会更快一点

00:04:20.255 --> 00:04:22.036 A:middle
也会更一致

00:04:23.676 --> 00:04:25.206 A:middle
最后 还要说说继续运行

00:04:26.256 --> 00:04:28.536 A:middle
当用户从主屏幕

00:04:28.536 --> 00:04:30.066 A:middle
或 App 切换器重新进入你们的 App 时

00:04:30.066 --> 00:04:31.306 A:middle
会发生这种情况

00:04:32.336 --> 00:04:33.926 A:middle
如你们所知

00:04:33.926 --> 00:04:35.546 A:middle
该 App 在此时已经启动

00:04:35.546 --> 00:04:36.786 A:middle
因此速度非常快

00:04:38.146 --> 00:04:39.066 A:middle
你们需要记住的是

00:04:39.066 --> 00:04:41.256 A:middle
在进行估量时 

00:04:41.396 --> 00:04:43.116 A:middle
不要将继续运行与启动混淆

00:04:43.906 --> 00:04:46.436 A:middle
所以 鉴于这些信息

00:04:46.936 --> 00:04:49.986 A:middle
如果启动与继续运行一样快速

00:04:50.696 --> 00:04:56.006 A:middle
和令人愉悦

00:04:56.516 --> 00:04:57.096 A:middle
那不是很棒吗

00:04:57.826 --> 00:05:00.676 A:middle
我们怎样才能做到这一点

00:05:02.036 --> 00:05:04.146 A:middle
好吧 我们需要达到

00:05:04.146 --> 00:05:05.486 A:middle
在 400 毫秒内渲染

00:05:05.626 --> 00:05:06.906 A:middle
第一帧的目标

00:05:08.066 --> 00:05:09.266 A:middle
这样我们就可以在

00:05:09.266 --> 00:05:10.866 A:middle
启动动画期间

00:05:10.866 --> 00:05:13.116 A:middle
向用户显示像素

00:05:13.116 --> 00:05:14.136 A:middle
并且在启动动画完成时

00:05:14.136 --> 00:05:15.796 A:middle
你们的 App 就具有

00:05:15.796 --> 00:05:17.506 A:middle
交互性和响应性

00:05:18.096 --> 00:05:20.346 A:middle
这样做的第一步是

00:05:20.346 --> 00:05:22.296 A:middle
了解启动期间发生的情况

00:05:22.866 --> 00:05:24.666 A:middle
那么 让我们启动《地图》

00:05:26.496 --> 00:05:28.126 A:middle
如你们所知 

00:05:28.126 --> 00:05:29.606 A:middle
启动通常发生在用户点按

00:05:29.606 --> 00:05:32.236 A:middle
主屏幕上你们的图标时

00:05:32.406 --> 00:05:34.316 A:middle
然后在接下来的 100 毫秒左右内

00:05:34.316 --> 00:05:36.136 A:middle
iOS 将执行必要的

00:05:36.136 --> 00:05:37.916 A:middle
系统端工作以

00:05:37.916 --> 00:05:39.746 A:middle
初始化你们的 App

00:05:40.456 --> 00:05:42.386 A:middle
这给了你们开发者有

00:05:42.786 --> 00:05:46.846 A:middle
大约 300 毫秒来创建视图加载内容

00:05:46.846 --> 00:05:48.206 A:middle
并生成第一帧

00:05:49.716 --> 00:05:51.506 A:middle
现在这个帧不一定

00:05:51.506 --> 00:05:53.316 A:middle
需要完全完成

00:05:53.316 --> 00:05:55.056 A:middle
它可以有一些占位符

00:05:55.226 --> 00:05:58.996 A:middle
用于异步加载数据

00:05:58.996 --> 00:06:00.706 A:middle
但此时你们的 App 应该是

00:06:00.706 --> 00:06:01.356 A:middle
可交互 且有响应的

00:06:02.536 --> 00:06:04.936 A:middle
因此 在这个 Maps 的例子中 

00:06:04.936 --> 00:06:06.106 A:middle
所有视窗尚未加载

00:06:06.526 --> 00:06:07.586 A:middle
你们仍然可以启动搜索

00:06:07.586 --> 00:06:10.086 A:middle
并浏览收藏夹

00:06:10.656 --> 00:06:13.786 A:middle
然后在接下来的几百毫秒内

00:06:13.786 --> 00:06:15.006 A:middle
你们可以显示异步加载的

00:06:15.006 --> 00:06:16.636 A:middle
数据并为你们的用户

00:06:16.636 --> 00:06:17.646 A:middle
生成最终帧

00:06:18.636 --> 00:06:19.976 A:middle
让我们仔细看看这些阶段

00:06:24.156 --> 00:06:25.316 A:middle
这六个阶段涵盖所有内容

00:06:25.316 --> 00:06:28.676 A:middle
从系统初始化到 App 初始化

00:06:28.676 --> 00:06:32.716 A:middle
再到视图创建和布局

00:06:32.716 --> 00:06:34.576 A:middle
如果你们的 App 有需要的

00:06:34.576 --> 00:06:36.736 A:middle
还可能有一个扩展阶段

00:06:37.036 --> 00:06:37.976 A:middle
用于数据的异步加载

00:06:42.086 --> 00:06:44.666 A:middle
系统界面的前半部分是 DYLD3

00:06:44.726 --> 00:06:47.476 A:middle
对于你们中那些不熟悉的人

00:06:47.476 --> 00:06:49.356 A:middle
动态链接器会加载

00:06:49.356 --> 00:06:50.536 A:middle
你们的共享库和框架

00:06:52.156 --> 00:06:56.256 A:middle
在 2017 年 我们引入了 DYLD3

00:06:56.296 --> 00:06:58.636 A:middle
它为系统增加了

00:06:58.636 --> 00:07:00.026 A:middle
令人兴奋的优化

00:07:01.096 --> 00:07:02.026 A:middle
好吧 我们很高兴地宣布

00:07:02.026 --> 00:07:03.906 A:middle
在 iOS 13 中 我们会为

00:07:03.906 --> 00:07:05.966 A:middle
你们的 App 带来这些优化

00:07:07.176 --> 00:07:08.726 A:middle
这意味着我们现在会为热启动

00:07:08.726 --> 00:07:10.166 A:middle
缓存运行时依赖项

00:07:10.166 --> 00:07:13.486 A:middle
这应该会给它们带来显著的速度提升 [掌声]

00:07:13.956 --> 00:07:15.446 A:middle
谢谢你们

00:07:21.066 --> 00:07:22.566 A:middle
现在有了一个新的链接器

00:07:22.566 --> 00:07:23.606 A:middle
我们提出了一些新的建议

00:07:24.846 --> 00:07:26.126 A:middle
为了充分利用这些新的改进

00:07:26.126 --> 00:07:28.606 A:middle
我们建议你们

00:07:28.606 --> 00:07:30.276 A:middle
避免链接未使用的框架

00:07:30.276 --> 00:07:32.786 A:middle
因为这可能会产生潜在成本

00:07:32.786 --> 00:07:33.136 A:middle
我们稍后会向你们展示

00:07:34.646 --> 00:07:37.186 A:middle
我们还建议你们

00:07:37.186 --> 00:07:39.236 A:middle
避免动态库加载

00:07:39.236 --> 00:07:42.086 A:middle
例如 dlopen() 或 NSBundle 中的 load()

00:07:42.166 --> 00:07:43.666 A:middle
因为这会损失你们

00:07:43.666 --> 00:07:46.516 A:middle
在缓存中建立的那些优势

00:07:47.816 --> 00:07:49.216 A:middle
最后 这意味着

00:07:49.216 --> 00:07:51.386 A:middle
你们应该硬链接

00:07:51.386 --> 00:07:52.786 A:middle
所有依赖项

00:07:52.916 --> 00:07:54.676 A:middle
因为它现在甚至比以前更快

00:07:57.456 --> 00:07:58.886 A:middle
系统接口的后半部分

00:07:58.886 --> 00:08:00.476 A:middle
是 libSystem Init

00:08:01.616 --> 00:08:02.716 A:middle
这是我们在 App 中

00:08:02.716 --> 00:08:05.336 A:middle
初始化底层系统组件的时候

00:08:06.436 --> 00:08:08.106 A:middle
现在这主要是系统方面的工作

00:08:08.106 --> 00:08:09.556 A:middle
有固定成本

00:08:10.336 --> 00:08:11.976 A:middle
因此 开发者不需要关注该部分

00:08:15.106 --> 00:08:16.956 A:middle
接下来是静态运行时初始化

00:08:18.496 --> 00:08:19.406 A:middle
这在系统初始化

00:08:19.406 --> 00:08:21.386 A:middle
Objective-C 和 Swift 

00:08:21.386 --> 00:08:22.136 A:middle
运行次数时会出现

00:08:23.666 --> 00:08:25.006 A:middle
一般来说

00:08:25.006 --> 00:08:26.136 A:middle
你们的 App 不应该在这里做任何工作

00:08:26.706 --> 00:08:29.416 A:middle
除非你有可能存在于代码中的

00:08:29.416 --> 00:08:30.816 A:middle
静态初始化方法

00:08:31.436 --> 00:08:33.446 A:middle
或者更可能是你链接的

00:08:33.446 --> 00:08:35.246 A:middle
框架带来的“惊喜”

00:08:36.056 --> 00:08:38.626 A:middle
通常 我们不建议静态初始化

00:08:38.626 --> 00:08:40.395 A:middle
所以 让我们花点时间谈谈

00:08:40.395 --> 00:08:42.186 A:middle
如何减少其影响

00:08:43.376 --> 00:08:45.016 A:middle
如果你们拥有一个

00:08:45.016 --> 00:08:46.336 A:middle
使用静态初始化的框架

00:08:46.686 --> 00:08:48.916 A:middle
你们要考虑暴露 API 以

00:08:48.916 --> 00:08:50.076 A:middle
尽早初始化你们的栈

00:08:50.716 --> 00:08:52.636 A:middle
但是如果必须使用静态初始化

00:08:52.636 --> 00:08:56.966 A:middle
请考虑将代码移出 +[Class load]

00:08:56.966 --> 00:08:59.366 A:middle
它在 App 启动期间

00:09:01.906 --> 00:09:03.646 A:middle
就在你在类中第一次使用方法的时候

00:09:03.646 --> 00:09:08.066 A:middle
被懒调用

00:09:08.246 --> 00:09:09.946 A:middle
接下来是 UIKit 初始化

00:09:11.266 --> 00:09:12.156 A:middle
这就是系统实例化

00:09:12.186 --> 00:09:13.896 A:middle
你们的 UIApplication 

00:09:13.896 --> 00:09:15.896 A:middle
和 UIApplicationDelegate 的时候

00:09:16.566 --> 00:09:18.646 A:middle
在大多数情况下

00:09:18.646 --> 00:09:20.036 A:middle
这是系统方面的工作

00:09:20.036 --> 00:09:21.606 A:middle
设置事件处理

00:09:21.606 --> 00:09:22.206 A:middle
和与系统的集成

00:09:23.256 --> 00:09:24.226 A:middle
但是你们其实仍然

00:09:24.226 --> 00:09:26.996 A:middle
可以影响此阶段

00:09:26.996 --> 00:09:29.876 A:middle
如果你们在子类 UIApplication

00:09:30.056 --> 00:09:31.926 A:middle
或者在 UIApplicationDelegate

00:09:32.646 --> 00:09:35.746 A:middle
初始化程序中做任何工作

00:09:35.746 --> 00:09:36.516 A:middle
现在我们看看 App 初始化

00:09:37.436 --> 00:09:38.476 A:middle
最重要的东西都在这里

00:09:38.896 --> 00:09:40.136 A:middle
这是作为开发者

00:09:40.136 --> 00:09:40.996 A:middle
可能在你们 App 启动时

00:09:40.996 --> 00:09:42.706 A:middle
初始化程序中做任何工作地方

00:09:43.246 --> 00:09:45.586 A:middle
对于你们之中尚未采用

00:09:45.586 --> 00:09:47.826 A:middle
UIScene API 或针对 iOS 12 

00:09:49.146 --> 00:09:50.326 A:middle
或更早版本的用户的人来说

00:09:50.326 --> 00:09:53.356 A:middle
App 初始化

00:09:54.116 --> 00:09:55.766 A:middle
仍然可以用这些

00:09:55.766 --> 00:09:56.426 A:middle
代理回调方法

00:09:57.186 --> 00:09:57.736 A:middle
application:willFinishLaunchingwithOptions

00:09:57.736 --> 00:10:01.216 A:middle
和 application:didFinishLaunchingwithOptions

00:10:01.956 --> 00:10:04.196 A:middle
当你们的 App 显示给用户时

00:10:04.196 --> 00:10:06.286 A:middle
applicationDidBecomeActive 这个方法

00:10:07.006 --> 00:10:09.036 A:middle
会被进一步调用

00:10:10.176 --> 00:10:11.356 A:middle
现在重要的是要知道

00:10:11.356 --> 00:10:13.316 A:middle
如果你没有采用 UIScene API

00:10:13.316 --> 00:10:14.116 A:middle
你应该创建视图控制器

00:10:14.116 --> 00:10:16.546 A:middle
和 didFinishLaunchingwithOptions

00:10:17.686 --> 00:10:19.276 A:middle
这是因为使用 UIScene 时

00:10:19.666 --> 00:10:23.216 A:middle
App 初始化的工作方式略有不同

00:10:23.216 --> 00:10:24.276 A:middle
现在你仍然可以获得

00:10:24.276 --> 00:10:25.456 A:middle
willFinishLaunching 和

00:10:25.456 --> 00:10:26.726 A:middle
didFinishLaunchingwithOptions

00:10:27.546 --> 00:10:28.736 A:middle
但是当你们的 App 显示给用户时

00:10:28.736 --> 00:10:30.126 A:middle
你们将获得

00:10:30.126 --> 00:10:32.836 A:middle
UISceneDelegate 生命周期回调

00:10:34.116 --> 00:10:35.986 A:middle
当然就是带有选项的

00:10:35.986 --> 00:10:36.426 A:middle
scene:willConnectToSession

00:10:36.846 --> 00:10:38.586 A:middle
sceneWillEnterForeground 和

00:10:38.586 --> 00:10:39.446 A:middle
sceneDidBecomeActive

00:10:40.106 --> 00:10:41.666 A:middle
你们应该创建视图控制器

00:10:41.666 --> 00:10:43.446 A:middle
和带有选项的

00:10:43.446 --> 00:10:44.866 A:middle
scene:willConnectToSession

00:10:46.266 --> 00:10:48.016 A:middle
重要的是要注意 

00:10:48.016 --> 00:10:49.206 A:middle
你们应该只创建

00:10:49.206 --> 00:10:50.256 A:middle
视图控制器和带有选项的

00:10:50.256 --> 00:10:51.406 A:middle
scene:willConnectToSession

00:10:51.666 --> 00:10:52.836 A:middle
以及带有选项的

00:10:52.836 --> 00:10:53.956 A:middle
didFinishLaunching

00:10:54.416 --> 00:10:55.956 A:middle
这是常见的陷阱

00:10:55.956 --> 00:10:59.176 A:middle
当然会导致性能损失

00:10:59.476 --> 00:11:01.826 A:middle
并且可能导致你们代码库中

00:11:04.316 --> 00:11:04.426 A:middle
出现不可预测的错误

00:11:04.636 --> 00:11:05.716 A:middle
无论你们是否

00:11:05.846 --> 00:11:07.256 A:middle
采用了新的 UIScene API

00:11:07.326 --> 00:11:09.196 A:middle
我们对此阶段的建议

00:11:09.196 --> 00:11:09.996 A:middle
通常都是相同的

00:11:09.996 --> 00:11:12.896 A:middle
你们应该推迟

00:11:12.896 --> 00:11:14.456 A:middle
任何不相关的工作

00:11:14.456 --> 00:11:15.926 A:middle
但是没有必要

00:11:15.926 --> 00:11:18.446 A:middle
提交你的第一帧

00:11:18.446 --> 00:11:20.846 A:middle
可以通过将其推送到后台队列

00:11:20.846 --> 00:11:22.346 A:middle
或者稍后再完全执行

00:11:25.096 --> 00:11:27.386 A:middle
如果你们确实采用了 UIScenes

00:11:27.386 --> 00:11:28.886 A:middle
那么你们可以再做一件事

00:11:28.886 --> 00:11:31.506 A:middle
那就是确保你们在场景之间共享资源

00:11:32.126 --> 00:11:33.486 A:middle
当然 这是为了减少

00:11:33.486 --> 00:11:35.456 A:middle
多次不必要地

00:11:35.456 --> 00:11:37.766 A:middle
进行一些工作的开销

00:11:38.696 --> 00:11:40.206 A:middle
要了解有关 UIScenes 的更多信息

00:11:40.636 --> 00:11:43.366 A:middle
那就是确保你们在场景之间这两个会议 

00:11:46.126 --> 00:11:47.456 A:middle
接下来是第一帧 渲染阶段

00:11:48.446 --> 00:11:50.066 A:middle
这是相对简单的

00:11:50.506 --> 00:11:51.776 A:middle
这是我们创建视图

00:11:51.776 --> 00:11:54.106 A:middle
执行布局 然后绘制它们的时候

00:11:55.236 --> 00:11:56.486 A:middle
然后我们获取该信息

00:11:56.956 --> 00:11:58.166 A:middle
并将你们的第一帧渲染

00:11:58.166 --> 00:11:59.956 A:middle
用漂亮的像素呈现出来

00:12:03.816 --> 00:12:05.876 A:middle
层次结构中的视图数

00:12:05.876 --> 00:12:06.406 A:middle
来影响此阶段

00:12:06.446 --> 00:12:08.466 A:middle
你们也可以通过

00:12:08.656 --> 00:12:09.946 A:middle
展平视图以减少使用

00:12:09.946 --> 00:12:13.156 A:middle
或延迟加载在启动期间

00:12:13.546 --> 00:12:15.026 A:middle
未显示的视图来实现

00:12:15.556 --> 00:12:18.946 A:middle
你们还应该查看自动布局

00:12:18.946 --> 00:12:19.966 A:middle
看看是否可以减少

00:12:19.966 --> 00:12:21.496 A:middle
正在使用的约束数量

00:12:23.516 --> 00:12:25.416 A:middle
最后 我们有一个扩展阶段

00:12:26.106 --> 00:12:27.776 A:middle
这是从你们第一次

00:12:27.896 --> 00:12:29.786 A:middle
提交到向用户显示

00:12:29.786 --> 00:12:31.976 A:middle
最终帧的 App 特定时间段

00:12:33.016 --> 00:12:34.146 A:middle
这是当你加载

00:12:34.146 --> 00:12:35.506 A:middle
我们谈到的异步数据时

00:12:36.316 --> 00:12:38.826 A:middle
其实不是每个 App 都有这个阶段

00:12:39.916 --> 00:12:41.546 A:middle
但如果你们确实有这个阶段

00:12:42.736 --> 00:12:44.876 A:middle
那么你们的 App 应该具有互动性和响应性

00:12:45.436 --> 00:12:47.936 A:middle
如果你们确实有这个阶段

00:12:47.936 --> 00:12:49.366 A:middle
我们只会就你应该如何处理

00:12:49.366 --> 00:12:50.956 A:middle
这个问题提供广泛性建议

00:12:50.956 --> 00:12:52.216 A:middle
那就是了解正在发生什么

00:12:52.216 --> 00:12:54.386 A:middle
并且你们可以通过

00:12:54.386 --> 00:12:56.626 A:middle
利用 os_signpost API 来标记和衡量

00:12:56.956 --> 00:13:00.336 A:middle
在这两个时期发生的工作

00:13:04.476 --> 00:13:05.956 A:middle
既然我们讨论了启动是什么

00:13:05.956 --> 00:13:08.886 A:middle
让我们谈谈如何获得可用的测量

00:13:11.556 --> 00:13:14.236 A:middle
在任何给定时间

00:13:14.236 --> 00:13:16.006 A:middle
iOS 设备都处于各种

00:13:16.006 --> 00:13:17.836 A:middle
不同的状态和情况下

00:13:17.836 --> 00:13:19.066 A:middle
这可能会在启动时

00:13:19.066 --> 00:13:20.226 A:middle
引入很大的差异

00:13:21.166 --> 00:13:22.506 A:middle
因此 当我们分析和

00:13:22.506 --> 00:13:24.356 A:middle
比较我们的启动结果时

00:13:24.846 --> 00:13:26.686 A:middle
确保我们进行“Apple-Apple”的

00:13:26.686 --> 00:13:27.896 A:middle
对比比较至关重要

00:13:27.896 --> 00:13:30.106 A:middle
因为如果在进行任何更改之前

00:13:30.106 --> 00:13:33.396 A:middle
你的启动结果完全不可预测

00:13:33.396 --> 00:13:35.146 A:middle
你们如何知道

00:13:35.146 --> 00:13:36.356 A:middle
自己是否取得了进展呢

00:13:36.896 --> 00:13:38.866 A:middle
使其可预测的第一步是

00:13:38.866 --> 00:13:40.546 A:middle
消除这些差异来源

00:13:40.546 --> 00:13:44.286 A:middle
例如网络干扰和

00:13:44.286 --> 00:13:45.816 A:middle
后台进程中的干扰

00:13:47.126 --> 00:13:48.526 A:middle
现在我们意识到

00:13:48.576 --> 00:13:50.366 A:middle
这听起来有悖常理

00:13:50.366 --> 00:13:51.836 A:middle
因为这可能会导致

00:13:51.836 --> 00:13:53.366 A:middle
启动不能完全

00:13:53.366 --> 00:13:55.506 A:middle
代表常规使用 但我们想让

00:13:55.506 --> 00:13:57.276 A:middle
你们知道这没关系

00:13:58.356 --> 00:13:59.456 A:middle
拥有一致的结果可以

00:13:59.566 --> 00:14:01.286 A:middle
使评估很好地进展

00:14:01.286 --> 00:14:02.416 A:middle
这一点尤为重要

00:14:03.216 --> 00:14:07.186 A:middle
在 Apple 我们一直在使用这种技术

00:14:07.276 --> 00:14:08.666 A:middle
在开发过程中成功检测回归

00:14:09.186 --> 00:14:10.326 A:middle
并缩短启动时间

00:14:11.106 --> 00:14:13.736 A:middle
然后 我们通过使用

00:14:14.016 --> 00:14:15.626 A:middle
在实际情况中收集的遥测数据

00:14:16.156 --> 00:14:17.406 A:middle
来验证这些性能改进

00:14:17.586 --> 00:14:18.816 A:middle
幸运的是 

00:14:18.816 --> 00:14:20.076 A:middle
我们提供了一些关于建立干净

00:14:20.076 --> 00:14:21.066 A:middle
和一致的环境的技巧

00:14:23.176 --> 00:14:25.146 A:middle
首先 重启你们的设备

00:14:26.046 --> 00:14:26.976 A:middle
这将清除任何

00:14:26.976 --> 00:14:28.616 A:middle
不必要的状态

00:14:28.616 --> 00:14:29.996 A:middle
然后让它在接下来的几分钟内

00:14:29.996 --> 00:14:31.506 A:middle
安定下来以清除

00:14:31.506 --> 00:14:31.956 A:middle
任何启动时间工作

00:14:34.256 --> 00:14:37.126 A:middle
你们还可以通过打开飞行模式

00:14:37.126 --> 00:14:38.486 A:middle
或在代码中标记

00:14:39.196 --> 00:14:40.306 A:middle
网络依赖性来

00:14:40.306 --> 00:14:41.446 A:middle
减少对网络的依赖

00:14:42.496 --> 00:14:45.156 A:middle
网络可以引入相当多的差异

00:14:45.926 --> 00:14:48.056 A:middle
接下来是 iCloud

00:14:49.176 --> 00:14:50.746 A:middle
iCloud 是一个很棒的功能

00:14:50.776 --> 00:14:51.926 A:middle
它可以在后台运行

00:14:51.926 --> 00:14:53.436 A:middle
为我们的用户提供无缝体验

00:14:53.436 --> 00:14:55.726 A:middle
但是在后台工作

00:14:55.726 --> 00:14:57.776 A:middle
会干扰 App 的启动

00:14:58.246 --> 00:14:59.236 A:middle
因此 在你们的测量过程中

00:15:04.446 --> 00:15:05.746 A:middle
或完全注销 iCloud

00:15:06.296 --> 00:15:12.456 A:middle
接下来一定要在进行测量时

00:15:12.456 --> 00:15:13.276 A:middle
使用 App 的发布构建版本

00:15:13.946 --> 00:15:19.306 A:middle
当然 这是为了减少测量期间

00:15:19.306 --> 00:15:22.796 A:middle
不必要的调试代码的开销

00:15:22.796 --> 00:15:24.946 A:middle
并利用编译时优化

00:15:26.276 --> 00:15:28.196 A:middle
最后 你们应该使用

00:15:28.246 --> 00:15:30.216 A:middle
热启动进行测量

00:15:30.216 --> 00:15:31.406 A:middle
如前所述

00:15:31.406 --> 00:15:33.216 A:middle
它们更加一致

00:15:33.216 --> 00:15:34.196 A:middle
因为你们的某些 App 可能已经在内存中

00:15:34.996 --> 00:15:35.946 A:middle
并且其中一些

00:15:35.946 --> 00:15:37.506 A:middle
系统端服务可能已在运行

00:15:37.536 --> 00:15:41.786 A:middle
现在我们可以设置

00:15:41.786 --> 00:15:42.196 A:middle
一些数据来测试

00:15:43.286 --> 00:15:44.716 A:middle
创建一致的模拟

00:15:44.806 --> 00:15:46.136 A:middle
数据集非常重要

00:15:46.136 --> 00:15:48.296 A:middle
你们可能需要

00:15:48.296 --> 00:15:49.366 A:middle
为不同类型的用户

00:15:49.366 --> 00:15:51.376 A:middle
提供一些数据集

00:15:51.376 --> 00:15:53.236 A:middle
例如具有少量数据的用户

00:15:53.336 --> 00:15:55.966 A:middle
和具有大量数据的用户

00:15:55.966 --> 00:15:58.406 A:middle
但在理想情况下

00:15:58.406 --> 00:15:59.906 A:middle
你们的 App 应该能够扩展到

00:15:59.906 --> 00:16:00.486 A:middle
任何数量的数据

00:16:01.546 --> 00:16:02.826 A:middle
这就是为什么

00:16:02.826 --> 00:16:04.066 A:middle
在显示第一帧时

00:16:04.066 --> 00:16:04.716 A:middle
只加载必要数据的原因

00:16:08.076 --> 00:16:09.526 A:middle
现在我们准备挑选一些设备了

00:16:10.656 --> 00:16:11.906 A:middle
你们应该选择

00:16:11.906 --> 00:16:13.126 A:middle
对用户重要的各种设备

00:16:13.126 --> 00:16:14.636 A:middle
然后坚持使用它们

00:16:14.636 --> 00:16:15.626 A:middle
强制一致性

00:16:16.876 --> 00:16:18.466 A:middle
请确保将最旧的

00:16:18.466 --> 00:16:19.416 A:middle
设备包含在

00:16:19.416 --> 00:16:20.686 A:middle
最早支持的版本中

00:16:21.436 --> 00:16:22.496 A:middle
这是因为旧设备

00:16:22.496 --> 00:16:24.186 A:middle
和较新设备之间

00:16:24.186 --> 00:16:26.136 A:middle
的性能特征

00:16:26.136 --> 00:16:28.716 A:middle
看起来不同

00:16:29.196 --> 00:16:31.636 A:middle
后者具有不同数量的 RAM 和 CPU 内核

00:16:32.936 --> 00:16:33.856 A:middle
这将确保你们的

00:16:33.856 --> 00:16:35.776 A:middle
所有设备上的

00:16:35.776 --> 00:16:38.046 A:middle
所有用户都能感到愉快

00:16:41.046 --> 00:16:41.836 A:middle
现在我们准备

00:16:41.836 --> 00:16:42.276 A:middle
进行一些测量

00:16:43.576 --> 00:16:45.076 A:middle
我们可以利用新的 XCTest 

00:16:45.286 --> 00:16:46.916 A:middle
来在 Xcode 11 中

00:16:46.916 --> 00:16:47.636 A:middle
测试 App 性能

00:16:48.686 --> 00:16:49.936 A:middle
只需几行代码

00:16:50.506 --> 00:16:51.446 A:middle
Xcode 就会重复启动你们的 App 

00:16:51.496 --> 00:16:53.716 A:middle
然后提供有关其

00:16:53.796 --> 00:16:55.626 A:middle
执行情况的统计结果

00:16:56.856 --> 00:16:58.626 A:middle
我们稍后会谈到这个

00:17:03.026 --> 00:17:05.326 A:middle
启动是什么以及如何衡量它

00:17:06.306 --> 00:17:09.126 A:middle
让我们谈谈如何改进它

00:17:10.516 --> 00:17:11.715 A:middle
当你们在代码和工具中

00:17:11.715 --> 00:17:13.556 A:middle
查看 App 的启动时

00:17:13.556 --> 00:17:15.136 A:middle
你们应该记住

00:17:15.136 --> 00:17:16.756 A:middle
这三个提示和技巧

00:17:18.205 --> 00:17:20.066 A:middle
首先是最小化你们的工作

00:17:20.066 --> 00:17:22.226 A:middle
然后优先考虑你们的工作

00:17:23.006 --> 00:17:25.205 A:middle
最后 优化你们的工作

00:17:27.016 --> 00:17:28.846 A:middle
在最小化工作时

00:17:28.846 --> 00:17:30.696 A:middle
你们应该推迟与

00:17:31.086 --> 00:17:32.536 A:middle
生成第一帧无关的任何内容

00:17:33.356 --> 00:17:34.746 A:middle
这意味着推迟

00:17:34.746 --> 00:17:36.746 A:middle
未显示的视图或尚未使用的

00:17:36.746 --> 00:17:39.146 A:middle
预加热功能等内容

00:17:41.216 --> 00:17:42.776 A:middle
你们还应该避免阻塞主线程

00:17:42.776 --> 00:17:46.996 A:middle
比如网络 I/O  文件 I/O 或其他

00:17:47.696 --> 00:17:48.836 A:middle
因为这会影响启动

00:17:49.216 --> 00:17:50.826 A:middle
将其移动到后台线程

00:17:51.756 --> 00:17:53.566 A:middle
最后 你们应该注意

00:17:53.566 --> 00:17:56.556 A:middle
减少内存使用量分配和操作

00:17:56.556 --> 00:18:00.686 A:middle
内存可能需要时间

00:18:00.896 --> 00:18:02.286 A:middle
接下来 优先工作

00:18:03.416 --> 00:18:04.206 A:middle
这时你们应确保以

00:18:04.206 --> 00:18:06.976 A:middle
正确的服务质量安排工作

00:18:08.296 --> 00:18:10.306 A:middle
现在 在 iOS 13 中

00:18:10.306 --> 00:18:11.456 A:middle
我们对排程器进行了

00:18:11.456 --> 00:18:14.006 A:middle
一些令人兴奋的优化

00:18:14.006 --> 00:18:15.076 A:middle
使你们的 App 启动速度更快

00:18:15.076 --> 00:18:16.876 A:middle
但这意味着

00:18:16.876 --> 00:18:18.706 A:middle
保持优先问题跨线程传播工作

00:18:18.706 --> 00:18:21.456 A:middle
比以往任何时候都更加重要

00:18:22.196 --> 00:18:24.456 A:middle
你们应该看看 2017 年 WWDC 的

00:18:24.456 --> 00:18:25.536 A:middle
《Modernizing Grand Central 

00:18:25.536 --> 00:18:28.236 A:middle
Dispatch Usage》

00:18:28.566 --> 00:18:30.056 A:middle
它深入探讨了

00:18:30.056 --> 00:18:31.286 A:middle
如何正确处理并发问题

00:18:33.916 --> 00:18:35.566 A:middle
最后 我们要进行优化工作

00:18:36.696 --> 00:18:37.966 A:middle
这应该是在最小化

00:18:37.966 --> 00:18:38.936 A:middle
并考虑优先级之后

00:18:38.936 --> 00:18:40.746 A:middle
剩下的所有东西了

00:18:41.366 --> 00:18:42.526 A:middle
也就是说它应该是

00:18:42.526 --> 00:18:43.976 A:middle
简化的和有限的

00:18:44.726 --> 00:18:46.376 A:middle
例如 限制仅在

00:18:46.376 --> 00:18:48.016 A:middle
启动期间获取所需

00:18:48.016 --> 00:18:50.306 A:middle
数据的数据量

00:18:50.306 --> 00:18:52.186 A:middle
或者懒计算

00:18:52.186 --> 00:18:53.406 A:middle
所需的任何变量和结果

00:18:55.016 --> 00:18:56.486 A:middle
当你们这样做时

00:18:56.486 --> 00:18:57.556 A:middle
请查看你们的方法和算法

00:18:57.556 --> 00:19:00.896 A:middle
看看你们是否可以优化它们

00:19:00.896 --> 00:19:02.196 A:middle
因为你们可以通过

00:19:02.196 --> 00:19:03.596 A:middle
不同的计算结果或

00:19:04.066 --> 00:19:05.006 A:middle
使用不同的数据结构

00:19:05.006 --> 00:19:05.426 A:middle
来获得显着的改进

00:19:06.006 --> 00:19:10.616 A:middle
最后 你们应该缓存你们的资源和复杂功能

00:19:11.396 --> 00:19:12.476 A:middle
当然 这是通过多次

00:19:12.526 --> 00:19:14.386 A:middle
不必要地工作

00:19:14.386 --> 00:19:16.646 A:middle
来减少 CPU 和内存开销

00:19:17.246 --> 00:19:20.506 A:middle
现在 我想把舞台交给 Dan

00:19:20.506 --> 00:19:22.696 A:middle
Dan 将为你们提供一个

00:19:22.696 --> 00:19:24.236 A:middle
关于如何在 Xcode Instruments 中使用

00:19:24.236 --> 00:19:25.496 A:middle
新的 App 启动模板

00:19:25.496 --> 00:19:27.696 A:middle
来理解和改进我们的 App 发布的精彩演示

00:19:28.516 --> 00:19:34.176 A:middle
[掌声]

00:19:34.676 --> 00:19:35.436 A:middle
&gt;&gt; 谢谢 Spencer

00:19:36.336 --> 00:19:38.326 A:middle
嗨 大家好 我是 Dan Sawada

00:19:38.376 --> 00:19:39.786 A:middle
我也是 Apple 的

00:19:39.786 --> 00:19:41.686 A:middle
性能工程师之一

00:19:42.666 --> 00:19:44.276 A:middle
今天 我将介绍一个了解

00:19:44.356 --> 00:19:45.676 A:middle
你们的 App 启动的

00:19:45.846 --> 00:19:47.616 A:middle
典型工作流程

00:19:48.156 --> 00:19:49.686 A:middle
并寻找最小化 

00:19:49.686 --> 00:19:53.886 A:middle
优先处理 以及优化工作的机会

00:19:53.886 --> 00:19:55.166 A:middle
以便你们可以真正提供

00:19:55.416 --> 00:19:57.596 A:middle
令人愉悦的第一次用户体验

00:19:58.836 --> 00:19:59.606 A:middle
那么 我们开始吧

00:19:59.606 --> 00:20:02.096 A:middle
我今天要展示的 

00:20:02.096 --> 00:20:04.496 A:middle
App 叫做《Star Searcher》

00:20:04.856 --> 00:20:06.186 A:middle
这是我们为此次分享会

00:20:06.186 --> 00:20:08.366 A:middle
专门编写的示例 App

00:20:09.106 --> 00:20:10.856 A:middle
如你们所见

00:20:10.856 --> 00:20:13.686 A:middle
这是一个非常典型的 UITableView

00:20:13.746 --> 00:20:14.976 A:middle
列出了我所有想象中的星星

00:20:15.176 --> 00:20:17.556 A:middle
如果单击单元格或星形

00:20:17.556 --> 00:20:19.936 A:middle
除了图片之外

00:20:19.936 --> 00:20:21.436 A:middle
它还会显示一些

00:20:21.436 --> 00:20:22.026 A:middle
描述性模糊状

00:20:23.116 --> 00:20:24.496 A:middle
但是 我们有一个问题 

00:20:25.496 --> 00:20:26.766 A:middle
先让我们继续并启动它

00:20:28.176 --> 00:20:29.676 A:middle
准备 开始

00:20:33.196 --> 00:20:38.926 A:middle
所以 这需要花费惊人的 2.5 秒才能启动

00:20:38.926 --> 00:20:40.546 A:middle
不知道我是否可以称之为 令人愉快的

00:20:40.896 --> 00:20:42.676 A:middle
所以 让我们使用 Xcode 和

00:20:43.016 --> 00:20:44.606 A:middle
Instruments 来看看

00:20:45.016 --> 00:20:46.786 A:middle
我们能做些什么

00:20:49.106 --> 00:20:51.326 A:middle
所以 这里我们有

00:20:51.386 --> 00:20:52.726 A:middle
《Star Searcher》 的 Xcode 项目

00:20:53.456 --> 00:21:01.126 A:middle
现在 在进行任何与性能相关的分析之前

00:21:01.956 --> 00:21:03.576 A:middle
我们应该做的一件重要事情

00:21:03.576 --> 00:21:04.026 A:middle
是在 Xcode 中选择“Profile”Scheme

00:21:04.856 --> 00:21:08.076 A:middle
这将确保 Xcode 

00:21:08.076 --> 00:21:11.816 A:middle
在发布模式下重新编译你们的 App

00:21:11.816 --> 00:21:14.646 A:middle
以便你们可以利用编译器时间优化

00:21:15.716 --> 00:21:17.196 A:middle
一旦 Xcode 重新编译你们的 App

00:21:17.756 --> 00:21:19.026 A:middle
它将在你们的设备上安装它

00:21:19.026 --> 00:21:21.936 A:middle
并启动 Instruments

00:21:22.736 --> 00:21:24.816 A:middle
现在我们很高兴地宣布

00:21:25.056 --> 00:21:28.416 A:middle
从 iOS 13 或 Xcode 11 开始

00:21:28.796 --> 00:21:29.896 A:middle
我们现在有了

00:21:29.896 --> 00:21:31.316 A:middle
App Launch 模板

00:21:31.316 --> 00:21:35.496 A:middle
专门用于这样的情况

00:21:35.496 --> 00:21:36.616 A:middle
弄清楚 App 启动的问题

00:21:37.366 --> 00:21:39.096 A:middle
那么 让我们继续并

00:21:39.806 --> 00:21:42.256 A:middle
双击 App Launch

00:21:42.826 --> 00:21:45.786 A:middle
现在我们要做的

00:21:45.786 --> 00:21:49.876 A:middle
第一件事就是点按记录按钮

00:21:52.776 --> 00:21:54.176 A:middle
此时 Instruments 将自动

00:21:54.176 --> 00:21:57.826 A:middle
启动我们的 App《Star Searcher》

00:21:57.826 --> 00:22:00.016 A:middle
收集所有指标

00:22:00.586 --> 00:22:02.176 A:middle
遥测数据 分析它们

00:22:02.176 --> 00:22:03.756 A:middle
并为所有 App 启动阶段

00:22:03.756 --> 00:22:04.776 A:middle
创建可视化

00:22:05.686 --> 00:22:06.816 A:middle
所以 看一看

00:22:07.396 --> 00:22:09.906 A:middle
标记为紫色的

00:22:09.906 --> 00:22:12.836 A:middle
前几个阶段是

00:22:12.836 --> 00:22:14.316 A:middle
在 App 中调用 main 函数

00:22:14.316 --> 00:22:15.506 A:middle
之前发生的阶段

00:22:17.656 --> 00:22:19.316 A:middle
在绿色阶段

00:22:19.316 --> 00:22:21.356 A:middle
当你们的 App 完成其启动

00:22:21.356 --> 00:22:22.916 A:middle
并在 UI 中绘制其第一帧

00:22:22.916 --> 00:22:24.426 A:middle
早期的这些过程发生在

00:22:24.426 --> 00:22:26.556 A:middle
你们的主要功能的

00:22:26.556 --> 00:22:29.746 A:middle
第一阶段

00:22:29.906 --> 00:22:32.166 A:middle
让我们继续并展开轨道

00:22:32.686 --> 00:22:34.566 A:middle
在我们展开轨道时

00:22:34.716 --> 00:22:36.496 A:middle
你们可以看到在 App 进程中

00:22:36.496 --> 00:22:37.956 A:middle
响应的所有线程的

00:22:37.956 --> 00:22:39.126 A:middle
详细状态

00:22:40.086 --> 00:22:41.966 A:middle
显然 最重要的一个

00:22:41.966 --> 00:22:44.256 A:middle
是主线程

00:22:44.296 --> 00:22:46.106 A:middle
或者也称为 UI 线程

00:22:46.356 --> 00:22:47.936 A:middle
它负责处理

00:22:47.936 --> 00:22:51.016 A:middle
用户输入和绘制 UI

00:22:51.786 --> 00:22:53.416 A:middle
让我们继续并确定

00:22:53.416 --> 00:22:54.646 A:middle
与我们的目的相关的轨道

00:22:54.646 --> 00:22:56.206 A:middle
从 App 启动阶段开始

00:22:56.386 --> 00:22:59.356 A:middle
我们的主要线程

00:22:59.786 --> 00:23:01.436 A:middle
还有一个工人线程

00:23:01.436 --> 00:23:02.616 A:middle
在启动期间

00:23:02.826 --> 00:23:04.546 A:middle
做了大量的工作

00:23:05.476 --> 00:23:08.086 A:middle
所以 让我们继续下去 并将其

00:23:08.976 --> 00:23:10.136 A:middle
固定下来

00:23:11.616 --> 00:23:13.426 A:middle
说到线程状态 

00:23:13.426 --> 00:23:18.226 A:middle
哎呀 像那样

00:23:21.076 --> 00:23:23.596 A:middle
说到线程状态 

00:23:23.596 --> 00:23:24.856 A:middle
灰色意味着它被阻止

00:23:24.856 --> 00:23:26.336 A:middle
这意味着线程没有做任何工作

00:23:27.856 --> 00:23:30.016 A:middle
红色意味着它可以运行

00:23:30.016 --> 00:23:31.546 A:middle
这意味着计划完成工作

00:23:31.546 --> 00:23:34.326 A:middle
但缺乏 CPU 资源

00:23:35.256 --> 00:23:37.046 A:middle
橙色意味着它被抢先一步

00:23:37.166 --> 00:23:39.336 A:middle
这意味着它正在开展工作

00:23:39.566 --> 00:23:41.376 A:middle
但却被中断

00:23:41.466 --> 00:23:44.216 A:middle
支持其他具有更高优先级的竞争工作

00:23:44.856 --> 00:23:47.046 A:middle
最后但并非不重要的是

00:23:47.046 --> 00:23:48.376 A:middle
蓝色表示它正在运行

00:23:48.376 --> 00:23:49.836 A:middle
这意味着它实际上正在 

00:23:49.926 --> 00:23:50.676 A:middle
CPU 核心上工作

00:23:50.676 --> 00:23:53.856 A:middle
因此 有了这些信息

00:23:53.856 --> 00:23:57.266 A:middle
让我们从系统界面初始化

00:23:57.266 --> 00:23:58.516 A:middle
开始逐步查看

00:24:02.706 --> 00:24:04.676 A:middle
我们可以突出显示这个阶段

00:24:04.676 --> 00:24:06.016 A:middle
并在屏幕下半部分

00:24:06.016 --> 00:24:07.236 A:middle
获取详细信息

00:24:08.026 --> 00:24:09.776 A:middle
在你们的左侧

00:24:09.776 --> 00:24:12.246 A:middle
你们可以看到在此时间段内

00:24:12.246 --> 00:24:13.376 A:middle
正在完成的所有工作的

00:24:13.376 --> 00:24:14.216 A:middle
详细栈跟踪

00:24:14.926 --> 00:24:17.676 A:middle
在右侧 你们也可以看到

00:24:17.676 --> 00:24:19.176 A:middle
聚合栈跟踪

00:24:19.176 --> 00:24:21.786 A:middle
其中列出了按 CPU 

00:24:21.786 --> 00:24:23.856 A:middle
样本数量排序的所有符号

00:24:24.826 --> 00:24:29.366 A:middle
现在请注意这个初始阶段

00:24:29.736 --> 00:24:32.576 A:middle
在设置系统接口时只需要 6 毫秒

00:24:33.316 --> 00:24:35.196 A:middle
这主要归功于 

00:24:35.196 --> 00:24:37.666 A:middle
dyld3 的引入

00:24:37.946 --> 00:24:39.546 A:middle
和第三方应 App 的优势

00:24:39.546 --> 00:24:42.086 A:middle
以及其他系统层的增强功能

00:24:42.996 --> 00:24:45.316 A:middle
因此 作为开发者

00:24:45.316 --> 00:24:46.706 A:middle
我们可以利用所有这些

00:24:46.706 --> 00:24:49.906 A:middle
增强功能 而无需编写任何代码

00:24:50.876 --> 00:24:54.386 A:middle
让我们继续来看

00:24:54.386 --> 00:24:55.986 A:middle
但在我们这样做之前

00:24:55.986 --> 00:24:56.806 A:middle
我还应该指出另一件事

00:24:57.996 --> 00:25:00.156 A:middle
请注意 虽然此阶段

00:25:00.156 --> 00:25:02.206 A:middle
仅为《Star Searcher》 的

00:25:02.206 --> 00:25:05.876 A:middle
CPU 占时上花费了 6 毫秒

00:25:05.876 --> 00:25:09.186 A:middle
但它实际上花费了 149 毫秒

00:25:09.626 --> 00:25:11.366 A:middle
这种差异来自

00:25:11.406 --> 00:25:13.016 A:middle
分析机制本身的开销

00:25:13.016 --> 00:25:15.376 A:middle
它确实为我们

00:25:15.376 --> 00:25:17.006 A:middle
提供了大量的信息和想法

00:25:17.006 --> 00:25:18.886 A:middle
但是它有自己的成本 

00:25:19.056 --> 00:25:21.156 A:middle
因此 这就是将分析与

00:25:21.156 --> 00:25:23.016 A:middle
测量结果区分开来

00:25:23.176 --> 00:25:24.946 A:middle
非常重要的原因

00:25:25.186 --> 00:25:26.866 A:middle
稍后我将对此进行解释

00:25:27.496 --> 00:25:30.506 A:middle
进入下一阶段

00:25:30.506 --> 00:25:32.276 A:middle
即静态运行时初始化

00:25:32.856 --> 00:25:35.566 A:middle
现在我们注意到这个阶段

00:25:35.566 --> 00:25:38.616 A:middle
耗时惊人的 375 毫秒

00:25:39.046 --> 00:25:40.866 A:middle
这就有点太长了

00:25:42.316 --> 00:25:43.126 A:middle
那我们来看看吧

00:25:43.866 --> 00:25:45.056 A:middle
查看详细的栈跟踪

00:25:45.096 --> 00:25:47.566 A:middle
我们看到一个带有

00:25:47.696 --> 00:25:50.576 A:middle
蓝色图标的突出显示的符号

00:25:50.686 --> 00:25:54.366 A:middle
标志着 CPU 工作量为 370 毫秒

00:25:54.716 --> 00:25:56.186 A:middle
现在 所有这些突出显示的

00:25:56.256 --> 00:25:58.336 A:middle
符号表示在我们的

00:25:58.376 --> 00:25:59.976 A:middle
源中声明的代码

00:26:08.046 --> 00:26:09.826 A:middle
现在通过扩展栈跟踪

00:26:09.866 --> 00:26:12.426 A:middle
它将我们指向

00:26:12.426 --> 00:26:14.046 A:middle
SLSuperFastLogger

00:26:14.456 --> 00:26:18.496 A:middle
现在 如果一个库自称超高速（SuperFast）

00:26:18.596 --> 00:26:22.496 A:middle
是有一些可疑的

00:26:22.496 --> 00:26:22.706 A:middle
但还是让我们来看看

00:26:23.266 --> 00:26:26.266 A:middle
那么 SLSuperFastLogger

00:26:26.266 --> 00:26:27.786 A:middle
是我们专门导入 

00:26:27.786 --> 00:26:29.926 A:middle
《Star Searcher》的外部框架

00:26:29.926 --> 00:26:34.606 A:middle
可以利用强大而方便的日志记录

00:26:35.556 --> 00:26:37.256 A:middle
但是 我们调用此框架的

00:26:37.256 --> 00:26:41.186 A:middle
唯一位置是

00:26:41.186 --> 00:26:42.556 A:middle
在 TableViewController 中

00:26:43.016 --> 00:26:44.296 A:middle
具体说来

00:26:44.296 --> 00:26:46.146 A:middle
在 didSelectRowAt 回调中

00:26:47.236 --> 00:26:49.816 A:middle
现在这个回调完全在

00:26:49.816 --> 00:26:51.226 A:middle
启动路径之外

00:26:51.406 --> 00:26:53.176 A:middle
因为它只在用户点按

00:26:53.176 --> 00:26:54.026 A:middle
一个单元格时调用

00:26:54.326 --> 00:26:56.616 A:middle
那么 为什么它在之前的启动期间

00:26:56.616 --> 00:27:00.656 A:middle
甚至在我们的主函数被调用之前

00:27:00.656 --> 00:27:02.976 A:middle
它的工作量超过 300 毫秒呢

00:27:03.436 --> 00:27:04.836 A:middle
好吧 我们来探个究竟

00:27:08.476 --> 00:27:10.696 A:middle
通过搜索符号

00:27:10.696 --> 00:27:13.336 A:middle
它指向我们在

00:27:13.376 --> 00:27:14.666 A:middle
SLSuperFastLogger 类中

00:27:14.756 --> 00:27:16.006 A:middle
声明的加载方法

00:27:16.796 --> 00:27:18.026 A:middle
现在 这是一个

00:27:18.026 --> 00:27:20.816 A:middle
静态初始化程序

00:27:20.816 --> 00:27:23.296 A:middle
这意味着所有这些工作

00:27:23.296 --> 00:27:24.976 A:middle
都将在调用 main 函数之前的

00:27:24.976 --> 00:27:26.486 A:middle
早期启动时完成

00:27:26.486 --> 00:27:27.886 A:middle
因为我们链接了它

00:27:28.416 --> 00:27:30.636 A:middle
这里的重点是

00:27:30.636 --> 00:27:33.686 A:middle
了解依赖在你们使用的

00:27:33.686 --> 00:27:37.296 A:middle
框架中的影响 是非常重要的

00:27:38.016 --> 00:27:39.116 A:middle
外部库和框架可能很方便

00:27:39.116 --> 00:27:40.676 A:middle
也可能很强大

00:27:40.676 --> 00:27:42.976 A:middle
但可能需要付出

00:27:42.976 --> 00:27:44.076 A:middle
巨大的代价

00:27:44.456 --> 00:27:48.316 A:middle
所以 如果这些成本带来了

00:27:48.316 --> 00:27:49.796 A:middle
这些好处 那很好

00:27:49.796 --> 00:27:51.606 A:middle
但对于我们的情况

00:27:51.606 --> 00:27:54.166 A:middle
在启动期间的 300 毫秒

00:27:54.166 --> 00:27:55.536 A:middle
对于它的价值来说有点花费太多了

00:27:56.316 --> 00:27:58.496 A:middle
所以 让我们继续前进

00:27:58.496 --> 00:27:59.216 A:middle
寻求替代方案

00:28:02.346 --> 00:28:03.956 A:middle
这是一个非常轻量级

00:28:03.956 --> 00:28:06.226 A:middle
和高效的日志记录机制

00:28:06.226 --> 00:28:08.546 A:middle
适用于 iOS 以及

00:28:08.716 --> 00:28:11.696 A:middle
其他 Apple 平台

00:28:11.696 --> 00:28:15.076 A:middle
一旦我们删除了依赖

00:28:15.076 --> 00:28:17.696 A:middle
我们一定要记住一件事

00:28:18.176 --> 00:28:23.426 A:middle
即删除实际的链接

00:28:23.946 --> 00:28:26.616 A:middle
现在因为这里的成本

00:28:26.706 --> 00:28:28.476 A:middle
是静态初始化程序

00:28:28.916 --> 00:28:31.936 A:middle
我们需要确保删除链接

00:28:31.936 --> 00:28:36.766 A:middle
以免影响我们

00:28:37.106 --> 00:28:40.066 A:middle
那么 有了这个 让我们回到我们的跟踪

00:28:41.076 --> 00:28:44.706 A:middle
下一阶段是 UIKit 初始化 

00:28:44.706 --> 00:28:48.316 A:middle
实际上耗时 28 毫秒

00:28:48.746 --> 00:28:52.186 A:middle
这几乎是所有 App 的固定成本

00:28:53.066 --> 00:28:58.596 A:middle
除非你们将 UI App 子类化

00:28:58.596 --> 00:28:59.966 A:middle
或在 UIApplicationDelegate 中执行

00:28:59.966 --> 00:29:02.136 A:middle
自定义初始化工作

00:29:02.136 --> 00:29:03.196 A:middle
否则它几乎是我们

00:29:03.196 --> 00:29:04.446 A:middle
现在可以忽略的

00:29:04.976 --> 00:29:06.856 A:middle
那么 让我们继续前进

00:29:08.416 --> 00:29:11.296 A:middle
下一部分工作是

00:29:11.336 --> 00:29:13.046 A:middle
你们的 App 初始化

00:29:13.566 --> 00:29:15.586 A:middle
这基本是由你们控制的

00:29:16.146 --> 00:29:18.296 A:middle
注意到使用 

00:29:18.296 --> 00:29:20.116 A:middle
didFinishLaunchingWithOptions 

00:29:20.266 --> 00:29:25.306 A:middle
回调进行了大量的工作

00:29:25.306 --> 00:29:26.736 A:middle
这在时钟上花费了 791 毫秒

00:29:27.086 --> 00:29:28.706 A:middle
这其实很长

00:29:29.546 --> 00:29:32.276 A:middle
让我们来看看

00:29:32.536 --> 00:29:35.056 A:middle
因此 此阶段立即

00:29:35.056 --> 00:29:36.846 A:middle
指出我们在

00:29:36.846 --> 00:29:39.986 A:middle
StarDataProvider 类中进行了大量工作

00:29:41.156 --> 00:29:42.276 A:middle
也就是在载入星星

00:29:42.796 --> 00:29:48.076 A:middle
好的 现在请注意主线程中

00:29:48.076 --> 00:29:50.776 A:middle
存在巨大的阻塞

00:29:50.776 --> 00:29:52.066 A:middle
这实际上是我们启动的延迟

00:29:52.596 --> 00:29:55.896 A:middle
我们的主线程被阻止了 754 毫秒

00:29:56.306 --> 00:29:58.396 A:middle
这很不理想

00:29:59.606 --> 00:30:00.266 A:middle
让我们来看看

00:30:01.926 --> 00:30:03.126 A:middle
因此 为了检查详细状态

00:30:03.126 --> 00:30:07.326 A:middle
我们应该查看事件列表

00:30:09.016 --> 00:30:11.096 A:middle
通过查看事件列表

00:30:11.096 --> 00:30:12.666 A:middle
我们注意到它被

00:30:12.796 --> 00:30:15.756 A:middle
阻止了 754 毫秒

00:30:15.796 --> 00:30:20.376 A:middle
之后 它被线程 0x12253 解除阻塞

00:30:20.376 --> 00:30:22.576 A:middle
或者说变得可运行了

00:30:23.396 --> 00:30:28.316 A:middle
这对应着正在做大量工作的工人线程

00:30:29.636 --> 00:30:31.386 A:middle
所以 这里有一些联系

00:30:32.576 --> 00:30:34.096 A:middle
现在回到主线程

00:30:34.096 --> 00:30:36.256 A:middle
注意它被安排

00:30:36.296 --> 00:30:38.816 A:middle
在优先级 47 上工作

00:30:39.376 --> 00:30:41.356 A:middle
47 个等同于

00:30:41.356 --> 00:30:45.066 A:middle
用户交互 QoS

00:30:45.276 --> 00:30:47.016 A:middle
现在注意到这些红色交汇处

00:30:47.016 --> 00:30:49.606 A:middle
我们还有很多工作要做

00:30:49.646 --> 00:30:51.986 A:middle
但是他缺少 CPU 资源

00:30:52.496 --> 00:30:54.196 A:middle
好吧 让我们找出原因

00:30:55.446 --> 00:30:58.476 A:middle
当我们点按工人线程时

00:30:58.476 --> 00:30:59.836 A:middle
我们注意到有

00:30:59.836 --> 00:31:02.156 A:middle
很多工作计划在

00:31:02.156 --> 00:31:03.456 A:middle
优先级 4 下工作

00:31:03.966 --> 00:31:06.106 A:middle
这相当于后台 QoS

00:31:06.106 --> 00:31:09.116 A:middle
我们在这里

00:31:09.116 --> 00:31:11.326 A:middle
实际看到的是一种被称为

00:31:11.326 --> 00:31:13.176 A:middle
优先级倒置的问题

00:31:13.316 --> 00:31:15.186 A:middle
其中给定线程被一个比自身

00:31:15.186 --> 00:31:17.406 A:middle
具有更低 QoS 或优先级的

00:31:17.906 --> 00:31:19.386 A:middle
单独线程阻塞

00:31:20.176 --> 00:31:21.676 A:middle
显然 这并不理想

00:31:21.936 --> 00:31:23.816 A:middle
因为它占用的资源

00:31:23.816 --> 00:31:25.286 A:middle
超出了应有的范围

00:31:25.736 --> 00:31:30.346 A:middle
所以 让我们继续尝试解决这个问题

00:31:30.346 --> 00:31:32.096 A:middle
回顾一下这个问题的核心

00:31:32.096 --> 00:31:34.826 A:middle
StarDataProvider 是一个

00:31:34.826 --> 00:31:36.576 A:middle
非常简单的类

00:31:36.576 --> 00:31:38.016 A:middle
它负责从 SQLite 数据库

00:31:38.506 --> 00:31:40.396 A:middle
中获取我们的星星数据

00:31:40.396 --> 00:31:42.516 A:middle
有一个具有

00:31:42.516 --> 00:31:44.456 A:middle
后台 QoS 的专用调度队列

00:31:45.296 --> 00:31:47.286 A:middle
并注意这是

00:31:47.286 --> 00:31:48.786 A:middle
为了确保数据提取

00:31:48.786 --> 00:31:50.946 A:middle
不会与 UI 竞争

00:31:50.946 --> 00:31:54.556 A:middle
并且有两个 API 被暴露

00:31:55.246 --> 00:31:56.556 A:middle
一个用于使用

00:31:56.556 --> 00:32:00.846 A:middle
此 GrandCentralDispatch 的异步原语

00:32:00.886 --> 00:32:06.866 A:middle
和另一个以同步方式加载数据的同步 API

00:32:08.446 --> 00:32:10.876 A:middle
现在看看  

00:32:10.876 --> 00:32:12.026 A:middle
didFinishLaunchingWithOptions

00:32:12.026 --> 00:32:13.686 A:middle
中的实际调用站点

00:32:14.776 --> 00:32:15.916 A:middle
我们正在利用

00:32:16.046 --> 00:32:19.486 A:middle
异步 API

00:32:19.486 --> 00:32:20.706 A:middle
但也利用调度 semaphore

00:32:20.816 --> 00:32:23.346 A:middle
来确保在继续

00:32:23.346 --> 00:32:26.706 A:middle
绘制 TableView 的第一帧之前

00:32:26.706 --> 00:32:29.816 A:middle
等待所有数据都被提取

00:32:29.816 --> 00:32:32.626 A:middle
现在 如果我们要这样做

00:32:32.626 --> 00:32:37.376 A:middle
我们应该使用正确的并发原语

00:32:37.696 --> 00:32:41.736 A:middle
也就是 GCD 中的同步原语

00:32:42.306 --> 00:32:45.436 A:middle
用过使用正确的并发原语

00:32:45.746 --> 00:32:47.376 A:middle
GrandCentralDispatch 将

00:32:47.376 --> 00:32:49.186 A:middle
临时将主线程

00:32:49.246 --> 00:32:51.176 A:middle
的优先级传播到

00:32:51.176 --> 00:32:52.626 A:middle
工人线程 并将其提升为

00:32:52.626 --> 00:32:55.206 A:middle
用户非活动状态

00:32:57.376 --> 00:32:57.546 A:middle
以使其匹配

00:32:57.676 --> 00:32:59.986 A:middle
所以 在这一点上

00:32:59.986 --> 00:33:01.916 A:middle
我认为我们有可能

00:33:01.916 --> 00:33:03.186 A:middle
解决优先级倒置问题

00:33:03.186 --> 00:33:04.456 A:middle
但我还注意这儿

00:33:04.456 --> 00:33:05.066 A:middle
有一个问题

00:33:06.326 --> 00:33:09.006 A:middle
loadStarDataSync API 接受

00:33:09.006 --> 00:33:12.576 A:middle
一系列行来加载数据

00:33:13.196 --> 00:33:15.016 A:middle
在我们的例子中

00:33:15.296 --> 00:33:17.776 A:middle
我们从第 0 行加载到最后一行

00:33:17.996 --> 00:33:19.766 A:middle
这基本上就是一切

00:33:20.646 --> 00:33:22.946 A:middle
现在 当你们考虑它时

00:33:22.946 --> 00:33:24.666 A:middle
第一帧只能适合

00:33:24.666 --> 00:33:27.746 A:middle
可能在屏幕尺寸上的

00:33:27.746 --> 00:33:28.706 A:middle
有限数量的单元格

00:33:29.186 --> 00:33:30.506 A:middle
在《Star Searcher》的情况下

00:33:30.986 --> 00:33:32.386 A:middle
可能大约 10 到 15 个

00:33:32.736 --> 00:33:33.636 A:middle
具体取决于设备

00:33:34.186 --> 00:33:36.186 A:middle
所以 让我们继续并优化它

00:33:36.186 --> 00:33:38.086 A:middle
而不是加载所有内容

00:33:38.216 --> 00:33:41.336 A:middle
让我们只加载前 20 行

00:33:41.496 --> 00:33:44.806 A:middle
就足以以同步方式

00:33:44.886 --> 00:33:47.006 A:middle
绘制 TableView 的第一帧

00:33:47.846 --> 00:33:49.606 A:middle
之后 我们应该在后台

00:33:49.606 --> 00:33:51.316 A:middle
懒加载所有其余的

00:33:51.316 --> 00:33:53.156 A:middle
只在启动后完成后

00:33:53.156 --> 00:33:55.566 A:middle
更新 TableView

00:33:58.136 --> 00:33:58.916 A:middle
让我们继续吧

00:33:59.696 --> 00:34:02.006 A:middle
最后但也很重要的是回到追踪

00:34:02.396 --> 00:34:05.046 A:middle
最后一个阶段是我们的

00:34:05.046 --> 00:34:06.256 A:middle
第一个帧渲染

00:34:07.846 --> 00:34:11.126 A:middle
请注意 这个阶段花了 951 毫秒

00:34:11.126 --> 00:34:12.656 A:middle
这是非常长的

00:34:12.656 --> 00:34:15.866 A:middle
考虑到这只是负责

00:34:15.866 --> 00:34:17.556 A:middle
布局工作和我们

00:34:17.556 --> 00:34:18.186 A:middle
第一帧的渲染

00:34:19.606 --> 00:34:22.656 A:middle
现在让我们更深入地了解它

00:34:22.856 --> 00:34:28.206 A:middle
它指向 StarTableViewController

00:34:29.906 --> 00:34:31.896 A:middle
并查看详细的栈跟踪

00:34:31.936 --> 00:34:36.916 A:middle
我们看到了很多工作和

00:34:36.916 --> 00:34:39.755 A:middle
一个 cellForRowAt 回调

00:34:39.755 --> 00:34:42.485 A:middle
它负责执行单元格的布局工作

00:34:42.485 --> 00:34:45.335 A:middle
让我们继续并扩展我们所说的

00:34:46.216 --> 00:34:49.136 A:middle
当我们扩展栈跟踪时

00:34:49.176 --> 00:34:53.815 A:middle
它指明我们为 StarDetailViewController 进行了

00:34:53.815 --> 00:34:56.565 A:middle
大量的初始化工作

00:34:56.565 --> 00:34:59.386 A:middle
这在 CPU 上耗时 882 毫秒

00:34:59.466 --> 00:35:02.586 A:middle
所以 在这一点上我们已经发现

00:35:02.586 --> 00:35:02.976 A:middle
这几乎是这里的瓶颈

00:35:05.046 --> 00:35:06.626 A:middle
我们来看看我们的代码吧

00:35:06.676 --> 00:35:12.416 A:middle
现在查看 cellforRowAt 回调中的

00:35:12.556 --> 00:35:15.746 A:middle
tableView 控制器

00:35:15.746 --> 00:35:17.406 A:middle
我们使用自定义单元格创建单元格

00:35:18.576 --> 00:35:22.976 A:middle
同时 我们进行推测性优化

00:35:22.976 --> 00:35:26.846 A:middle
预热和缓存 DetailView 的 

00:35:27.036 --> 00:35:29.516 A:middle
DetailViewControllers

00:35:29.516 --> 00:35:29.806 A:middle
就像我们做布局工作一样

00:35:30.306 --> 00:35:31.686 A:middle
这是希望简化从

00:35:32.046 --> 00:35:33.806 A:middle
表格视图到

00:35:33.806 --> 00:35:35.266 A:middle
详细视图的过渡

00:35:35.836 --> 00:35:38.456 A:middle
但正如我们在追踪中所看到的

00:35:38.846 --> 00:35:40.126 A:middle
这并不会产生高成本

00:35:41.196 --> 00:35:43.156 A:middle
现在退一步

00:35:43.306 --> 00:35:44.296 A:middle
当你想到它时

00:35:44.296 --> 00:35:45.816 A:middle
详细的视图对

00:35:45.816 --> 00:35:47.356 A:middle
我们的第一帧没有意义

00:35:47.816 --> 00:35:49.126 A:middle
只有当用户点按

00:35:49.126 --> 00:35:50.376 A:middle
一个单元格时才有意义

00:35:51.276 --> 00:35:54.336 A:middle
所以 让我们继续推迟这项工作

00:35:57.356 --> 00:35:58.486 A:middle
我们应该把它推迟到哪里

00:35:59.216 --> 00:36:01.566 A:middle
也许是 didSelectRowAt 回调这里

00:36:01.566 --> 00:36:07.966 A:middle
当用户点按一个单元格时调用它

00:36:09.336 --> 00:36:11.156 A:middle
因此 此时 我们对 

00:36:11.276 --> 00:36:12.526 A:middle
《Star Searcher》进行了

00:36:12.526 --> 00:36:14.316 A:middle
一些改进或优化

00:36:14.466 --> 00:36:15.976 A:middle
所以 让我们继续并重新分析它

00:36:23.086 --> 00:36:26.656 A:middle
现在需要注意的一点是

00:36:26.656 --> 00:36:29.646 A:middle
当你们进行增量更改时

00:36:29.646 --> 00:36:32.046 A:middle
你们应该在进展时

00:36:32.046 --> 00:36:34.076 A:middle
不断重新测量

00:36:34.076 --> 00:36:35.006 A:middle
和重新分析

00:36:35.356 --> 00:36:37.676 A:middle
这样 你们就可以

00:36:37.746 --> 00:36:41.776 A:middle
真正了解你们增量变更集的确切影响

00:36:42.046 --> 00:36:43.416 A:middle
但是为了这个演示

00:36:43.696 --> 00:36:44.916 A:middle
我们实际上因为

00:36:44.916 --> 00:36:49.566 A:middle
节省时间 把所有变化合并为一个 Boom

00:36:49.566 --> 00:36:51.086 A:middle
有一点 UI 故障

00:36:51.086 --> 00:36:54.016 A:middle
但我们可以立即看到

00:36:54.406 --> 00:36:56.456 A:middle
我们的启动时间不到 500 毫秒

00:36:57.186 --> 00:37:02.346 A:middle
现在 正如我之前所说

00:37:02.346 --> 00:37:04.296 A:middle
分析机制确实带来了

00:37:04.296 --> 00:37:05.376 A:middle
自己的成本

00:37:05.636 --> 00:37:06.896 A:middle
因此 为了更好地了解

00:37:06.896 --> 00:37:08.816 A:middle
我们的用户将

00:37:08.816 --> 00:37:11.486 A:middle
体验到什么

00:37:12.476 --> 00:37:15.656 A:middle
让我们继续使用

00:37:16.066 --> 00:37:17.626 A:middle
新的 XCTest API 来测量

00:37:17.626 --> 00:37:18.886 A:middle
我们测试中的启动性能

00:37:20.246 --> 00:37:21.986 A:middle
只需几行代码

00:37:22.176 --> 00:37:23.886 A:middle
我们就可以将

00:37:23.886 --> 00:37:25.876 A:middle
启动性能测试

00:37:25.876 --> 00:37:27.766 A:middle
或任何性能测试与 XCTest 集成在一起

00:37:28.306 --> 00:37:32.446 A:middle
让我们继续 并启动测试

00:37:33.886 --> 00:37:39.636 A:middle
现在 XCTest 将进行一次一次性的启动测试

00:37:39.846 --> 00:37:41.936 A:middle
这将取消冷启动

00:37:42.536 --> 00:37:44.946 A:middle
会产生的差异

00:37:45.466 --> 00:37:47.116 A:middle
之后 它将执行

00:37:47.116 --> 00:37:48.676 A:middle
指定的迭代次数

00:37:48.816 --> 00:37:51.326 A:middle
或者默认执行

00:37:51.436 --> 00:37:54.016 A:middle
五次迭代 并测量所花费的时间

00:37:54.856 --> 00:37:57.176 A:middle
之后 它将产生一些

00:37:57.176 --> 00:38:01.986 A:middle
很好的统计数据

00:38:02.186 --> 00:38:06.236 A:middle
这项测试需要几分钟才能完成

00:38:06.236 --> 00:38:09.986 A:middle
现在我们已经将《Star Searcher》的启动

00:38:10.106 --> 00:38:12.696 A:middle
从 2.5 秒推到了

00:38:13.066 --> 00:38:16.536 A:middle
刚刚超过 300 毫秒

00:38:17.031 --> 00:38:19.031 A:middle
[掌声]

00:38:19.046 --> 00:38:21.346 A:middle
为了结束演示

00:38:21.346 --> 00:38:22.136 A:middle
我想向你们展示

00:38:22.686 --> 00:38:23.726 A:middle
UI 上的实际情况

00:38:24.606 --> 00:38:26.276 A:middle
好了 让我们确保漂亮得完成了

00:38:26.276 --> 00:38:29.126 A:middle
《Star Searcher》真的很快

00:38:30.516 --> 00:38:33.500 A:middle
[掌声]

00:38:38.056 --> 00:38:39.946 A:middle
谢谢你们 交回给你 Spencer

00:38:41.516 --> 00:38:45.376 A:middle
[掌声]

00:38:45.876 --> 00:38:47.066 A:middle
&gt;&gt; 多谢 Dan 关于如何使用

00:38:47.066 --> 00:38:49.076 A:middle
Xcode Instruments

00:38:49.486 --> 00:38:51.746 A:middle
App Launch 模板

00:38:52.006 --> 00:38:53.766 A:middle
来改善我们的 App 启动体验的精彩演示

00:38:54.526 --> 00:38:57.226 A:middle
好的 我们意识到

00:38:57.226 --> 00:38:59.816 A:middle
在你们的代码库中

00:38:59.816 --> 00:39:01.766 A:middle
你们不会在代码中

00:39:01.766 --> 00:39:03.356 A:middle
找到几个可以用几行修复的地方

00:39:03.356 --> 00:39:06.516 A:middle
并获得如此重大的改进

00:39:07.546 --> 00:39:10.356 A:middle
你很可能必须找到一堆

00:39:10.356 --> 00:39:12.396 A:middle
5 到 10 毫秒的胜利

00:39:12.396 --> 00:39:13.586 A:middle
然后将所有这些组合在一起

00:39:14.816 --> 00:39:15.866 A:middle
我们想让你们知道

00:39:15.866 --> 00:39:16.396 A:middle
我们已经在背后支持你们了

00:39:17.746 --> 00:39:20.146 A:middle
我们已经进行了

00:39:20.146 --> 00:39:21.636 A:middle
大量的 iOS 优化以改善

00:39:21.636 --> 00:39:23.146 A:middle
你们的 App 的推出

00:39:23.146 --> 00:39:26.076 A:middle
并帮助你们实现目标

00:39:26.076 --> 00:39:27.016 A:middle
而你们几乎没有采用

00:39:28.016 --> 00:39:30.396 A:middle
我想特别呼吁采用一些

00:39:30.956 --> 00:39:36.256 A:middle
如前所述 dyld3 将运行时依赖项

00:39:36.256 --> 00:39:38.056 A:middle
缓存到你们的 App 中

00:39:38.056 --> 00:39:39.276 A:middle
你们在演示中看到了这些依赖项

00:39:39.426 --> 00:39:40.976 A:middle
这提供了巨大的改进

00:39:41.496 --> 00:39:43.606 A:middle
排程器还经过优化

00:39:43.606 --> 00:39:45.626 A:middle
以帮助确定启动期间

00:39:45.626 --> 00:39:47.236 A:middle
发生的工作的优先级

00:39:48.026 --> 00:39:50.126 A:middle
我们还仔细看了 Auto Layout

00:39:50.126 --> 00:39:51.646 A:middle
和 Objective-C

00:39:51.956 --> 00:39:53.736 A:middle
并在那里进行了一系列优化

00:39:54.896 --> 00:39:56.526 A:middle
最后 我们将在今年晚些时候

00:39:56.526 --> 00:39:57.566 A:middle
对 App 打包进行

00:39:57.766 --> 00:39:59.386 A:middle
激动人心的更改

00:40:02.216 --> 00:40:03.786 A:middle
总会导致你们几乎没有

00:40:03.786 --> 00:40:09.176 A:middle
采用优化的 App 的大幅改进

00:40:09.316 --> 00:40:10.956 A:middle
所以 让我们总结

00:40:10.956 --> 00:40:12.316 A:middle
一些提示和技巧

00:40:12.316 --> 00:40:13.266 A:middle
了解如何在完成

00:40:13.306 --> 00:40:14.976 A:middle
所有这些工作后确保你们的 App 令人愉悦

00:40:19.076 --> 00:40:20.276 A:middle
首先 不要让性能

00:40:20.276 --> 00:40:21.546 A:middle
成为事后的想法

00:40:22.326 --> 00:40:24.136 A:middle
你们应该在每个 Bug 

00:40:24.136 --> 00:40:25.566 A:middle
修复的开始

00:40:25.696 --> 00:40:27.036 A:middle
每个参数改动的开始

00:40:27.736 --> 00:40:30.316 A:middle
以及每个功能研发的开始时

00:40:30.316 --> 00:40:30.956 A:middle
考虑并研究它

00:40:32.286 --> 00:40:35.316 A:middle
这是因为 引入回归非常容易

00:40:35.756 --> 00:40:38.216 A:middle
特别是像 2 毫秒这样的小回归

00:40:39.026 --> 00:40:40.616 A:middle
问题是这些小问题

00:40:40.616 --> 00:40:43.026 A:middle
加起来是一个大问题

00:40:43.026 --> 00:40:45.576 A:middle
如果你不立即解决它们

00:40:45.576 --> 00:40:46.336 A:middle
就很难找到它们

00:40:46.336 --> 00:40:49.536 A:middle
为了做到这一点 

00:40:49.536 --> 00:40:51.096 A:middle
为了要检测这些回归

00:40:51.096 --> 00:40:52.926 A:middle
你们应该定期绘制 App 的启动

00:40:52.926 --> 00:40:54.896 A:middle
并定期运行测试

00:40:55.646 --> 00:40:58.016 A:middle
这将确保你们达到目标

00:40:58.016 --> 00:40:59.446 A:middle
并立即知道你们

00:40:59.446 --> 00:41:03.896 A:middle
是否已回归了该目标

00:41:03.986 --> 00:41:05.946 A:middle
你们还应该看看

00:41:05.946 --> 00:41:08.416 A:middle
新的 Xcode 管理器

00:41:08.816 --> 00:41:09.736 A:middle
它可以让你们了解

00:41:09.776 --> 00:41:10.586 A:middle
你们 App 在现场的表现

00:41:11.666 --> 00:41:13.366 A:middle
在 iOS 13 中 对于已选择加入的用户

00:41:13.366 --> 00:41:15.756 A:middle
将收集有关你们 App 的

00:41:15.756 --> 00:41:17.256 A:middle
耗电和性能指标

00:41:18.296 --> 00:41:19.816 A:middle
然后 它们将在

00:41:19.816 --> 00:41:21.456 A:middle
24 小时内汇总

00:41:21.456 --> 00:41:22.886 A:middle
并发送回你们的组织者

00:41:22.886 --> 00:41:25.936 A:middle
你们可以通过软件版本和设备版本 

00:41:25.936 --> 00:41:26.796 A:middle
以直方图的形式查看它们

00:41:28.136 --> 00:41:29.726 A:middle
但是 如果你们希望

00:41:29.726 --> 00:41:31.026 A:middle
对该数据进行更多控制

00:41:31.916 --> 00:41:33.236 A:middle
你们可以采用 MetricKit

00:41:34.636 --> 00:41:36.406 A:middle
MetricKit 允许你们

00:41:36.616 --> 00:41:38.386 A:middle
指定自定义功率和性能指标

00:41:39.886 --> 00:41:41.236 A:middle
现在 与组织者一样

00:41:41.236 --> 00:41:42.486 A:middle
这些数据将在

00:41:42.486 --> 00:41:44.046 A:middle
24 小时内收集和汇总

00:41:44.046 --> 00:41:46.226 A:middle
然后通过你们 App 

00:41:46.266 --> 00:41:49.276 A:middle
中的授权方法 传回给你们

00:41:50.066 --> 00:41:51.186 A:middle
从那里开始 你们就可以

00:41:51.186 --> 00:41:52.686 A:middle
随意处理数据

00:41:53.696 --> 00:41:54.976 A:middle
要了解更多相关信息

00:41:54.976 --> 00:41:55.846 A:middle
我们建议你们查看

00:41:55.996 --> 00:41:57.066 A:middle
2019 年 WWDC 中的

00:41:57.066 --> 00:41:59.846 A:middle
提升电池寿命和性能

00:42:05.756 --> 00:42:07.736 A:middle
我们今天非常开心

00:42:07.736 --> 00:42:09.146 A:middle
通过 Xcode Instruments 中的新

00:42:09.146 --> 00:42:10.596 A:middle
App Lauch 模板开始

00:42:10.596 --> 00:42:11.116 A:middle
了解你们 App 的启动

00:42:11.916 --> 00:42:12.616 A:middle
看看你们是否能

00:42:12.616 --> 00:42:16.816 A:middle
找到最小化 最优排序和

00:42:17.536 --> 00:42:17.626 A:middle
优化你们工作的机会

00:42:18.836 --> 00:42:21.036 A:middle
接下来 虽然意图很好

00:42:21.276 --> 00:42:22.786 A:middle
但并非所有优化都能成功得到

00:42:23.586 --> 00:42:24.596 A:middle
例如 Dan 在他的演示中

00:42:24.596 --> 00:42:26.936 A:middle
提到的预热 DetailView 控制器

00:42:27.936 --> 00:42:30.026 A:middle
因此 每当你们进行更改时

00:42:30.026 --> 00:42:32.596 A:middle
请务必测量而不是

00:42:32.596 --> 00:42:33.406 A:middle
大致估计性能

00:42:34.026 --> 00:42:35.646 A:middle
再说一次 无意中

00:42:35.646 --> 00:42:37.566 A:middle
引入回归 非常容易

00:42:38.956 --> 00:42:40.496 A:middle
最后 你们应该

00:42:40.496 --> 00:42:41.916 A:middle
在开发的所有阶段

00:42:41.916 --> 00:42:42.566 A:middle
跟踪你们的表现

00:42:43.576 --> 00:42:44.696 A:middle
这意味着在各种设备上

00:42:44.696 --> 00:42:48.826 A:middle
使用新的 XCTest App 启动测量

00:42:48.826 --> 00:42:50.156 A:middle
并可能将其与

00:42:50.156 --> 00:42:52.006 A:middle
持续集成相结合

00:42:53.176 --> 00:42:54.216 A:middle
这将确保你们

00:42:54.216 --> 00:42:57.356 A:middle
始终为所有设备上的所有用户

00:42:57.356 --> 00:42:59.546 A:middle
提供令人愉快的 App 启动

00:43:03.896 --> 00:43:04.646 A:middle
请查看我们今天

00:43:04.646 --> 00:43:06.806 A:middle
引用的会议

00:43:06.806 --> 00:43:07.756 A:middle
然后在周五下午

00:43:07.756 --> 00:43:08.806 A:middle
好好休息一下 多谢你们

00:43:09.516 --> 00:43:12.500 A:middle
[掌声]

