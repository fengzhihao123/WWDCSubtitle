WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:00.506 --> 00:00:04.500 A:middle
[音乐]

00:00:07.516 --> 00:00:11.286 A:middle
[掌声]

00:00:11.786 --> 00:00:13.076 A:middle
&gt;&gt; 大家下午好

00:00:13.546 --> 00:00:14.736 A:middle
欢迎来到我们的讲演

00:00:14.736 --> 00:00:15.976 A:middle
自然语言处理

00:00:16.566 --> 00:00:18.266 A:middle
我叫 Vivek 我的同事 

00:00:18.266 --> 00:00:19.656 A:middle
Doug Davidson 会和我一起

00:00:19.656 --> 00:00:20.806 A:middle
完成讲演

00:00:21.646 --> 00:00:23.086 A:middle
我们开始吧

00:00:23.716 --> 00:00:27.796 A:middle
如你所知 文本无处不在 随处可见

00:00:28.436 --> 00:00:29.826 A:middle
用户在 App 中  

00:00:29.826 --> 00:00:31.256 A:middle
和文本交互的模式

00:00:31.906 --> 00:00:34.796 A:middle
主要有两个

00:00:34.796 --> 00:00:36.376 A:middle
一是通过自然语言输入

00:00:36.456 --> 00:00:42.296 A:middle
用户在 App 内写入文本 或生成文本

00:00:43.176 --> 00:00:46.136 A:middle
比如用户可能在 App 里 

00:00:46.136 --> 00:00:48.266 A:middle
用键盘键入文本

00:00:48.526 --> 00:00:49.996 A:middle
这种 App 有很多

00:00:49.996 --> 00:00:51.506 A:middle
比如 《信息》

00:00:51.506 --> 00:00:53.566 A:middle
用户写入文本然后分享给其他人

00:00:53.566 --> 00:00:55.456 A:middle
还有《备忘录》

00:00:55.456 --> 00:00:56.956 A:middle
或者任何效率 App 

00:00:56.956 --> 00:00:58.776 A:middle
部分功能需要你键入文本

00:01:01.136 --> 00:01:03.126 A:middle
和 App 内文本互动的方式

00:01:03.126 --> 00:01:05.626 A:middle
是通过自然语言输出

00:01:06.046 --> 00:01:07.696 A:middle
App 把文本内容

00:01:07.696 --> 00:01:09.126 A:middle
提供给用户

00:01:09.286 --> 00:01:11.706 A:middle
用户使用或者读取这个文本

00:01:12.836 --> 00:01:14.256 A:middle
这类 App 有

00:01:14.436 --> 00:01:17.346 A:middle
比如《新闻》

00:01:17.346 --> 00:01:18.466 A:middle
信息或者文本展示给用户

00:01:18.466 --> 00:01:20.796 A:middle
用户阅读这个信息

00:01:21.666 --> 00:01:24.116 A:middle
所以 不论是文本输入还是输出

00:01:24.226 --> 00:01:26.686 A:middle
为了从原始文本中

00:01:26.686 --> 00:01:28.366 A:middle
提取可操作的情报

00:01:28.546 --> 00:01:30.346 A:middle
自然语言处理

00:01:30.346 --> 00:01:32.146 A:middle
都是非常重要的

00:01:32.146 --> 00:01:34.816 A:middle
去年 我们介绍了

00:01:34.816 --> 00:01:36.086 A:middle
自然语言框架

00:01:36.796 --> 00:01:38.236 A:middle
自然语言框架

00:01:38.406 --> 00:01:41.016 A:middle
是 Apple 所有平台通用的 

00:01:41.016 --> 00:01:42.796 A:middle
可处理所有东西的自然语言处理的主力

00:01:43.406 --> 00:01:44.476 A:middle
所以我们提供了几个

00:01:44.546 --> 00:01:46.256 A:middle
基础的 NLP 模块

00:01:46.696 --> 00:01:48.276 A:middle
比如语言识别

00:01:48.276 --> 00:01:51.666 A:middle
分词 词性标注等等

00:01:51.666 --> 00:01:53.036 A:middle
我们展示了这些基础功能

00:01:53.036 --> 00:01:55.796 A:middle
并跨语种提供这些功能

00:01:55.796 --> 00:01:58.456 A:middle
这是通过无缝融合 

00:01:58.456 --> 00:02:00.156 A:middle
语言学和机器学习实现的

00:02:00.156 --> 00:02:01.516 A:middle
所以你可以只关注  

00:02:01.516 --> 00:02:03.356 A:middle
通过使用这些 API

00:02:03.356 --> 00:02:05.526 A:middle
搭建你的 App

00:02:05.526 --> 00:02:07.706 A:middle
繁重的工作 我们在幕后处理

00:02:08.336 --> 00:02:09.955 A:middle
现在 如果你退一步

00:02:09.955 --> 00:02:11.306 A:middle
看看所有这些功能

00:02:11.536 --> 00:02:13.466 A:middle
实际上 如果你看看

00:02:13.466 --> 00:02:14.936 A:middle
大部分 NLP 功能

00:02:14.936 --> 00:02:16.676 A:middle
它们可以分为

00:02:17.006 --> 00:02:19.176 A:middle
两大类任务

00:02:19.176 --> 00:02:20.936 A:middle
第一类是文本分类

00:02:21.066 --> 00:02:22.796 A:middle
文本分类的目的是

00:02:22.796 --> 00:02:24.866 A:middle
给一个文本

00:02:24.866 --> 00:02:26.286 A:middle
这个文本可以是一个句子

00:02:26.286 --> 00:02:28.266 A:middle
可以是一个段落

00:02:28.266 --> 00:02:30.256 A:middle
或者一个文件

00:02:30.256 --> 00:02:31.566 A:middle
你想向这个文本

00:02:31.566 --> 00:02:33.336 A:middle
分配标签

00:02:33.336 --> 00:02:35.096 A:middle
这些标签可以是情感标签

00:02:35.096 --> 00:02:37.096 A:middle
可以是话题标签 任何你想分配的标签

00:02:38.426 --> 00:02:40.036 A:middle
另一类 NLP 任务被称为

00:02:40.036 --> 00:02:41.696 A:middle
单词标注

00:02:41.696 --> 00:02:43.576 A:middle
这里的任务

00:02:43.576 --> 00:02:45.176 A:middle
或这里的目的是

00:02:45.176 --> 00:02:46.756 A:middle
给一系列词 也被称为 token

00:02:46.756 --> 00:02:48.606 A:middle
我们想给这个序列里的

00:02:48.606 --> 00:02:51.456 A:middle
每个 token 分配一个标签

00:02:51.656 --> 00:02:54.366 A:middle
今年 在文本分类

00:02:54.366 --> 00:02:55.986 A:middle
和单词标记中 

00:02:55.986 --> 00:02:57.776 A:middle
我们都有新的 API

00:02:57.776 --> 00:02:59.646 A:middle
首先 我们先从

00:02:59.646 --> 00:03:01.616 A:middle
情感分析开始

00:03:02.356 --> 00:03:04.016 A:middle
情感分析是一个文本分类 API

00:03:04.016 --> 00:03:05.666 A:middle
这是个新的 API

00:03:05.666 --> 00:03:07.946 A:middle
是这样运作的

00:03:08.536 --> 00:03:09.766 A:middle
你要做的是

00:03:09.766 --> 00:03:11.496 A:middle
把文本传输到这个 API

00:03:11.496 --> 00:03:14.016 A:middle
API 分析文本

00:03:14.046 --> 00:03:15.816 A:middle
给你一个

00:03:15.816 --> 00:03:16.656 A:middle
情感分值

00:03:17.466 --> 00:03:18.666 A:middle
这个情感分值

00:03:18.786 --> 00:03:20.536 A:middle
捕捉文本里的 

00:03:20.536 --> 00:03:21.686 A:middle
情感程度

00:03:22.786 --> 00:03:24.106 A:middle
情感分值

00:03:24.106 --> 00:03:26.626 A:middle
从负一到正一不等

00:03:26.626 --> 00:03:27.516 A:middle
表示情感的程度

00:03:28.216 --> 00:03:29.516 A:middle
比如 -1.0 表明是一个

00:03:29.516 --> 00:03:31.396 A:middle
非常强烈的消极情感

00:03:31.396 --> 00:03:33.256 A:middle
1.0 表明是

00:03:33.256 --> 00:03:34.336 A:middle
非常强烈的积极情感

00:03:34.886 --> 00:03:36.056 A:middle
所以基本上 

00:03:36.056 --> 00:03:37.506 A:middle
我们提供一个分值 

00:03:37.506 --> 00:03:38.846 A:middle
让你为 App 测定分值

00:03:39.036 --> 00:03:41.356 A:middle
举个例子 如果有一句话

00:03:41.356 --> 00:03:42.836 A:middle
比如 我们在夏威夷

00:03:42.836 --> 00:03:44.386 A:middle
和家人玩得很开心

00:03:44.586 --> 00:03:45.946 A:middle
API 可能会给出 0.8 分

00:03:45.946 --> 00:03:48.166 A:middle
表明这句话

00:03:48.166 --> 00:03:50.476 A:middle
是一句积极的句子

00:03:51.616 --> 00:03:52.756 A:middle
相反 如果这句话是

00:03:52.796 --> 00:03:54.266 A:middle
我们在夏威夷玩得不好

00:03:54.266 --> 00:03:55.656 A:middle
因为妈妈扭伤了她的脚踝

00:03:55.656 --> 00:03:57.166 A:middle
这不是一句积极的话

00:03:57.166 --> 00:03:59.156 A:middle
所以你得到 -0.8 分

00:03:59.156 --> 00:04:00.956 A:middle
然后你就可以判定

00:04:00.956 --> 00:04:02.836 A:middle
这是一个消极的情感

00:04:04.126 --> 00:04:05.576 A:middle
非常棒 你怎么用呢

00:04:06.376 --> 00:04:07.676 A:middle
用起来真的很简单

00:04:08.006 --> 00:04:09.646 A:middle
对于你们 习惯使用 

00:04:09.646 --> 00:04:11.036 A:middle
NaturalLanguage 的人

00:04:11.036 --> 00:04:11.886 A:middle
这会非常简单

00:04:12.416 --> 00:04:13.736 A:middle
导入 NaturalLanguage

00:04:14.236 --> 00:04:15.496 A:middle
创建一个实例 NLTagger

00:04:15.536 --> 00:04:17.766 A:middle
现在你做的就是

00:04:17.836 --> 00:04:19.646 A:middle
指定一个新的标签方案

00:04:19.786 --> 00:04:22.456 A:middle
这个标签方案被称为情感分值

00:04:23.266 --> 00:04:25.116 A:middle
然后把想分析的字符串 

00:04:25.116 --> 00:04:26.466 A:middle
附加到 tagger

00:04:26.466 --> 00:04:28.256 A:middle
然后你只需要

00:04:28.256 --> 00:04:29.576 A:middle
在句子层面

00:04:29.906 --> 00:04:32.446 A:middle
或者在段落层面请求情感分值

00:04:33.476 --> 00:04:34.996 A:middle
看一下实际运行情况

00:04:36.316 --> 00:04:37.576 A:middle
这儿有一个

00:04:37.576 --> 00:04:38.516 A:middle
假设 App

00:04:38.876 --> 00:04:40.106 A:middle
它是个奶酪 App

00:04:40.596 --> 00:04:42.766 A:middle
作为这个 App 的一部分

00:04:42.766 --> 00:04:44.246 A:middle
用户可以做很多事情

00:04:44.536 --> 00:04:46.136 A:middle
他们可以写关于奶酪的笔记

00:04:46.416 --> 00:04:47.946 A:middle
他们可以写评价

00:04:47.946 --> 00:04:49.756 A:middle
发表对不同奶酪的看法

00:04:50.176 --> 00:04:51.496 A:middle
尽管这个 App 

00:04:51.496 --> 00:04:53.156 A:middle
是关于奶酪的

00:04:53.156 --> 00:04:56.276 A:middle
但它并不油腻 它处理的是精细的奶酪

00:04:56.656 --> 00:04:57.846 A:middle
我将要为大家展示的是

00:04:57.846 --> 00:05:00.646 A:middle
一个用户在写评价

00:05:01.066 --> 00:05:03.006 A:middle
在他写评价时

00:05:03.006 --> 00:05:05.036 A:middle
文本传送到

00:05:05.036 --> 00:05:06.286 A:middle
情感分类 API

00:05:06.286 --> 00:05:09.246 A:middle
我们得到一个分值

00:05:09.316 --> 00:05:11.416 A:middle
根据情感分值给文本上色

00:05:11.726 --> 00:05:13.646 A:middle
我们看 如果你键入类似

00:05:13.646 --> 00:05:15.496 A:middle
很好 非常美味的评语

00:05:16.336 --> 00:05:19.016 A:middle
你可以看到

00:05:19.016 --> 00:05:20.386 A:middle
这是一个积极的情感

00:05:21.796 --> 00:05:24.886 A:middle
相反 如果你键入

00:05:24.886 --> 00:05:28.306 A:middle
入口还不错

00:05:28.306 --> 00:05:30.296 A:middle
但是后味很糟糕

00:05:30.296 --> 00:05:32.006 A:middle
可以看到这是个消极情感

00:05:32.276 --> 00:05:33.936 A:middle
你可以看到

00:05:33.936 --> 00:05:36.386 A:middle
这些都是实时发生的

00:05:36.746 --> 00:05:38.046 A:middle
这是因为 API 

00:05:38.046 --> 00:05:39.156 A:middle
性能非常出色

00:05:39.556 --> 00:05:41.126 A:middle
它实际使用神经网络模型

00:05:41.126 --> 00:05:43.206 A:middle
所有 Apple 平台上

00:05:43.206 --> 00:05:44.516 A:middle
都激活了硬件

00:05:44.516 --> 00:05:46.336 A:middle
所以基本上

00:05:46.336 --> 00:05:47.616 A:middle
你可以实时做这些

00:05:48.756 --> 00:05:49.846 A:middle
我们支持情感分析 API

00:05:49.846 --> 00:05:51.936 A:middle
用于七种不同的语言

00:05:51.936 --> 00:05:53.966 A:middle
英语 法语

00:05:54.016 --> 00:05:55.596 A:middle
意大利语 德语 西班牙语

00:05:55.636 --> 00:05:57.646 A:middle
葡萄牙语和简体中文

00:05:58.176 --> 00:05:59.436 A:middle
我觉得你们肯定会喜欢这个

00:06:07.046 --> 00:06:08.126 A:middle
当然 所有的这些

00:06:08.126 --> 00:06:09.656 A:middle
都全部发生在设备上

00:06:09.656 --> 00:06:11.536 A:middle
用户数据不需要离开设备

00:06:11.896 --> 00:06:13.786 A:middle
设备本身就能提供这项强大的功能

00:06:14.756 --> 00:06:16.306 A:middle
我想简短地讨论一下

00:06:16.306 --> 00:06:17.926 A:middle
语言素材

00:06:18.296 --> 00:06:19.746 A:middle
我刚才已经提及 

00:06:19.746 --> 00:06:21.246 A:middle
NLP 功能是多种多样的

00:06:21.896 --> 00:06:23.476 A:middle
支持多种

00:06:23.476 --> 00:06:24.646 A:middle
不同的语言

00:06:25.176 --> 00:06:26.186 A:middle
现在 对于用户

00:06:26.186 --> 00:06:28.006 A:middle
我们确保他们能够拥有

00:06:28.006 --> 00:06:29.986 A:middle
自己感兴趣的

00:06:29.986 --> 00:06:31.286 A:middle
语言的素材

00:06:31.856 --> 00:06:33.316 A:middle
但是对于大家来说 

00:06:33.316 --> 00:06:34.686 A:middle
出于开发的目的 

00:06:34.686 --> 00:06:36.846 A:middle
可能对按需素材更感兴趣

00:06:36.846 --> 00:06:39.286 A:middle
实际上 这是大家的一个普遍请求

00:06:39.286 --> 00:06:40.716 A:middle
所以我们要介绍一个

00:06:40.716 --> 00:06:42.746 A:middle
新的便捷 API

00:06:42.746 --> 00:06:44.236 A:middle
叫做请求素材

00:06:44.686 --> 00:06:46.076 A:middle
你可以按照自己的需求

00:06:46.076 --> 00:06:49.216 A:middle
触发一个特定素材的下载

00:06:49.436 --> 00:06:50.896 A:middle
你只需指定

00:06:50.896 --> 00:06:51.836 A:middle
自己喜欢的

00:06:51.836 --> 00:06:53.306 A:middle
语言和标签方案

00:06:53.306 --> 00:06:55.186 A:middle
我们会在后台复刻一个下载

00:06:55.276 --> 00:06:56.476 A:middle
然后你就可以

00:06:56.476 --> 00:06:57.736 A:middle
及时在设备上获取素材

00:06:57.736 --> 00:07:00.226 A:middle
这会帮助你开发 App 

00:07:00.226 --> 00:07:01.866 A:middle
并提高你

00:07:01.866 --> 00:07:03.476 A:middle
搭建 App 的效率

00:07:05.156 --> 00:07:07.226 A:middle
我刚才介绍的是文本分类

00:07:07.226 --> 00:07:09.856 A:middle
现在我们进入单词标记部分

00:07:10.956 --> 00:07:12.486 A:middle
回顾一下

00:07:12.486 --> 00:07:14.616 A:middle
单词标记是一个任务

00:07:14.616 --> 00:07:16.116 A:middle
给定一系列 token  

00:07:16.116 --> 00:07:17.576 A:middle
我们想要给序列中每一个 token

00:07:17.576 --> 00:07:18.896 A:middle
分配标签

00:07:19.086 --> 00:07:21.776 A:middle
就像这个例子

00:07:21.856 --> 00:07:23.056 A:middle
我们可以给许多 token

00:07:23.056 --> 00:07:24.246 A:middle
分配不同的标签

00:07:24.376 --> 00:07:25.546 A:middle
Timothy 是一个人名

00:07:25.546 --> 00:07:27.326 A:middle
瑞士是一个地方

00:07:27.326 --> 00:07:29.366 A:middle
这句话里还有很多名词

00:07:30.466 --> 00:07:31.226 A:middle
很好

00:07:31.226 --> 00:07:32.736 A:middle
如果你只是想用我们的 API

00:07:32.736 --> 00:07:36.346 A:middle
做命名实体识别

00:07:36.346 --> 00:07:39.616 A:middle
或用 API 做词性标注也可以  

00:07:39.616 --> 00:07:43.096 A:middle
但这里还有几个例子 你可以做更适合你任务的东西

00:07:43.826 --> 00:07:46.456 A:middle
你想知道的不仅是格吕耶尔 干酪 是两个名词

00:07:46.816 --> 00:07:48.296 A:middle
你还想知道

00:07:48.296 --> 00:07:50.426 A:middle
它是种瑞士奶酪 我们在搭建一个奶酪 App

00:07:50.426 --> 00:07:53.136 A:middle
你当然想得到这个信息

00:07:53.856 --> 00:07:55.626 A:middle
但是 默认 tagger 

00:07:55.626 --> 00:07:56.696 A:middle
不包含任何关于奶酪的信息

00:07:56.756 --> 00:07:57.966 A:middle
那我们要如何

00:07:57.966 --> 00:07:58.846 A:middle
提供这个信息呢

00:07:59.446 --> 00:08:00.926 A:middle
所以自然语言框架里

00:08:01.336 --> 00:08:02.526 A:middle
有一个新功能

00:08:02.526 --> 00:08:04.366 A:middle
我们称之为文本目录

00:08:05.646 --> 00:08:07.326 A:middle
文本目录非常简单

00:08:07.866 --> 00:08:09.446 A:middle
你只需要提供

00:08:09.446 --> 00:08:11.446 A:middle
一个自定义列表

00:08:11.446 --> 00:08:13.036 A:middle
可能是一个非常大的实体列表

00:08:13.276 --> 00:08:14.546 A:middle
列表中的每一个实体

00:08:14.546 --> 00:08:15.666 A:middle
都有一个标签

00:08:16.556 --> 00:08:18.476 A:middle
实际情况下

00:08:18.476 --> 00:08:20.026 A:middle
这些列表可能是数百万

00:08:20.026 --> 00:08:21.046 A:middle
甚至是几亿

00:08:21.856 --> 00:08:23.416 A:middle
你需要做的是

00:08:23.676 --> 00:08:25.646 A:middle
把这种词库传送到 Create ML

00:08:25.646 --> 00:08:27.596 A:middle
创建一个 MLGazetteer 实例

00:08:27.596 --> 00:08:29.316 A:middle
Gazetteer 只是

00:08:29.316 --> 00:08:30.746 A:middle
文本目录的术语

00:08:31.026 --> 00:08:32.196 A:middle
两个名称可以混用

00:08:32.196 --> 00:08:34.015 A:middle
你得到的输出就是

00:08:34.015 --> 00:08:35.436 A:middle
文本目录

00:08:35.785 --> 00:08:37.145 A:middle
这是输入词库的

00:08:37.216 --> 00:08:40.456 A:middle
非常精简和有效的形式

00:08:41.015 --> 00:08:43.736 A:middle
非常简单

00:08:43.856 --> 00:08:45.486 A:middle
你要做的就是先提供这个词库

00:08:45.486 --> 00:08:46.956 A:middle
我们不能在这里

00:08:46.956 --> 00:08:48.066 A:middle
展现数百万的实例

00:08:48.066 --> 00:08:49.166 A:middle
我们只能用几个实例作例子

00:08:49.166 --> 00:08:50.546 A:middle
但是它可以是

00:08:50.546 --> 00:08:52.086 A:middle
一个非常非常大的词库

00:08:53.406 --> 00:08:54.916 A:middle
然后你就可以

00:08:54.916 --> 00:08:56.946 A:middle
创建 MLGazetteer 实例

00:08:56.946 --> 00:08:59.326 A:middle
传送词库 将它写到磁盘

00:08:59.776 --> 00:09:01.026 A:middle
这一切看起来都没有什么危险 

00:09:01.026 --> 00:09:02.386 A:middle
你可能在想

00:09:02.386 --> 00:09:03.386 A:middle
我只是把词库写到磁盘

00:09:03.386 --> 00:09:04.236 A:middle
这是在做什么

00:09:05.176 --> 00:09:06.866 A:middle
如果你的调用正确

00:09:06.866 --> 00:09:07.896 A:middle
会发生一些神奇的事情

00:09:08.516 --> 00:09:10.536 A:middle
Create ML 在内部调用自然语言

00:09:10.596 --> 00:09:12.246 A:middle
自然语言会把这个

00:09:12.246 --> 00:09:13.916 A:middle
非常大的词库

00:09:13.956 --> 00:09:15.566 A:middle
压缩到一个 

00:09:15.706 --> 00:09:17.306 A:middle
Bloom 过滤器

00:09:17.306 --> 00:09:18.286 A:middle
这是一种非常紧凑的形式

00:09:18.286 --> 00:09:19.946 A:middle
那么你得到的输出

00:09:19.946 --> 00:09:21.586 A:middle
就是文本目录

00:09:22.426 --> 00:09:24.046 A:middle
实际上 我们已经用了这个方法

00:09:24.046 --> 00:09:25.146 A:middle
并达到了效果

00:09:25.146 --> 00:09:27.466 A:middle
我们已经压缩了

00:09:27.876 --> 00:09:29.166 A:middle
维基百科几乎所有的

00:09:29.166 --> 00:09:30.986 A:middle
人名 机构名称 位置 

00:09:30.986 --> 00:09:32.536 A:middle
差不多有 250 万个

00:09:32.536 --> 00:09:33.916 A:middle
压缩到

00:09:34.306 --> 00:09:35.726 A:middle
磁盘上的 2 兆

00:09:36.136 --> 00:09:40.136 A:middle
在某种程度上 你一直在使用这个模型

00:09:40.356 --> 00:09:41.466 A:middle
当你在 NaturalLanguage 里

00:09:41.466 --> 00:09:42.476 A:middle
结合统计模型

00:09:42.476 --> 00:09:44.306 A:middle
调用命名实例识别 API 时

00:09:44.306 --> 00:09:47.146 A:middle
你就在用这个 Bloom 过滤器

00:09:47.146 --> 00:09:48.636 A:middle
和 Gazetteer

00:09:48.636 --> 00:09:51.816 A:middle
现在我们把这个能力给了你

00:09:51.896 --> 00:09:53.906 A:middle
一旦你创建了 Gazetteer 

00:09:53.906 --> 00:09:57.276 A:middle
或文本目录 用起来就会特别简单

00:09:58.116 --> 00:09:59.666 A:middle
通过指定文本目录的路径 

00:09:59.696 --> 00:10:01.376 A:middle
刚才写到磁盘上的文本目录

00:10:01.376 --> 00:10:03.576 A:middle
你创建了一个 

00:10:03.576 --> 00:10:06.616 A:middle
MLGazetteer 实例

00:10:06.616 --> 00:10:08.706 A:middle
你可以在这里用自己喜欢的标签方案

00:10:08.706 --> 00:10:09.826 A:middle
可以是词汇类 名称类型

00:10:09.826 --> 00:10:11.246 A:middle
任何标签方案都可以  

00:10:11.246 --> 00:10:12.836 A:middle
只需要把 Gazetteer

00:10:12.836 --> 00:10:14.756 A:middle
附加到标签方案

00:10:15.636 --> 00:10:17.696 A:middle
然后 每当有一个文本  

00:10:17.696 --> 00:10:19.456 A:middle
这个自定义的 Gazetteer

00:10:19.456 --> 00:10:23.916 A:middle
会覆盖 NaturalLanguage 提供的默认标签

00:10:25.246 --> 00:10:27.526 A:middle
这样 你就可以自定义你的 App

00:10:28.646 --> 00:10:29.456 A:middle
现在 返回奶酪 App

00:10:29.486 --> 00:10:30.876 A:middle
如果有一句话

00:10:30.876 --> 00:10:32.626 A:middle
比如 比卡芒贝尔奶酪

00:10:32.626 --> 00:10:34.196 A:middle
或牛乳奶酪更淡

00:10:34.196 --> 00:10:36.796 A:middle
你可以使用奶酪的文本目录

00:10:36.846 --> 00:10:39.956 A:middle
识别一个是法国奶酪

00:10:39.956 --> 00:10:41.116 A:middle
另一个是瑞士奶酪

00:10:41.116 --> 00:10:42.596 A:middle
你也许可以创建一个超链接

00:10:42.596 --> 00:10:44.076 A:middle
通过这种方式 

00:10:44.076 --> 00:10:46.116 A:middle
制作一个更好的 App

00:10:46.586 --> 00:10:49.306 A:middle
这是一种在 NaturalLanguage 里

00:10:49.306 --> 00:10:51.686 A:middle
使用文字目录

00:10:51.686 --> 00:10:53.066 A:middle
标注单词的方法

00:10:53.626 --> 00:10:57.246 A:middle
我刚才介绍了文本分类

00:10:57.246 --> 00:10:58.676 A:middle
介绍了单词标注

00:10:59.356 --> 00:11:01.086 A:middle
但是近几年 NLP 领域

00:11:01.086 --> 00:11:02.846 A:middle
发生了巨大的变化

00:11:02.846 --> 00:11:04.676 A:middle
有两个催化剂

00:11:04.676 --> 00:11:06.586 A:middle
促成了这一变化 

00:11:07.436 --> 00:11:08.916 A:middle
一是单词嵌入概念

00:11:08.916 --> 00:11:12.006 A:middle
单词嵌入只是单词的

00:11:12.006 --> 00:11:13.206 A:middle
向量表示

00:11:13.206 --> 00:11:15.876 A:middle
另一个是 NLP 里

00:11:15.876 --> 00:11:17.986 A:middle
神经网络的使用

00:11:19.056 --> 00:11:21.056 A:middle
我很高兴地宣布

00:11:21.386 --> 00:11:22.576 A:middle
今年你可以

00:11:22.576 --> 00:11:24.056 A:middle
通过 NaturalLanguage

00:11:24.056 --> 00:11:25.366 A:middle
使用这些功能搭建 App

00:11:25.946 --> 00:11:30.166 A:middle
我们先从单词嵌入开始 谢谢

00:11:31.596 --> 00:11:33.606 A:middle
在我们进入

00:11:33.606 --> 00:11:34.996 A:middle
单词嵌入部分之前

00:11:34.996 --> 00:11:36.426 A:middle
我想通过几张幻灯片

00:11:36.426 --> 00:11:37.726 A:middle
解释一下什么是嵌入

00:11:37.726 --> 00:11:40.336 A:middle
理论层面上 

00:11:40.336 --> 00:11:43.946 A:middle
嵌入只不过是把离散对象集合

00:11:43.946 --> 00:11:45.376 A:middle
映射到持续向量表示

00:11:46.046 --> 00:11:48.026 A:middle
我们有这些离散对象

00:11:48.466 --> 00:11:50.356 A:middle
这个集合里的每个对象

00:11:50.356 --> 00:11:52.536 A:middle
可以用有限向量表示

00:11:52.536 --> 00:11:54.176 A:middle
在这个例子中 我们是用 

00:11:54.176 --> 00:11:55.466 A:middle
3D 向量展示的

00:11:56.146 --> 00:11:57.096 A:middle
用 3D 是因为  

00:11:57.146 --> 00:11:59.236 A:middle
设计和看起来比较容易

00:11:59.236 --> 00:12:01.176 A:middle
但是实际上 这些向量

00:12:01.176 --> 00:12:02.476 A:middle
可以是任意维度 

00:12:02.786 --> 00:12:04.556 A:middle
可以是 100D 300D

00:12:04.556 --> 00:12:05.966 A:middle
甚至在某些情况下

00:12:06.266 --> 00:12:07.656 A:middle
是 1000D 向量

00:12:08.756 --> 00:12:10.146 A:middle
这些嵌入的特性是非常条理

00:12:10.146 --> 00:12:11.926 A:middle
当你要设计

00:12:11.926 --> 00:12:13.326 A:middle
这些嵌入时

00:12:14.176 --> 00:12:15.456 A:middle
语义相似的对象

00:12:15.556 --> 00:12:17.316 A:middle
会聚在一起

00:12:18.446 --> 00:12:19.976 A:middle
在这个例子中

00:12:19.976 --> 00:12:21.306 A:middle
油漆罐和油漆刷

00:12:21.306 --> 00:12:23.246 A:middle
聚在了一起

00:12:24.376 --> 00:12:28.276 A:middle
运动鞋 和高跟鞋聚在了一起

00:12:28.716 --> 00:12:30.896 A:middle
所以 嵌入的特性非常条理

00:12:31.096 --> 00:12:33.086 A:middle
嵌入的这个特性

00:12:33.086 --> 00:12:34.806 A:middle
不仅可以用于单词

00:12:34.806 --> 00:12:36.046 A:middle
实际上还可用于

00:12:36.046 --> 00:12:37.126 A:middle
不同的形式

00:12:37.646 --> 00:12:39.066 A:middle
可以是图片嵌入

00:12:39.166 --> 00:12:40.826 A:middle
当你有一张图片 

00:12:40.826 --> 00:12:42.876 A:middle
通过 VGG 网络

00:12:42.876 --> 00:12:43.946 A:middle
或者任何卷积神经网络传输时

00:12:43.946 --> 00:12:45.456 A:middle
你得到的输出

00:12:45.456 --> 00:12:48.046 A:middle
就是这个特性图像嵌入

00:12:48.986 --> 00:12:51.696 A:middle
同样 你可以嵌入单词 短语 

00:12:51.696 --> 00:12:54.016 A:middle
当你在做推荐系统时

00:12:54.016 --> 00:12:55.676 A:middle
里面有歌曲名 

00:12:55.676 --> 00:12:57.136 A:middle
或者产品名

00:12:57.136 --> 00:13:00.076 A:middle
他们都是通过向量表示的

00:13:00.526 --> 00:13:02.066 A:middle
所以 它们只是嵌入

00:13:02.926 --> 00:13:04.326 A:middle
总的来说

00:13:04.326 --> 00:13:06.506 A:middle
嵌入只是将字符串  

00:13:06.506 --> 00:13:08.376 A:middle
映射到持续的数字序列

00:13:08.376 --> 00:13:10.556 A:middle
或者数字向量

00:13:11.076 --> 00:13:15.026 A:middle
我们已经在 iOS 12 里

00:13:15.066 --> 00:13:16.836 A:middle
非常成功地使用了这些嵌入

00:13:16.836 --> 00:13:18.656 A:middle
我将向大家介绍

00:13:18.656 --> 00:13:19.836 A:middle
如何在照片中使用嵌入

00:13:21.226 --> 00:13:23.236 A:middle
在照片搜索中

00:13:23.316 --> 00:13:24.426 A:middle
当你输入一个想查找的词时

00:13:24.426 --> 00:13:26.366 A:middle
比如说 雷雨的照片

00:13:26.416 --> 00:13:28.506 A:middle
在屏幕下面

00:13:28.506 --> 00:13:29.936 A:middle
照片库里的所有照片

00:13:29.936 --> 00:13:33.626 A:middle
都通过卷积神经网络编了索引

00:13:33.626 --> 00:13:35.106 A:middle
卷积神经网络的输出

00:13:35.106 --> 00:13:36.466 A:middle
固定在一定数量的类上

00:13:36.466 --> 00:13:37.696 A:middle
可能是 1000 个类

00:13:37.696 --> 00:13:40.556 A:middle
也可能是 2000 个类

00:13:41.426 --> 00:13:42.406 A:middle
如果你的卷积神经网络  

00:13:42.406 --> 00:13:43.666 A:middle
不知道雷雨是什么 

00:13:43.666 --> 00:13:45.506 A:middle
那么你永远无法找到

00:13:45.506 --> 00:13:46.716 A:middle
雷雨的索引照片

00:13:46.716 --> 00:13:48.476 A:middle
因为不知道雷雨这个单词

00:13:48.476 --> 00:13:50.396 A:middle
但是因为有单词嵌入

00:13:50.396 --> 00:13:55.076 A:middle
我们知道雷雨和天空多云相关

00:13:55.076 --> 00:13:56.986 A:middle
这些标签

00:13:57.876 --> 00:13:59.996 A:middle
你的卷积神经网络是明白的

00:14:02.266 --> 00:14:04.366 A:middle
你可以使用单词嵌入

00:14:04.366 --> 00:14:07.076 A:middle
在照片搜索中实现模糊搜索

00:14:07.706 --> 00:14:09.396 A:middle
所以 通过单词嵌入  

00:14:09.666 --> 00:14:11.676 A:middle
你可以找到

00:14:11.676 --> 00:14:12.876 A:middle
自己想找的照片

00:14:12.876 --> 00:14:14.006 A:middle
实际上 它可以应用到 

00:14:14.006 --> 00:14:15.216 A:middle
所有的搜索 App

00:14:15.466 --> 00:14:16.716 A:middle
如果你有一串字符 

00:14:16.716 --> 00:14:18.226 A:middle
你想模糊搜索

00:14:18.226 --> 00:14:19.426 A:middle
你可以关联原单词

00:14:19.426 --> 00:14:21.946 A:middle
和与其相近的单词

00:14:22.656 --> 00:14:24.826 A:middle
说到这儿 你可以用嵌入

00:14:24.826 --> 00:14:25.846 A:middle
做些什么呢

00:14:26.676 --> 00:14:27.696 A:middle
你可以用单词嵌入

00:14:27.696 --> 00:14:29.716 A:middle
进行 4 项基本操作

00:14:30.556 --> 00:14:32.486 A:middle
一是 你可以得到

00:14:32.716 --> 00:14:34.466 A:middle
一个单词的向量

00:14:35.576 --> 00:14:37.486 A:middle
二是 如果有两个单词

00:14:37.486 --> 00:14:38.716 A:middle
你可以找到两个词的距离

00:14:39.116 --> 00:14:40.356 A:middle
因为你可以查看 

00:14:40.356 --> 00:14:41.156 A:middle
每个单词的

00:14:41.156 --> 00:14:42.356 A:middle
对应向量

00:14:42.616 --> 00:14:44.446 A:middle
比如说 猫和狗

00:14:44.446 --> 00:14:45.576 A:middle
如果我想得到这两个词

00:14:45.576 --> 00:14:46.816 A:middle
之间的距离

00:14:46.816 --> 00:14:47.866 A:middle
那么这个距离

00:14:47.866 --> 00:14:48.996 A:middle
应该挺近的

00:14:49.886 --> 00:14:51.976 A:middle
但如果是 狗和靴子

00:14:51.976 --> 00:14:53.706 A:middle
那么在语义场内 

00:14:53.706 --> 00:14:55.246 A:middle
它们距离应该挺远

00:14:55.246 --> 00:14:57.366 A:middle
那么你会得到更远一些的距离

00:14:58.546 --> 00:14:59.696 A:middle
三是 你可以得到 

00:14:59.696 --> 00:15:01.086 A:middle
和某个单词最相近的词

00:15:01.086 --> 00:15:02.916 A:middle
这应该是到目前为止

00:15:02.916 --> 00:15:04.676 A:middle
对于单词嵌入 

00:15:04.676 --> 00:15:06.106 A:middle
最流行的用法

00:15:06.106 --> 00:15:07.516 A:middle
我刚才展示的照片搜索 App

00:15:07.516 --> 00:15:10.236 A:middle
正是在做这个

00:15:10.236 --> 00:15:12.936 A:middle
寻找和某个单词最相近的单词

00:15:12.936 --> 00:15:15.836 A:middle
最后一点是

00:15:15.836 --> 00:15:19.376 A:middle
你可以得到一个向量的最近邻居

00:15:19.376 --> 00:15:20.776 A:middle
假设你有一个句子

00:15:20.836 --> 00:15:22.116 A:middle
句子里有好几个单词

00:15:22.116 --> 00:15:23.726 A:middle
句子里每一个单词

00:15:23.726 --> 00:15:25.176 A:middle
都可以得到一个单词嵌入

00:15:25.176 --> 00:15:26.276 A:middle
你可以把它们

00:15:26.326 --> 00:15:27.516 A:middle
总结起来

00:15:27.516 --> 00:15:28.886 A:middle
这样你会得到一个新的向量

00:15:28.886 --> 00:15:31.036 A:middle
有了这个向量

00:15:31.036 --> 00:15:32.466 A:middle
你就可以得到

00:15:32.466 --> 00:15:33.266 A:middle
所有和这个向量相近的单词

00:15:33.266 --> 00:15:35.576 A:middle
这也是一种应用单词嵌入的方法

00:15:35.576 --> 00:15:38.186 A:middle
单词嵌入内容很多 

00:15:38.186 --> 00:15:39.396 A:middle
但是最重要的是   

00:15:39.396 --> 00:15:40.476 A:middle
我们为你提供了这个功能

00:15:40.476 --> 00:15:42.436 A:middle
你可以在 OS 上

00:15:42.436 --> 00:15:43.786 A:middle
便捷地使用它

00:15:44.076 --> 00:15:45.326 A:middle
很高兴告诉大家

00:15:45.456 --> 00:15:46.906 A:middle
这些单词嵌入

00:15:46.906 --> 00:15:48.396 A:middle
支持 7 种语言

00:15:48.396 --> 00:15:51.426 A:middle
我刚才提到的所有功能

00:15:51.456 --> 00:15:53.366 A:middle
都只需要一两行代码

00:15:53.496 --> 00:15:54.946 A:middle
就可以实现

00:15:55.386 --> 00:15:56.686 A:middle
单词嵌入支持 7 种语言

00:15:56.686 --> 00:15:58.406 A:middle
英语 西班牙语

00:15:58.406 --> 00:15:59.686 A:middle
法语 意大利语 德语

00:15:59.766 --> 00:16:01.706 A:middle
葡萄牙语和简体中文

00:16:02.986 --> 00:16:04.146 A:middle
非常棒

00:16:04.146 --> 00:16:05.546 A:middle
OS 嵌入通常是在

00:16:05.626 --> 00:16:07.536 A:middle
通用语料库上构建的

00:16:07.536 --> 00:16:09.866 A:middle
文本数量庞大 有数亿单词

00:16:10.406 --> 00:16:11.936 A:middle
所以他们对于

00:16:12.056 --> 00:16:14.126 A:middle
某个词和其他词的关系

00:16:14.126 --> 00:16:15.156 A:middle
有一个大致概念

00:16:15.876 --> 00:16:17.226 A:middle
但是很多时候

00:16:17.226 --> 00:16:18.216 A:middle
你想做一些更自定义的事

00:16:19.846 --> 00:16:21.016 A:middle
也许你活跃在

00:16:21.216 --> 00:16:22.366 A:middle
不同的领域

00:16:22.926 --> 00:16:25.566 A:middle
医药领域 法律领域

00:16:25.566 --> 00:16:26.316 A:middle
或金融领域

00:16:27.046 --> 00:16:28.286 A:middle
如果你的领域各不相同

00:16:28.286 --> 00:16:30.316 A:middle
那么你想在 App 中

00:16:30.316 --> 00:16:31.916 A:middle
使用的词汇

00:16:31.916 --> 00:16:33.076 A:middle
会非常不同

00:16:33.076 --> 00:16:34.806 A:middle
也许你只是想  

00:16:34.806 --> 00:16:36.076 A:middle
让一个 OS 不支持的语言

00:16:36.076 --> 00:16:37.426 A:middle
实现单词嵌入

00:16:37.426 --> 00:16:40.886 A:middle
你应该怎么做呢

00:16:40.886 --> 00:16:42.466 A:middle
我们对此也有准备 

00:16:43.366 --> 00:16:45.786 A:middle
你可以使用自定义单词嵌入

00:16:46.506 --> 00:16:47.246 A:middle
对于熟悉单词嵌入

00:16:47.246 --> 00:16:50.166 A:middle
见证这个领域发展的人

00:16:50.166 --> 00:16:51.856 A:middle
有许多第三方工具

00:16:51.856 --> 00:16:53.576 A:middle
可以训练自定义嵌入

00:16:53.576 --> 00:16:55.866 A:middle
比如 word2vec GloVe fasttext

00:16:56.366 --> 00:16:57.906 A:middle
所以 你可以用自己的文本

00:16:58.306 --> 00:16:59.666 A:middle
也可以用自己在 

00:16:59.666 --> 00:17:01.726 A:middle
Keras TensorFlow 或 PyTorch

00:17:01.726 --> 00:17:01.793 A:middle
训练的自定义神经网络

00:17:01.793 --> 00:17:04.756 A:middle
你可以通过原始文本

00:17:04.756 --> 00:17:06.756 A:middle
创建自己的嵌入

00:17:06.756 --> 00:17:07.935 A:middle
你也可以从任一网站

00:17:07.935 --> 00:17:09.256 A:middle
下载它们训练好的

00:17:09.256 --> 00:17:10.526 A:middle
单词嵌入

00:17:11.205 --> 00:17:14.185 A:middle
问题是 你要下载的这些嵌入

00:17:14.185 --> 00:17:15.866 A:middle
体积非常非常大

00:17:16.256 --> 00:17:18.306 A:middle
1GB 或 2GB 那么大

00:17:18.695 --> 00:17:19.826 A:middle
但是你想非常精简有效地

00:17:19.826 --> 00:17:20.896 A:middle
在你的 App 中使用它们

00:17:20.896 --> 00:17:23.266 A:middle
我们实现了这一点

00:17:23.266 --> 00:17:26.915 A:middle
这些来自第三方 App 的嵌入

00:17:26.915 --> 00:17:28.406 A:middle
体积非常大

00:17:28.406 --> 00:17:30.076 A:middle
我们自动将它们

00:17:30.076 --> 00:17:32.296 A:middle
压缩成非常紧凑的格式

00:17:32.296 --> 00:17:33.576 A:middle
有了这个格式

00:17:33.746 --> 00:17:35.446 A:middle
你就可以像用 OS 嵌入一样

00:17:35.446 --> 00:17:36.716 A:middle
使用它们了

00:17:37.436 --> 00:17:38.666 A:middle
接下来将由 Doug    

00:17:38.666 --> 00:17:40.206 A:middle
为大家介绍

00:17:40.206 --> 00:17:41.746 A:middle
如何使用 OS 嵌入

00:17:41.746 --> 00:17:42.836 A:middle
和自定义嵌入

00:17:42.936 --> 00:17:45.666 A:middle
他会给大家做个示范

00:17:45.666 --> 00:17:46.786 A:middle
后半段的讲演交给他了

00:17:47.426 --> 00:17:48.066 A:middle
轮到你了 Doug

00:17:49.516 --> 00:17:55.836 A:middle
[掌声]

00:17:56.336 --> 00:17:57.036 A:middle
&gt;&gt; 好的

00:17:57.036 --> 00:17:58.196 A:middle
我将通过一个演示 App

00:17:58.196 --> 00:18:00.066 A:middle
向大家展示运行起来 

00:18:00.066 --> 00:18:00.976 A:middle
是什么样的

00:18:01.656 --> 00:18:02.986 A:middle
首先 我写了个

00:18:02.986 --> 00:18:04.796 A:middle
非常小的演示 App 

00:18:04.796 --> 00:18:06.496 A:middle
帮助大家理解

00:18:06.496 --> 00:18:08.566 A:middle
单词嵌入

00:18:08.606 --> 00:18:10.456 A:middle
在这儿键入一个单词

00:18:10.456 --> 00:18:11.636 A:middle
它会显示最近的邻居

00:18:11.636 --> 00:18:13.676 A:middle
嵌入空间内 

00:18:13.676 --> 00:18:15.296 A:middle
离那个单词最近的邻居

00:18:15.636 --> 00:18:16.826 A:middle
我们先从英语开始

00:18:16.826 --> 00:18:19.456 A:middle
使用内置 OS 单词嵌入 

00:18:19.806 --> 00:18:21.466 A:middle
我键入一个单词 比如椅子

00:18:21.666 --> 00:18:23.076 A:middle
可以看到  

00:18:23.076 --> 00:18:24.476 A:middle
它的邻居都是

00:18:24.476 --> 00:18:25.886 A:middle
意思和它相近的单词

00:18:25.886 --> 00:18:28.246 A:middle
椅子 沙发 长榻 等等

00:18:28.246 --> 00:18:31.116 A:middle
我也可以键入自行车

00:18:31.796 --> 00:18:33.466 A:middle
最近的邻居是

00:18:33.466 --> 00:18:34.666 A:middle
自行车 摩托车 等等

00:18:34.666 --> 00:18:36.166 A:middle
这些单词意思

00:18:36.166 --> 00:18:39.596 A:middle
和自行车相近

00:18:40.406 --> 00:18:42.576 A:middle
我也可以键入 书 就能得到和书意思相近的词

00:18:43.026 --> 00:18:44.616 A:middle
从这里 我们可以看出

00:18:44.936 --> 00:18:46.746 A:middle
内置 OS 单词嵌入

00:18:46.746 --> 00:18:48.316 A:middle
显示原本的  

00:18:48.716 --> 00:18:50.826 A:middle
词义和语言

00:18:50.826 --> 00:18:54.736 A:middle
并识别出该语言在

00:18:54.776 --> 00:18:59.206 A:middle
通用文本里相近的意思

00:19:02.596 --> 00:19:04.686 A:middle
这里我最感兴趣的是

00:19:05.066 --> 00:19:06.216 A:middle
这些嵌入 

00:19:06.216 --> 00:19:08.916 A:middle
和奶酪有什么关系

00:19:08.916 --> 00:19:09.976 A:middle
毕竟我们做的是

00:19:09.976 --> 00:19:10.726 A:middle
奶酪 App

00:19:11.426 --> 00:19:13.246 A:middle
所以 我们键入一个 奶酪 单词

00:19:14.556 --> 00:19:16.156 A:middle
看一下这里

00:19:16.156 --> 00:19:18.996 A:middle
你立刻就能看到

00:19:18.996 --> 00:19:21.446 A:middle
内置嵌入知道奶酪是什么

00:19:21.446 --> 00:19:24.506 A:middle
但是我很失望

00:19:24.966 --> 00:19:26.196 A:middle
这些嵌入只知道奶酪 

00:19:26.196 --> 00:19:28.206 A:middle
但不了解任何细节

00:19:29.406 --> 00:19:31.086 A:middle
否则 他们就不会把这些特殊的奶酪

00:19:31.086 --> 00:19:32.796 A:middle
和奶酪相关的东西

00:19:32.796 --> 00:19:34.086 A:middle
放在一起

00:19:34.086 --> 00:19:35.436 A:middle
它们不应该放在一起

00:19:36.236 --> 00:19:37.706 A:middle
我想要的效果是 

00:19:37.706 --> 00:19:39.136 A:middle
它能明白 

00:19:39.136 --> 00:19:40.486 A:middle
奶酪之间的关系

00:19:40.776 --> 00:19:42.046 A:middle
所以 我就趁机训练  

00:19:42.046 --> 00:19:44.316 A:middle
我自己的自定义奶酪嵌入

00:19:44.316 --> 00:19:46.446 A:middle
它会基于相似性

00:19:46.446 --> 00:19:48.016 A:middle
把奶酪放在一起

00:19:48.936 --> 00:19:50.116 A:middle
切换到自定义嵌入

00:19:51.436 --> 00:19:52.616 A:middle
这些是自定义奶酪嵌入里的 

00:19:52.616 --> 00:19:54.716 A:middle
切德干酪的邻居

00:19:54.966 --> 00:19:55.806 A:middle
这样就好多了

00:19:56.586 --> 00:19:57.786 A:middle
可以看到 它把 

00:19:57.786 --> 00:19:59.646 A:middle
和切德干酪

00:20:01.596 --> 00:20:03.446 A:middle
放在了一起

00:20:03.446 --> 00:20:05.676 A:middle
比如 兰开夏奶酪 格洛斯特硬干酪和柴郡白干酪

00:20:06.666 --> 00:20:07.826 A:middle
这是我们可以用在

00:20:07.826 --> 00:20:09.356 A:middle
App 里的东西

00:20:09.946 --> 00:20:10.896 A:middle
现在 我们再来看一下

00:20:10.896 --> 00:20:12.886 A:middle
奶酪 App 是什么样的

00:20:15.426 --> 00:20:16.476 A:middle
我在这个奶酪 App 上 

00:20:16.476 --> 00:20:18.266 A:middle
尝试了一些想法

00:20:18.266 --> 00:20:20.676 A:middle
看一下现在它的样子

00:20:21.226 --> 00:20:22.276 A:middle
当用户键入时

00:20:22.276 --> 00:20:23.406 A:middle
首先我会得到 

00:20:23.406 --> 00:20:25.486 A:middle
一个情感分值

00:20:25.486 --> 00:20:27.826 A:middle
看一下这是否是一句

00:20:27.826 --> 00:20:30.066 A:middle
积极情感的话

00:20:30.066 --> 00:20:31.446 A:middle
如果是的话 

00:20:31.446 --> 00:20:34.146 A:middle
我会用我的标注 

00:20:34.146 --> 00:20:35.436 A:middle
检查一下这句话

00:20:35.436 --> 00:20:39.156 A:middle
当然 也会用我们的

00:20:39.156 --> 00:20:41.776 A:middle
自定义奶酪 Gazetteer

00:20:41.776 --> 00:20:44.656 A:middle
查看这句话里有没有提到什么奶酪

00:20:45.356 --> 00:20:47.076 A:middle
我在找有没有提及奶酪

00:20:47.126 --> 00:20:48.826 A:middle
如果用户真的提及了

00:20:48.826 --> 00:20:50.736 A:middle
我就会把这个名字  

00:20:50.736 --> 00:20:52.296 A:middle
传送到自定义奶酪嵌入

00:20:52.296 --> 00:20:56.366 A:middle
查找相关奶酪

00:20:57.426 --> 00:20:58.336 A:middle
听起来挺好的吧

00:20:58.336 --> 00:21:01.386 A:middle
我们试一下

00:21:01.656 --> 00:21:02.726 A:middle
调出我们的奶酪 App

00:21:02.726 --> 00:21:08.816 A:middle
去年我去荷兰旅游

00:21:08.816 --> 00:21:10.136 A:middle
然后我爱上了

00:21:10.136 --> 00:21:11.796 A:middle
荷兰奶酪

00:21:11.796 --> 00:21:16.986 A:middle
我将把这个告诉我的 App

00:21:16.986 --> 00:21:19.616 A:middle
这肯定是一句

00:21:19.616 --> 00:21:20.686 A:middle
情感积极的话

00:21:20.686 --> 00:21:22.716 A:middle
而且确实提及了

00:21:22.716 --> 00:21:24.006 A:middle
一种特定的奶酪

00:21:24.416 --> 00:21:27.586 A:middle
然后我的 App 

00:21:27.876 --> 00:21:29.336 A:middle
就可以为我推荐

00:21:29.336 --> 00:21:31.216 A:middle
和我刚才提到的奶酪

00:21:31.216 --> 00:21:32.296 A:middle
相似的奶酪

00:21:33.376 --> 00:21:35.186 A:middle
这展示了单词嵌入的功能

00:21:35.226 --> 00:21:36.946 A:middle
不仅如此

00:21:36.946 --> 00:21:39.166 A:middle
它还展示了自然的 多变的

00:21:39.166 --> 00:21:40.626 A:middle
NaturalLanguage API

00:21:40.626 --> 00:21:43.566 A:middle
是如何和 App 功能 

00:21:43.566 --> 00:21:44.906 A:middle
结合到一起的

00:21:46.516 --> 00:21:50.736 A:middle
[掌声]

00:21:51.236 --> 00:21:52.656 A:middle
现在我们退回幻灯片

00:21:52.656 --> 00:21:54.976 A:middle
我想要简单的回顾一下

00:21:54.976 --> 00:21:57.496 A:middle
在 API 中 这个是什么样子的

00:21:58.466 --> 00:22:00.546 A:middle
如果你想要用

00:22:00.666 --> 00:22:02.926 A:middle
内置的 OS 单词嵌入

00:22:02.926 --> 00:22:04.996 A:middle
非常简单 你要做的就是请求

00:22:05.206 --> 00:22:06.696 A:middle
请求某个特定语言的

00:22:06.696 --> 00:22:07.876 A:middle
单词嵌入

00:22:07.876 --> 00:22:08.346 A:middle
我们就会给你

00:22:08.346 --> 00:22:10.976 A:middle
一旦你有了这些 

00:22:10.976 --> 00:22:12.766 A:middle
NLEmbedding 对象的其中一个

00:22:12.766 --> 00:22:14.106 A:middle
你就可以用它做很多事情

00:22:14.536 --> 00:22:16.886 A:middle
当然 你可以得到组件 向量组件

00:22:16.886 --> 00:22:19.856 A:middle
和任何特定目录相对应

00:22:21.136 --> 00:22:22.476 A:middle
你可以得到在嵌入空间中

00:22:22.476 --> 00:22:24.326 A:middle
两个单词之间的距离

00:22:24.326 --> 00:22:26.436 A:middle
是近还是远

00:22:27.346 --> 00:22:28.936 A:middle
正如在奶酪 App 里所见

00:22:28.936 --> 00:22:30.676 A:middle
你可以浏览 

00:22:30.676 --> 00:22:32.166 A:middle
找到在这个嵌入空间内

00:22:32.596 --> 00:22:35.296 A:middle
任何特定名称

00:22:35.426 --> 00:22:37.186 A:middle
最近的邻居

00:22:37.796 --> 00:22:40.436 A:middle
如果你想用自定义单词嵌入

00:22:40.436 --> 00:22:43.346 A:middle
要创建它

00:22:43.346 --> 00:22:46.496 A:middle
你可以用 Create ML

00:22:46.546 --> 00:22:48.486 A:middle
当然你需要

00:22:48.486 --> 00:22:50.846 A:middle
所有表示嵌入的向量

00:22:51.186 --> 00:22:52.596 A:middle
我不能在这里 通过幻灯片 

00:22:52.596 --> 00:22:53.986 A:middle
向大家展示所有的向量

00:22:53.986 --> 00:22:55.536 A:middle
因为他们有 50

00:22:55.856 --> 00:22:57.736 A:middle
或者 100 个组件那么长

00:22:57.736 --> 00:22:59.906 A:middle
但是这儿有一个例子

00:22:59.906 --> 00:23:01.146 A:middle
在实际操作中

00:23:01.176 --> 00:23:02.396 A:middle
你可能从一个文件中引入它们

00:23:02.396 --> 00:23:04.486 A:middle
使用各种 Create ML 工具

00:23:04.486 --> 00:23:06.656 A:middle
从文件中

00:23:06.656 --> 00:23:07.746 A:middle
加载数据

00:23:08.076 --> 00:23:12.476 A:middle
然后你就可以从中

00:23:12.476 --> 00:23:15.336 A:middle
创建一个单词嵌入对象

00:23:15.336 --> 00:23:16.376 A:middle
将它写到磁盘上

00:23:16.376 --> 00:23:18.376 A:middle
这么做时 发生了什么呢

00:23:19.036 --> 00:23:22.256 A:middle
在实际操作中

00:23:22.256 --> 00:23:23.796 A:middle
这些嵌入一般会比较大

00:23:23.796 --> 00:23:25.936 A:middle
数百维

00:23:25.936 --> 00:23:27.206 A:middle
乘以数千个条目

00:23:27.206 --> 00:23:30.066 A:middle
体积会很大

00:23:30.066 --> 00:23:32.206 A:middle
会占用很多磁盘空间

00:23:32.776 --> 00:23:35.286 A:middle
搜索就会比较贵

00:23:35.856 --> 00:23:38.336 A:middle
当你把它们  

00:23:38.336 --> 00:23:41.416 A:middle
编译进单词嵌入对象时

00:23:41.416 --> 00:23:43.836 A:middle
在内部 我们做的是

00:23:43.836 --> 00:23:46.346 A:middle
用产品量化技术

00:23:46.346 --> 00:23:47.906 A:middle
实现很高程度的压缩

00:23:47.906 --> 00:23:50.856 A:middle
然后添加索引

00:23:50.856 --> 00:23:53.336 A:middle
这样你就可以快速搜索

00:23:53.506 --> 00:23:55.456 A:middle
最近的邻居

00:23:55.456 --> 00:23:56.926 A:middle
就像我们的示范一样

00:23:57.606 --> 00:24:00.926 A:middle
来试一下 我们有一些

00:24:00.926 --> 00:24:04.256 A:middle
开源的 非常大的嵌入

00:24:04.446 --> 00:24:06.916 A:middle
这些是 GloVe 和 fasttext 嵌入

00:24:06.916 --> 00:24:08.876 A:middle
未压缩的格式

00:24:08.876 --> 00:24:11.046 A:middle
有 1GB 或 2GB 大

00:24:11.686 --> 00:24:13.956 A:middle
当我们把它压缩成 

00:24:13.956 --> 00:24:15.606 A:middle
NL 压缩格式时

00:24:16.206 --> 00:24:17.736 A:middle
它们只有几十兆

00:24:18.136 --> 00:24:19.086 A:middle
只需要几毫秒

00:24:19.086 --> 00:24:20.146 A:middle
你就可以搜索到

00:24:20.146 --> 00:24:21.176 A:middle
离它们最近的邻居

00:24:23.056 --> 00:24:23.976 A:middle
有个 Apple 的例子

00:24:24.516 --> 00:24:27.716 A:middle
[掌声]

00:24:28.216 --> 00:24:30.146 A:middle
有个 Apple 的例子

00:24:30.266 --> 00:24:32.406 A:middle
Apple 做了许多播客

00:24:32.536 --> 00:24:34.516 A:middle
我们和播客团队

00:24:34.516 --> 00:24:36.616 A:middle
交流了一下

00:24:36.616 --> 00:24:38.226 A:middle
他们有一个

00:24:38.226 --> 00:24:40.426 A:middle
为播客制作的嵌入

00:24:40.426 --> 00:24:43.686 A:middle
表示各种播客之间的相似性

00:24:44.346 --> 00:24:46.196 A:middle
所以我们想试一下

00:24:46.226 --> 00:24:48.186 A:middle
看看把这个嵌入

00:24:48.186 --> 00:24:49.886 A:middle
做成 NL 嵌入格式

00:24:49.886 --> 00:24:51.826 A:middle
会发生什么

00:24:52.456 --> 00:24:54.156 A:middle
这个嵌入代表

00:24:54.156 --> 00:24:57.466 A:middle
66,000 个不同的播客

00:24:57.466 --> 00:24:59.486 A:middle
原格式有 167MB

00:24:59.526 --> 00:25:00.906 A:middle
但是我们压缩了它

00:25:00.906 --> 00:25:02.976 A:middle
现在只占 3MB

00:25:03.326 --> 00:25:05.716 A:middle
NL 嵌入的功能就是

00:25:05.716 --> 00:25:08.246 A:middle
添加这些嵌入

00:25:08.246 --> 00:25:10.376 A:middle
在你的 App 里

00:25:11.036 --> 00:25:13.236 A:middle
设备上使用它们

00:25:16.716 --> 00:25:19.716 A:middle
好的 接下来我想换一个话题

00:25:19.716 --> 00:25:22.646 A:middle
介绍另一个

00:25:22.646 --> 00:25:24.976 A:middle
和单词嵌入相关的东西

00:25:24.976 --> 00:25:28.036 A:middle
那就是文本分类的迁移学习

00:25:29.356 --> 00:25:31.886 A:middle
我想先谈一下

00:25:31.886 --> 00:25:33.516 A:middle
我们是如何

00:25:33.516 --> 00:25:37.936 A:middle
训练文本分类的

00:25:39.176 --> 00:25:40.886 A:middle
在我们训练文本分类时

00:25:40.886 --> 00:25:44.076 A:middle
我们给他一系列

00:25:44.076 --> 00:25:47.096 A:middle
各种类的例子

00:25:47.636 --> 00:25:50.826 A:middle
把这些数据传送给 Create ML

00:25:50.826 --> 00:25:52.946 A:middle
Create ML 会调用自然语言

00:25:53.506 --> 00:25:55.766 A:middle
训练分类器

00:25:55.876 --> 00:25:58.136 A:middle
生成一个 Core ML 模型

00:25:58.506 --> 00:26:00.686 A:middle
我们希望

00:26:00.686 --> 00:26:04.256 A:middle
这些例子会充分提供

00:26:04.576 --> 00:26:06.626 A:middle
关于各类的信息

00:26:06.686 --> 00:26:08.546 A:middle
这样模型就可以概括

00:26:08.546 --> 00:26:11.916 A:middle
分类它没有

00:26:11.916 --> 00:26:12.926 A:middle
见过的例子

00:26:13.406 --> 00:26:15.126 A:middle
当然 去年

00:26:15.366 --> 00:26:17.786 A:middle
这个功能已经上市了

00:26:17.786 --> 00:26:20.566 A:middle
我们有训练这些模型的算法

00:26:20.566 --> 00:26:23.136 A:middle
最出名的是

00:26:23.136 --> 00:26:24.846 A:middle
我们的标准算法 

00:26:24.846 --> 00:26:26.926 A:middle
我们称之为 maxEnt 算法

00:26:26.926 --> 00:26:27.966 A:middle
它基于逻辑压缩

00:26:28.336 --> 00:26:30.816 A:middle
快速 强大 有效

00:26:31.666 --> 00:26:35.126 A:middle
但是有一个问题

00:26:35.126 --> 00:26:36.876 A:middle
除了你给的

00:26:36.876 --> 00:26:39.076 A:middle
训练资料外

00:26:39.076 --> 00:26:41.846 A:middle
它不知道其他的东西

00:26:42.116 --> 00:26:45.566 A:middle
这样你就要确保

00:26:45.566 --> 00:26:46.876 A:middle
你给他的训练材料

00:26:46.876 --> 00:26:50.736 A:middle
包括你希望 

00:26:50.736 --> 00:26:52.296 A:middle
在实际操作中

00:26:52.296 --> 00:26:55.156 A:middle
能看到的所有东西

00:26:55.386 --> 00:26:57.336 A:middle
在某种意义上说 

00:26:57.336 --> 00:26:58.736 A:middle
我们提供算法 比较简单

00:26:58.736 --> 00:27:00.136 A:middle
比较困难的部分留给了你们

00:27:00.136 --> 00:27:03.096 A:middle
那就是提供训练数据

00:27:03.716 --> 00:27:06.916 A:middle
但是如果我们用

00:27:06.916 --> 00:27:09.216 A:middle
已知的语言知识 

00:27:09.216 --> 00:27:11.386 A:middle
结合我们提供的

00:27:12.316 --> 00:27:16.966 A:middle
体积小一点的训练材料

00:27:16.966 --> 00:27:18.526 A:middle
来训练模型

00:27:18.526 --> 00:27:21.366 A:middle
这样不是很好吗？

00:27:21.366 --> 00:27:24.616 A:middle
通过两者的结合

00:27:24.696 --> 00:27:26.886 A:middle
它会理解更多的实例

00:27:26.886 --> 00:27:31.176 A:middle
即便是训练材料

00:27:31.176 --> 00:27:33.046 A:middle
没有那么多

00:27:34.426 --> 00:27:37.866 A:middle
这就是迁移学习的目标

00:27:38.576 --> 00:27:41.036 A:middle
这是 NLP 重点研究领域

00:27:41.036 --> 00:27:43.876 A:middle
很高兴 我们已经

00:27:43.876 --> 00:27:45.786 A:middle
找到了一个解决办法

00:27:46.136 --> 00:27:47.326 A:middle
现在介绍给大家

00:27:48.286 --> 00:27:50.426 A:middle
自然语言训练模型

00:27:50.426 --> 00:27:52.946 A:middle
生成一个 Core ML 模型

00:27:53.326 --> 00:27:54.916 A:middle
但是我们怎么结合

00:27:54.916 --> 00:27:57.696 A:middle
已知的语言知识呢

00:27:58.026 --> 00:27:58.886 A:middle
我们从哪儿得到这个知识呢

00:27:59.946 --> 00:28:06.376 A:middle
单词嵌入提供了许多语言的知识

00:28:06.376 --> 00:28:07.656 A:middle
尤其是 它们知道

00:28:07.656 --> 00:28:10.626 A:middle
单词的许多意思

00:28:11.296 --> 00:28:13.996 A:middle
我们的方法是

00:28:13.996 --> 00:28:16.026 A:middle
有单词嵌入

00:28:16.026 --> 00:28:18.056 A:middle
和你提供的训练材料

00:28:18.056 --> 00:28:19.466 A:middle
把他们放入单词嵌入

00:28:19.466 --> 00:28:21.686 A:middle
在此之上

00:28:21.686 --> 00:28:25.596 A:middle
训练神经网络模型

00:28:26.096 --> 00:28:27.986 A:middle
这样我们就得到了

00:28:27.986 --> 00:28:30.456 A:middle
迁移学习文本分类模型

00:28:31.556 --> 00:28:32.686 A:middle
看起来比较复杂

00:28:32.686 --> 00:28:34.716 A:middle
但是如果你想用 

00:28:34.716 --> 00:28:37.156 A:middle
你只需要请求

00:28:38.496 --> 00:28:42.416 A:middle
在训练迁移学习模型时

00:28:42.416 --> 00:28:45.436 A:middle
你只需要在算法规范里

00:28:45.436 --> 00:28:46.876 A:middle
改变一个参数

00:28:47.216 --> 00:28:49.366 A:middle
现在这里有几个选择

00:28:50.056 --> 00:28:52.776 A:middle
首先 显而易见

00:28:52.776 --> 00:28:54.696 A:middle
你可以用

00:28:54.696 --> 00:28:56.806 A:middle
表示单词原意的

00:28:57.296 --> 00:29:00.486 A:middle
内置 OS 单词嵌入

00:29:00.656 --> 00:29:02.696 A:middle
如果你有一个

00:29:02.696 --> 00:29:03.936 A:middle
自定义单词嵌入

00:29:03.936 --> 00:29:06.106 A:middle
也可以用

00:29:06.306 --> 00:29:10.066 A:middle
我们知道一个给定单词

00:29:10.066 --> 00:29:11.236 A:middle
可以有不同的意思

00:29:11.236 --> 00:29:12.456 A:middle
这个词的意思

00:29:12.456 --> 00:29:13.586 A:middle
取决于上下文

00:29:14.016 --> 00:29:15.316 A:middle
比如 Apple 在这两句话中

00:29:15.316 --> 00:29:16.896 A:middle
意思完全不同

00:29:18.206 --> 00:29:20.586 A:middle
我们希望

00:29:20.586 --> 00:29:22.356 A:middle
用在迁移学习上的嵌入

00:29:22.356 --> 00:29:24.766 A:middle
可以根据单词的

00:29:25.386 --> 00:29:28.816 A:middle
意思和上下文

00:29:28.816 --> 00:29:31.226 A:middle
给这些单词不同的值

00:29:31.226 --> 00:29:32.366 A:middle
当然 普通的单词嵌入

00:29:32.366 --> 00:29:34.966 A:middle
只是将单词映射到向量

00:29:34.966 --> 00:29:37.306 A:middle
不管单词是什么意思

00:29:37.306 --> 00:29:39.036 A:middle
它只能给出

00:29:39.036 --> 00:29:40.076 A:middle
同样的值

00:29:41.466 --> 00:29:44.876 A:middle
但我们做的是

00:29:44.876 --> 00:29:46.866 A:middle
训练一个特殊嵌入

00:29:46.976 --> 00:29:50.356 A:middle
让它根据单词的

00:29:50.356 --> 00:29:51.656 A:middle
意思和上下文

00:29:51.656 --> 00:29:52.866 A:middle
给出不同的值

00:29:53.446 --> 00:29:54.886 A:middle
大家可以感受到

00:29:54.886 --> 00:29:56.086 A:middle
这个领域发展的有多快

00:29:56.086 --> 00:29:57.456 A:middle
这只是一年前

00:29:57.456 --> 00:30:00.166 A:middle
我们在研究的东西

00:30:00.166 --> 00:30:03.156 A:middle
现在就可以公布出来

00:30:03.376 --> 00:30:04.796 A:middle
如果你想用

00:30:04.796 --> 00:30:06.546 A:middle
你只需要请求

00:30:07.076 --> 00:30:08.956 A:middle
指定一个动态嵌入

00:30:09.186 --> 00:30:10.426 A:middle
这个动态嵌入

00:30:10.956 --> 00:30:13.366 A:middle
会根据单词

00:30:13.366 --> 00:30:15.106 A:middle
所处的上下文

00:30:15.106 --> 00:30:17.766 A:middle
改变单词的值

00:30:17.766 --> 00:30:20.016 A:middle
这是做文本分类的迁移学习

00:30:20.016 --> 00:30:22.296 A:middle
非常强大的一个技术

00:30:23.546 --> 00:30:25.206 A:middle
看一下示范

00:30:27.056 --> 00:30:30.716 A:middle
好的 这里是一些

00:30:30.716 --> 00:30:32.636 A:middle
用 Create ML 训练文本分类

00:30:32.676 --> 00:30:34.566 A:middle
非常标准的代码

00:30:34.566 --> 00:30:37.236 A:middle
和我即将训练的东西

00:30:37.236 --> 00:30:39.056 A:middle
它基于一个数据集

00:30:39.056 --> 00:30:41.326 A:middle
从一个名为 DBpedia 的

00:30:41.766 --> 00:30:43.836 A:middle
开源百科全书中得到的

00:30:44.676 --> 00:30:46.486 A:middle
它包含许多话题的

00:30:46.486 --> 00:30:47.426 A:middle
简短词条

00:30:47.496 --> 00:30:49.456 A:middle
一些是关于人

00:30:49.456 --> 00:30:51.096 A:middle
艺术家 作家 

00:30:51.096 --> 00:30:52.616 A:middle
植物 动物等等

00:30:52.616 --> 00:30:55.146 A:middle
这里的任务是

00:30:55.146 --> 00:30:56.746 A:middle
根据词条确定分类

00:30:56.876 --> 00:30:59.186 A:middle
是一个人 还是一个作家

00:30:59.186 --> 00:31:01.886 A:middle
或艺术家 等等

00:31:01.956 --> 00:31:04.186 A:middle
有 14 种不同的类

00:31:04.186 --> 00:31:05.546 A:middle
我想通过 

00:31:05.546 --> 00:31:07.036 A:middle
200 个实例

00:31:07.036 --> 00:31:08.406 A:middle
尝试训练分类器

00:31:08.906 --> 00:31:11.016 A:middle
这是一个非常困难的任务

00:31:11.016 --> 00:31:13.766 A:middle
我们用现有的 maxEnt 模型

00:31:13.766 --> 00:31:16.236 A:middle
来尝试一下

00:31:17.356 --> 00:31:19.006 A:middle
快速写入发送

00:31:19.436 --> 00:31:21.316 A:middle
开始 结束了

00:31:22.776 --> 00:31:25.296 A:middle
非常快 非常简单

00:31:25.296 --> 00:31:30.966 A:middle
看一下测试集的表现情况

00:31:31.286 --> 00:31:34.116 A:middle
77% 的准确率

00:31:35.116 --> 00:31:39.796 A:middle
还可以 但是能更好吗

00:31:39.796 --> 00:31:41.756 A:middle
稍微改动一下

00:31:41.756 --> 00:31:43.926 A:middle
这里的代码

00:31:44.266 --> 00:31:46.856 A:middle
不再使用 maxEnt 模型

00:31:46.856 --> 00:31:47.986 A:middle
而是使用

00:31:47.986 --> 00:31:49.526 A:middle
带有动态嵌入的迁移学习

00:31:49.526 --> 00:31:53.266 A:middle
开始试一下

00:31:54.736 --> 00:31:56.186 A:middle
正如我刚才所说

00:31:56.186 --> 00:31:57.956 A:middle
这是在训练一个神经网络模型

00:31:58.136 --> 00:31:59.526 A:middle
所以时间会久一点

00:32:02.606 --> 00:32:04.286 A:middle
我们可以细看一下

00:32:04.326 --> 00:32:05.916 A:middle
正在训练的数据

00:32:06.326 --> 00:32:08.196 A:middle
实际上

00:32:08.196 --> 00:32:09.646 A:middle
在你训练神经网络模型时

00:32:09.916 --> 00:32:11.556 A:middle
你需要关注

00:32:11.556 --> 00:32:14.216 A:middle
训练使用的数据

00:32:14.596 --> 00:32:17.166 A:middle
这个数据是

00:32:17.276 --> 00:32:19.386 A:middle
跨多个类的随机实例

00:32:19.386 --> 00:32:22.646 A:middle
我整理了一下

00:32:22.646 --> 00:32:23.846 A:middle
所以每个类的

00:32:23.846 --> 00:32:26.676 A:middle
实例数大致相同

00:32:27.186 --> 00:32:28.346 A:middle
这是一个比较均衡的集

00:32:29.366 --> 00:32:30.626 A:middle
我们的训练集

00:32:30.626 --> 00:32:31.926 A:middle
另外我们还有一个

00:32:31.926 --> 00:32:34.146 A:middle
单独的验证集

00:32:34.146 --> 00:32:36.226 A:middle
也是跨类的随机实例

00:32:36.226 --> 00:32:38.546 A:middle
也许没有训练集

00:32:38.546 --> 00:32:39.756 A:middle
体积那么大

00:32:39.756 --> 00:32:41.296 A:middle
但也是均衡的

00:32:41.986 --> 00:32:43.246 A:middle
验证集在这种训练中

00:32:43.306 --> 00:32:45.536 A:middle
尤为重要

00:32:45.996 --> 00:32:48.466 A:middle
神经网络训练

00:32:48.516 --> 00:32:50.846 A:middle
容易过度拟合

00:32:50.846 --> 00:32:52.666 A:middle
会或多或少记住训练内容

00:32:52.666 --> 00:32:54.816 A:middle
但不会概括总结

00:32:55.096 --> 00:32:56.616 A:middle
验证集

00:32:56.616 --> 00:32:57.976 A:middle
会确保它

00:32:57.976 --> 00:32:59.316 A:middle
继续概括

00:33:01.376 --> 00:33:03.946 A:middle
单独的测试集

00:33:03.946 --> 00:33:05.846 A:middle
实例也是随机但均衡的

00:33:05.846 --> 00:33:10.196 A:middle
当然 训练验证测试集之间

00:33:10.196 --> 00:33:12.006 A:middle
没有重叠部分

00:33:12.006 --> 00:33:12.796 A:middle
不然就是欺骗

00:33:13.966 --> 00:33:16.606 A:middle
我们需要测试集

00:33:16.606 --> 00:33:17.576 A:middle
查看我们在做什么

00:33:17.576 --> 00:33:19.586 A:middle
尤其是在这个例子中

00:33:19.586 --> 00:33:22.296 A:middle
有了测试集

00:33:22.296 --> 00:33:24.646 A:middle
我们就知道迁移学习模型

00:33:24.646 --> 00:33:28.126 A:middle
是不是比 maxEnt 模型好

00:33:28.596 --> 00:33:29.866 A:middle
好像是结束了

00:33:29.866 --> 00:33:31.326 A:middle
我们来看一下

00:33:31.606 --> 00:33:36.486 A:middle
在这里我们可以看到

00:33:36.486 --> 00:33:38.576 A:middle
迁移学习实现了

00:33:38.576 --> 00:33:41.106 A:middle
86.5% 的正确率

00:33:41.186 --> 00:33:45.976 A:middle
比 maxEnt 模型好很多

00:33:46.516 --> 00:33:51.796 A:middle
[掌声]

00:33:52.296 --> 00:33:55.996 A:middle
那么如何把这个应用到

00:33:55.996 --> 00:33:56.976 A:middle
我们的奶酪 App 呢

00:33:57.056 --> 00:33:59.536 A:middle
我已经有

00:33:59.576 --> 00:34:01.746 A:middle
奶酪口味的笔记

00:34:03.146 --> 00:34:05.726 A:middle
按它们提到的奶酪

00:34:05.756 --> 00:34:07.116 A:middle
给每一个都标上了标签

00:34:07.396 --> 00:34:09.626 A:middle
我将用这个

00:34:09.626 --> 00:34:10.676 A:middle
训练分类器模型

00:34:10.676 --> 00:34:13.196 A:middle
我的奶酪分类器模型

00:34:13.196 --> 00:34:16.146 A:middle
会拿到一个句子

00:34:16.246 --> 00:34:18.216 A:middle
尝试对他进行分类

00:34:18.216 --> 00:34:20.866 A:middle
找到它最接近的是哪种奶酪

00:34:21.016 --> 00:34:24.036 A:middle
把它放入我的奶酪 App

00:34:24.036 --> 00:34:28.826 A:middle
我将在这个奶酪 App 里做的是

00:34:28.826 --> 00:34:32.366 A:middle
如果用户

00:34:32.366 --> 00:34:33.545 A:middle
没有特别提到一种奶酪

00:34:33.585 --> 00:34:34.936 A:middle
那么我需要尝试找出

00:34:34.936 --> 00:34:36.746 A:middle
他们想要哪种奶酪

00:34:37.255 --> 00:34:39.456 A:middle
我要做的只是向模型请求

00:34:39.456 --> 00:34:43.226 A:middle
文本的标签非常简单

00:34:43.226 --> 00:34:45.000 A:middle
我们来试一下

00:35:15.486 --> 00:35:20.966 A:middle
然后让奶酪器分类解析它

00:35:21.516 --> 00:35:23.536 A:middle
奶酪分类器判定

00:35:23.696 --> 00:35:24.996 A:middle
我想要的最接近

00:35:25.046 --> 00:35:26.716 A:middle
卡芒贝尔奶酪

00:35:27.066 --> 00:35:29.066 A:middle
然后我的奶酪嵌入

00:35:29.066 --> 00:35:30.516 A:middle
会推荐一些

00:35:30.516 --> 00:35:31.936 A:middle
其他相似的奶酪

00:35:31.936 --> 00:35:32.756 A:middle
布里奶酪等等

00:35:34.156 --> 00:35:36.000 A:middle
我也可以输入

00:35:45.386 --> 00:35:46.826 A:middle
质地结实的奶酪

00:35:46.826 --> 00:35:47.946 A:middle
它认定为是

00:35:48.286 --> 00:35:49.826 A:middle
切达奶酪

00:35:50.036 --> 00:35:53.001 A:middle
并推荐了一些相似的奶酪 [掌声]

00:35:53.036 --> 00:35:54.386 A:middle
这向我们展示了

00:35:54.426 --> 00:35:57.596 A:middle
文本分类结合其他

00:35:57.596 --> 00:35:59.746 A:middle
NaturalLanguage API 的

00:35:59.956 --> 00:36:01.486 A:middle
强大功能

00:36:01.736 --> 00:36:03.276 A:middle
最后我将说明一些

00:36:03.276 --> 00:36:05.366 A:middle
使用文本分类

00:36:05.456 --> 00:36:07.656 A:middle
必须要考虑的问题

00:36:07.656 --> 00:36:09.266 A:middle
首先我们要注意

00:36:09.266 --> 00:36:10.756 A:middle
哪些语言支持迁移学习

00:36:11.166 --> 00:36:12.846 A:middle
考虑上下文

00:36:12.846 --> 00:36:14.956 A:middle
不论是通过静态嵌入

00:36:14.956 --> 00:36:17.746 A:middle
还是通过

00:36:17.886 --> 00:36:19.576 A:middle
动态嵌入

00:36:20.026 --> 00:36:23.196 A:middle
然后我想再说一下

00:36:23.196 --> 00:36:25.056 A:middle
数据方面的问题

00:36:26.326 --> 00:36:28.446 A:middle
处理数据的

00:36:28.446 --> 00:36:29.626 A:middle
第一要求是

00:36:29.626 --> 00:36:31.676 A:middle
你必须要了解

00:36:31.676 --> 00:36:32.296 A:middle
自己的领域

00:36:33.506 --> 00:36:35.036 A:middle
在实际操作中

00:36:35.036 --> 00:36:36.176 A:middle
你将遇到什么样的文本

00:36:36.396 --> 00:36:37.626 A:middle
是句子片段

00:36:37.626 --> 00:36:39.086 A:middle
还是完整的句子

00:36:39.086 --> 00:36:41.556 A:middle
还是多个句子

00:36:41.556 --> 00:36:43.576 A:middle
确保你的训练数据

00:36:43.576 --> 00:36:45.526 A:middle
和在实际情况中

00:36:45.526 --> 00:36:47.106 A:middle
可能遇到 需要分类的数据

00:36:47.106 --> 00:36:48.576 A:middle
尽量的相似

00:36:49.646 --> 00:36:52.026 A:middle
并且尽量全面地包括

00:36:52.286 --> 00:36:53.646 A:middle
你在 App 中 

00:36:53.646 --> 00:36:55.866 A:middle
可能遇到的

00:36:55.866 --> 00:36:57.776 A:middle
文本的变体

00:36:58.906 --> 00:37:02.746 A:middle
就像刚才在 DBpedia 例子中

00:37:02.746 --> 00:37:04.806 A:middle
看到的那样

00:37:05.266 --> 00:37:08.806 A:middle
你要确保实例

00:37:08.806 --> 00:37:11.316 A:middle
尽量是随机的

00:37:11.316 --> 00:37:13.606 A:middle
训练集 验证集 测试集

00:37:13.606 --> 00:37:15.266 A:middle
尽量不同

00:37:15.766 --> 00:37:17.696 A:middle
这是基本的数据要求

00:37:18.096 --> 00:37:21.706 A:middle
如何知道

00:37:21.706 --> 00:37:23.916 A:middle
哪个算法最适合你呢 

00:37:24.336 --> 00:37:25.616 A:middle
普遍来讲 你需要尝试

00:37:25.616 --> 00:37:28.426 A:middle
但是也有一些参考

00:37:28.626 --> 00:37:30.466 A:middle
你可以先尝试 maxEnt 分类器

00:37:30.466 --> 00:37:31.456 A:middle
它速度很快

00:37:31.456 --> 00:37:32.606 A:middle
它会给你一个答案

00:37:33.766 --> 00:37:36.356 A:middle
但是 maxEnt 分类器能做什么呢

00:37:36.896 --> 00:37:38.926 A:middle
maxEnt 分类器

00:37:38.926 --> 00:37:41.556 A:middle
可以识别训练材料中

00:37:42.146 --> 00:37:44.556 A:middle
最常出现的词

00:37:45.096 --> 00:37:46.806 A:middle
比如说

00:37:46.806 --> 00:37:49.756 A:middle
你想训练识别积极和消极情感

00:37:49.756 --> 00:37:51.486 A:middle
它可能会注意到

00:37:51.486 --> 00:37:52.676 A:middle
爱和幸福是积极的

00:37:52.736 --> 00:37:54.666 A:middle
恨和不开心是消极的

00:37:55.326 --> 00:37:57.406 A:middle
如果实际使用中

00:37:57.406 --> 00:37:59.106 A:middle
遇到了这些单词

00:37:59.106 --> 00:38:00.426 A:middle
那么 maxEnt 分类器

00:38:00.426 --> 00:38:02.146 A:middle
就会做得很好

00:38:02.676 --> 00:38:08.146 A:middle
迁移学习做了什么呢

00:38:08.456 --> 00:38:10.546 A:middle
它注意的是不是单词的意思呢

00:38:11.056 --> 00:38:12.906 A:middle
如果在实际操作中

00:38:12.906 --> 00:38:14.476 A:middle
遇到了用不同的单词

00:38:14.476 --> 00:38:16.926 A:middle
表达相同意思的情况

00:38:17.016 --> 00:38:20.426 A:middle
这时迁移学习模型

00:38:20.426 --> 00:38:21.786 A:middle
就会大放异彩

00:38:21.786 --> 00:38:24.476 A:middle
它做的就会

00:38:24.476 --> 00:38:27.546 A:middle
比普通的 maxEnt 模型好

00:38:28.046 --> 00:38:33.086 A:middle
总的来说 我们有一些新的 API

00:38:33.086 --> 00:38:35.676 A:middle
可以用于情感分析

00:38:35.676 --> 00:38:38.706 A:middle
可以结合 MLGazetteer 用于文本目录 

00:38:38.706 --> 00:38:41.906 A:middle
可以结合 NL 嵌入

00:38:41.996 --> 00:38:45.376 A:middle
用于单词嵌入

00:38:45.376 --> 00:38:47.306 A:middle
我们有一种新型的文本分类

00:38:47.466 --> 00:38:49.046 A:middle
因为可以用迁移学习

00:38:49.716 --> 00:38:52.056 A:middle
所以这个新类型特别强大

00:38:53.096 --> 00:38:55.226 A:middle
希望这些可以在你的 App 中

00:38:55.226 --> 00:38:58.086 A:middle
起到帮助作用

00:38:58.426 --> 00:39:01.496 A:middle
线上还有更多的信息

00:39:01.496 --> 00:39:04.256 A:middle
你也可以查看其他

00:39:04.256 --> 00:39:05.256 A:middle
相关的讲解

00:39:06.356 --> 00:39:12.500 A:middle
谢谢 [掌声]

