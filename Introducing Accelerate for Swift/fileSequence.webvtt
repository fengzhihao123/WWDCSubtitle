WEBVTT
X-TIMESTAMP-MAP=MPEGTS:900000,LOCAL:00:00:00.000

00:00:06.974 --> 00:00:08.942 align:center line:0
你好
我是Simon Gladman

00:00:09.009 --> 00:00:11.011 align:center line:0
我是矢量和数字团队的一员

00:00:11.345 --> 00:00:14.515 align:center line:0
在本次演讲中
我会介绍两个主题

00:00:14.581 --> 00:00:17.718 align:center line:0
第一是我们为Accelerate
设计新Swift Overlay

00:00:17.784 --> 00:00:20.320 align:center line:0
第二个是使用LINPACK
基准来测试Accelerate

00:00:20.387 --> 00:00:22.122 align:center line:0
的性能表现

00:00:22.189 --> 00:00:24.224 align:center line:-2
在我们深入了解
Swift Overlay之前

00:00:24.291 --> 00:00:28.028 align:center line:-2
我们来确切地回顾一下
什么是Accelerate框架

00:00:29.229 --> 00:00:31.098 align:center line:-1
Accelerate的主要使用

00:00:31.164 --> 00:00:34.034 align:center line:-2
目的是提供许多
低级数学基元

00:00:34.101 --> 00:00:37.704 align:center line:-2
它在CPU上运行
支持图片和信号处理

00:00:37.771 --> 00:00:41.375 align:center line:-2
向量运算 线性代数
和机器学习

00:00:41.808 --> 00:00:46.180 align:center line:-2
这些基元大多数是通过手动调整
给处理器的微体系结构的

00:00:46.246 --> 00:00:48.715 align:center line:-1
这意味着我们获取了极佳的性能表现

00:00:48.782 --> 00:00:53.053 align:center line:-1
这个性能表现会直接转变为节能

00:00:53.620 --> 00:00:54.888 align:center line:-1
那么 如果你是一个app开发者

00:00:54.955 --> 00:00:56.757 align:center line:-1
使用Accelerate框架

00:00:56.823 --> 00:00:59.393 align:center line:-1
不仅会让你的app运行更快

00:00:59.459 --> 00:01:02.062 align:center line:-1
你的电池寿命也会更长

00:01:03.497 --> 00:01:07.000 align:center line:-2
我们提供的基元能
在所有的Apple平台运行

00:01:07.067 --> 00:01:11.305 align:center line:-1
这不只包含macOS和iOS

00:01:11.371 --> 00:01:15.075 align:center line:-2
也同样支持
watchOS和tvOS

00:01:15.742 --> 00:01:20.080 align:center line:-2
这意味着你的用户能
获得一致的更好体验

00:01:21.582 --> 00:01:23.951 align:center line:-1
Accelerate库非常强大

00:01:24.017 --> 00:01:24.952 align:center line:-1
但到现在为止

00:01:25.018 --> 00:01:28.355 align:center line:-2
它们的用户界面对
Swift开发者还不太友好

00:01:28.822 --> 00:01:30.190 align:center line:-1
我们来看一下四个库

00:01:30.257 --> 00:01:32.693 align:center line:-2
以及新创建的对
Swift友好的API

00:01:32.759 --> 00:01:36.096 align:center line:-2
来使得在Swift项目中使用
Accelerate变得非常简单

00:01:36.496 --> 00:01:39.099 align:center line:-1
关于这四个库 我们将主要关注：

00:01:39.433 --> 00:01:42.970 align:center line:-2
vDSP提供的
数字信号处理运算

00:01:43.036 --> 00:01:46.773 align:center line:-2
包括对大向量的运算
傅里叶变换

00:01:46.840 --> 00:01:50.110 align:center line:-2
双二次过滤
和强大的类型转换

00:01:51.278 --> 00:01:54.882 align:center line:-1
vForce提供的运算和超越函数

00:01:54.948 --> 00:01:58.118 align:center line:-1
包括三角和对数运算

00:01:58.785 --> 00:02:03.123 align:center line:-1
正交提供的函数的数值积分

00:02:03.891 --> 00:02:07.961 align:center line:-2
vImage提供了一个多种类
的图像处理函数

00:02:08.027 --> 00:02:11.131 align:center line:-2
它已被集成至Core Graphics
和Core Video

00:02:12.232 --> 00:02:16.136 align:center line:-2
Accelerate通过向量化
来实现它优异的性能表现

00:02:17.304 --> 00:02:18.839 align:center line:-1
为了了解向量化

00:02:18.906 --> 00:02:21.074 align:center line:-1
我们首先来看一下一个简单的运算

00:02:21.141 --> 00:02:24.144 align:center line:-1
在一个数组的元素中使用标量的代码

00:02:24.745 --> 00:02:26.914 align:center line:-1
如果 比如你写的代码

00:02:26.980 --> 00:02:31.952 align:center line:-2
一个数组中的每个元素和
另一个数组对应的元素相乘

00:02:32.019 --> 00:02:33.854 align:center line:-1
你使用了一个for循环

00:02:33.921 --> 00:02:36.123 align:center line:-1
每对元素都被分散地加载

00:02:36.190 --> 00:02:39.159 align:center line:-2
相互相乘
保存结果

00:02:39.526 --> 00:02:42.829 align:center line:-2
那么 当a和b中的第一个元素
相乘之后

00:02:42.896 --> 00:02:45.332 align:center line:-1
成为c的第一个元素

00:02:45.399 --> 00:02:47.167 align:center line:-1
第二对被处理了

00:02:48.068 --> 00:02:49.169 align:center line:-1
接着 是第三对

00:02:49.970 --> 00:02:52.172 align:center line:-1
以及 最后是第四对

00:02:55.042 --> 00:02:57.411 align:center line:-2
不过 如果你在
处理一个数组里的元素

00:02:57.477 --> 00:02:58.612 align:center line:-1
使用Accelerate

00:02:58.679 --> 00:03:02.449 align:center line:-2
你的运算会在
单指令多数据中被实现

00:03:02.516 --> 00:03:04.184 align:center line:-1
或simD寄存器

00:03:04.651 --> 00:03:06.820 align:center line:-1
这些寄存器能

00:03:06.887 --> 00:03:08.689 align:center line:-1
在多个数据项中执行相同的指令

00:03:08.755 --> 00:03:11.792 align:center line:-2
通过将多个这些物件打包成
一个单个的寄存器

00:03:12.125 --> 00:03:15.462 align:center line:-1
比如一个单个128位的寄存器

00:03:15.529 --> 00:03:19.833 align:center line:-2
实际上能存储
4个32位的浮点值

00:03:19.900 --> 00:03:21.768 align:center line:-1
所以 一个矢量乘法操作

00:03:21.835 --> 00:03:25.706 align:center line:-1
能同时相乘4对元素

00:03:26.306 --> 00:03:29.042 align:center line:-1
这意味着这个任务不仅会被加速执行

00:03:29.109 --> 00:03:32.212 align:center line:-1
它也会更显著地节能

00:03:34.581 --> 00:03:36.316 align:center line:-1
我们刚才看到的乘法函数

00:03:36.383 --> 00:03:40.721 align:center line:-2
是Accelerate的数字
信号处理库vDSP的一部分

00:03:40.787 --> 00:03:43.690 align:center line:-2
那么 我们从新的Swift
API是怎样通过

00:03:43.757 --> 00:03:46.260 align:center line:-1
使用vDSP简化使用方式来开始吧

00:03:48.529 --> 00:03:52.466 align:center line:-2
vDSP提供了矢量化数字
信号处理功能

00:03:52.533 --> 00:03:54.601 align:center line:-1
包括傅里叶变换

00:03:54.935 --> 00:03:56.570 align:center line:-1
双二次过滤

00:03:56.937 --> 00:03:59.239 align:center line:-1
卷积和相关

00:03:59.740 --> 00:04:04.011 align:center line:-2
更进一步 vDSP也提供了
一些强大的更常规的功能

00:04:04.077 --> 00:04:08.248 align:center line:-1
包括元素级算术和类型转换

00:04:09.082 --> 00:04:11.652 align:center line:-1
所以 即使你还没有一个迫切需求

00:04:11.718 --> 00:04:14.621 align:center line:-1
比如计算两个信号之间的连贯性

00:04:14.688 --> 00:04:18.524 align:center line:-2
你可能会发现
vDSP的常规运算程序

00:04:18.591 --> 00:04:21.862 align:center line:-2
为你app的性能表现
提供了一个解决方案

00:04:24.665 --> 00:04:27.301 align:center line:-1
我们来看看一些基本的运算

00:04:27.367 --> 00:04:28.869 align:center line:-1
一个例子：

00:04:28.936 --> 00:04:31.972 align:center line:-1
已知4个单精度值的数组

00:04:32.039 --> 00:04:33.006 align:center line:-1
你需要计算

00:04:33.073 --> 00:04:35.275 align:center line:-1
数组的二乘二的元素和

00:04:35.642 --> 00:04:37.711 align:center line:-1
其他两个的各个元素都不同

00:04:37.778 --> 00:04:40.280 align:center line:-1
使用一个for循环

00:04:41.682 --> 00:04:42.549 align:center line:-1
来互乘这些结果

00:04:42.616 --> 00:04:45.185 align:center line:-1
是这个问题的一个非常合理的选择

00:04:45.252 --> 00:04:47.621 align:center line:-1
以及计算这些预期结果

00:04:48.422 --> 00:04:53.060 align:center line:-2
这是你如何使用vDSP
经典的API来计算性能

00:04:53.560 --> 00:04:58.298 align:center line:-2
使用vDSP大约比for
循环快三倍

00:04:59.566 --> 00:05:03.937 align:center line:-2
这是使用我们新的为vDSP
设计Swift API相同的运算

00:05:04.438 --> 00:05:06.773 align:center line:-2
我们暴露了
新的Swift友好的函数

00:05:06.840 --> 00:05:08.609 align:center line:-1
通过我们的vDSP的命名空间

00:05:08.675 --> 00:05:12.312 align:center line:-2
你能看到函数和
参数名称解释了操作

00:05:12.946 --> 00:05:15.115 align:center line:-1
因为新的函数使用了相似的类型

00:05:15.182 --> 00:05:18.151 align:center line:-2
包括数组和数组分片
而不是指针

00:05:18.218 --> 00:05:21.088 align:center line:-1
你不再需要明确地传递数值

00:05:21.255 --> 00:05:25.325 align:center line:-2
所以整个函数调用更直观
和更简洁了

00:05:27.027 --> 00:05:28.996 align:center line:-1
传递一个初始化结果数组

00:05:29.062 --> 00:05:30.731 align:center line:-1
提供了最好的性能表现

00:05:30.797 --> 00:05:33.934 align:center line:-2
为了进一步的性能提升
你当然可以在其他操作中

00:05:34.001 --> 00:05:36.336 align:center line:-1
重复使用那个数组

00:05:37.137 --> 00:05:41.074 align:center line:-2
不过 我们也提供了
自调度函数

00:05:41.141 --> 00:05:46.180 align:center line:-2
这些利用了Swift新的功能
来访问一个数组里未初始化的缓冲

00:05:46.246 --> 00:05:48.682 align:center line:-1
返回运算的结果

00:05:49.183 --> 00:05:52.219 align:center line:-2
虽然没有传递
现有的存储那么快

00:05:52.286 --> 00:05:54.421 align:center line:-1
它还是比标量方式要快的

00:05:54.488 --> 00:05:57.891 align:center line:-2
以及 在一些使用场景
它会简化你的代码

00:06:02.863 --> 00:06:04.498 align:center line:-1
是类型转换

00:06:04.565 --> 00:06:08.335 align:center line:-2
这个例子将一个具有双精度值
的数组转换为

00:06:08.402 --> 00:06:12.940 align:center line:-2
16位的无符号整数的值
舍入到零

00:06:14.875 --> 00:06:18.378 align:center line:-1
标量版本使用了显式四舍五入映射

00:06:18.445 --> 00:06:21.682 align:center line:-2
再一次 这是一个
完全合理的技术使用

00:06:21.748 --> 00:06:25.786 align:center line:-2
但vDSP能矢量化这个任务来
提升性能

00:06:27.254 --> 00:06:28.222 align:center line:-1
在这个例子中

00:06:28.288 --> 00:06:34.061 align:center line:-2
vDSP大约比之前的
标量实现快4倍

00:06:35.996 --> 00:06:40.400 align:center line:-2
vDSP函数所在的新的Swift
版本提供了一个清晰的接口

00:06:40.634 --> 00:06:42.903 align:center line:-1
这个函数获取一个源函数

00:06:42.970 --> 00:06:45.806 align:center line:-1
你应该将每个元素转换成整型

00:06:45.873 --> 00:06:48.408 align:center line:-1
和一个枚举来指定rounding

00:06:51.979 --> 00:06:54.381 align:center line:-1
vDSP提供了傅里叶变换

00:06:54.448 --> 00:06:57.651 align:center line:-1
在时域和频域之间

00:06:57.718 --> 00:07:00.187 align:center line:-1
将一维数据转换至二维数据

00:07:01.588 --> 00:07:03.891 align:center line:-1
一个信号的正向傅里叶变换

00:07:03.957 --> 00:07:06.860 align:center line:-1
分解它成为它的组件的信号波

00:07:06.927 --> 00:07:09.429 align:center line:-1
那就是频域所代表的

00:07:10.030 --> 00:07:14.134 align:center line:-1
相反地 一个频域所展现的逆变换

00:07:14.201 --> 00:07:16.036 align:center line:-1
重建了原始信号

00:07:16.103 --> 00:07:18.438 align:center line:-1
那是时域所展现的

00:07:19.273 --> 00:07:23.377 align:center line:-2
傅里叶变换在信号和
图像处理中有许多应用

00:07:23.443 --> 00:07:27.114 align:center line:-1
比如只要一个音频信号被正向转换了

00:07:27.181 --> 00:07:31.919 align:center line:-2
你可以很容易的减小或
增大一定的频率来平衡音频

00:07:33.253 --> 00:07:35.689 align:center line:-1
经典的API是易于理解的

00:07:35.756 --> 00:07:37.124 align:center line:-1
如果你对它熟悉

00:07:37.191 --> 00:07:39.293 align:center line:-1
你从创建设置对象开始

00:07:39.359 --> 00:07:43.096 align:center line:-2
指定元素的数量
你想要的转换和定位

00:07:43.430 --> 00:07:46.466 align:center line:-2
接着
在创建完两个数组来获取结果之后

00:07:46.533 --> 00:07:48.368 align:center line:-1
你调用执行函数

00:07:48.435 --> 00:07:50.904 align:center line:-2
只要你在结束之后
你需要记得销毁设置

00:07:50.971 --> 00:07:53.473 align:center line:-1
来释放为它分配的资源

00:07:54.808 --> 00:07:58.946 align:center line:-1
新的API简化了设置对象的实例化

00:07:59.413 --> 00:08:02.583 align:center line:-1
转换本身是一个带有

00:08:02.649 --> 00:08:04.484 align:center line:-1
DFT实例参数名字的方法

00:08:04.551 --> 00:08:07.588 align:center line:-1
现在 你不需要担心释放资源

00:08:07.654 --> 00:08:09.122 align:center line:-1
我们会为你实现

00:08:11.024 --> 00:08:13.794 align:center line:-1
就像我们看到的vDSP函数

00:08:13.861 --> 00:08:16.997 align:center line:-1
它有一个自调度版本的转换函数

00:08:17.064 --> 00:08:20.501 align:center line:-1
它为你创建和返回返回值的数组

00:08:24.004 --> 00:08:25.506 align:center line:-1
如果你使用音频数据

00:08:25.572 --> 00:08:29.243 align:center line:-2
你可能会熟悉双二次或
双二阶滤波器

00:08:29.643 --> 00:08:32.044 align:center line:-1
双二阶滤波器能用来平衡音频

00:08:32.111 --> 00:08:33.746 align:center line:-1
来形成频率响应

00:08:33.813 --> 00:08:38.519 align:center line:-2
比如 它允许你能
移除低或高的频率

00:08:39.720 --> 00:08:41.421 align:center line:-1
vDSP的双二阶功能

00:08:41.488 --> 00:08:44.458 align:center line:-1
处理单个或多声道信号

00:08:44.525 --> 00:08:46.793 align:center line:-1
使用一组单个过滤器

00:08:46.860 --> 00:08:48.262 align:center line:-1
叫做sections的对象

00:08:48.328 --> 00:08:49.696 align:center line:-1
过滤器是级联的

00:08:49.763 --> 00:08:51.832 align:center line:-1
就是说它们是按顺序排列的

00:08:51.899 --> 00:08:55.536 align:center line:-1
整个信号依次通过每个过滤器

00:08:56.003 --> 00:08:58.605 align:center line:-1
过滤器被定义为一系列系数

00:08:58.672 --> 00:09:00.541 align:center line:-1
它会被代入这里的这个方程中

00:09:03.544 --> 00:09:06.713 align:center line:-2
在这里例子中
这些值来自一个低通滤波器

00:09:06.780 --> 00:09:09.683 align:center line:-2
就是说
一种减少高频的滤波器

00:09:09.750 --> 00:09:12.853 align:center line:-1
这是使用vDSP经典的API代码

00:09:12.920 --> 00:09:14.321 align:center line:-1
来创建双二阶设置

00:09:14.388 --> 00:09:17.057 align:center line:-1
使用之前的幻灯片的系数

00:09:18.091 --> 00:09:18.959 align:center line:-1
这里是

00:09:19.026 --> 00:09:22.496 align:center line:-2
运用双二阶过滤器
到一个叫做signal的数组

00:09:22.563 --> 00:09:25.566 align:center line:-2
返回返回值到一个
叫做output的数组的代码

00:09:26.099 --> 00:09:30.170 align:center line:-2
我们来看一下使用一个
新的API来实现相同的功能

00:09:32.072 --> 00:09:33.240 align:center line:-1
如你所见

00:09:33.307 --> 00:09:37.244 align:center line:-2
新的API大大地简化了
双二阶结构的创建

00:09:37.644 --> 00:09:40.781 align:center line:-2
你很容易地传递
系数到双二阶初始化函数

00:09:40.848 --> 00:09:43.584 align:center line:-1
指定频道的数量和部分

00:09:45.018 --> 00:09:48.589 align:center line:-2
将双二阶过滤器运用到一个信号
是一个单次函数调用

00:09:52.693 --> 00:09:55.996 align:center line:-2
现在我们来看一下新的API
我们为Accelerate的库

00:09:56.063 --> 00:10:00.601 align:center line:-2
和对大的数组
vForce快速的数学运算创建的

00:10:01.969 --> 00:10:06.273 align:center line:-2
vForce提供了vDSP
所没有的超越函数

00:10:06.540 --> 00:10:10.611 align:center line:-1
这些包括指数 对数和三角操作

00:10:12.279 --> 00:10:13.981 align:center line:-1
一个vForce的典型的例子

00:10:14.047 --> 00:10:17.618 align:center line:-2
可能被用来计算一个大数组中
每个元素的平方根

00:10:18.018 --> 00:10:20.621 align:center line:-1
这段代码的标量版本可以使用映射

00:10:22.256 --> 00:10:26.393 align:center line:-2
vForce提供了一个矢量化函数
来计算平方根

00:10:26.460 --> 00:10:29.563 align:center line:-1
在一些使用场合 它会

00:10:29.630 --> 00:10:31.632 align:center line:-1
比标量的实现快10倍以上

00:10:33.166 --> 00:10:34.501 align:center line:-1
新的Swift Overlay

00:10:34.568 --> 00:10:38.639 align:center line:-2
提供了一个和vDSP
函数一致的新API

00:10:38.705 --> 00:10:41.742 align:center line:-1
提供了向量化的性能表现

00:10:41.808 --> 00:10:43.243 align:center line:-1
和能源效率的好处

00:10:45.245 --> 00:10:46.613 align:center line:-1
就和我们早些时候看到的很类似

00:10:46.680 --> 00:10:49.783 align:center line:-2
这是一个自调度版本
它会返回一个数组

00:10:49.850 --> 00:10:52.986 align:center line:-2
包含了提供的数组中
每个元素的平方根

00:10:57.057 --> 00:11:01.161 align:center line:-2
接下来 我们来看看我们
为正交创建的新的API

00:11:02.596 --> 00:11:06.667 align:center line:-2
正交是判定一条曲线下区域
的一项有历史意义的条款

00:11:07.367 --> 00:11:10.737 align:center line:-1
它提供了一个在有限或无限区间内

00:11:10.804 --> 00:11:13.674 align:center line:-1
近似明确的集成函数

00:11:14.274 --> 00:11:18.579 align:center line:-2
在示例中 我们会使用
正交来估量半圆的面积

00:11:18.645 --> 00:11:22.683 align:center line:-2
这里的绿色的部分
通过对所示函数进行积分

00:11:25.352 --> 00:11:27.855 align:center line:-1
很像vDSP的双二阶代码

00:11:27.921 --> 00:11:32.693 align:center line:-2
需要相当多的代码来使用
已有的正交的API

00:11:33.293 --> 00:11:38.198 align:center line:-2
第一步是定义一个
描述要集成函数的结构体

00:11:40.100 --> 00:11:42.936 align:center line:-1
第二步是定义集成选项

00:11:43.003 --> 00:11:45.239 align:center line:-1
包括集成算法

00:11:46.607 --> 00:11:49.643 align:center line:-2
最后
使用选项定义的函数

00:11:49.710 --> 00:11:53.714 align:center line:-1
你能使用正交积分函数来进行整合

00:11:56.416 --> 00:11:58.919 align:center line:-1
新的API简化了代码

00:11:58.986 --> 00:12:02.022 align:center line:-1
好处之一是你能指定被积函数

00:12:02.089 --> 00:12:04.157 align:center line:-1
就是说 被集成的函数

00:12:04.224 --> 00:12:07.661 align:center line:-2
作为一个交易的闭包
而不是一个C函数的指针

00:12:07.728 --> 00:12:10.731 align:center line:-2
这意味着你能很容易的传值到
被积函数

00:12:12.266 --> 00:12:16.670 align:center line:-2
你也要留意积分器现在
是拥有关联值的枚举

00:12:16.737 --> 00:12:20.007 align:center line:-1
所以每次间隔无需提供没有必要的点

00:12:20.073 --> 00:12:21.742 align:center line:-1
或是这里的最大间隔

00:12:23.143 --> 00:12:24.178 align:center line:-1
比如

00:12:24.244 --> 00:12:27.514 align:center line:-1
你可以传递枚举给全局自适应积分器

00:12:27.581 --> 00:12:31.318 align:center line:-1
为间隔和最大间隔指定点

00:12:35.155 --> 00:12:37.424 align:center line:-2
现在
我们来看一下我们为

00:12:37.491 --> 00:12:40.761 align:center line:-2
Accelerate图像处理库
vImage创建的新的API

00:12:41.929 --> 00:12:43.497 align:center line:-1
vImage是一个包含了

00:12:43.564 --> 00:12:46.333 align:center line:-1
丰富的图片处理工具集的库

00:12:46.667 --> 00:12:52.139 align:center line:-2
它被设计在Core Graphics
和Core Video间无缝运作

00:12:52.873 --> 00:12:55.776 align:center line:-1
它包含了比如阿尔法混合

00:12:56.510 --> 00:12:58.612 align:center line:-1
格式转换

00:12:58.679 --> 00:13:00.781 align:center line:-1
直方图操作

00:13:00.848 --> 00:13:02.583 align:center line:-1
卷积

00:13:02.649 --> 00:13:04.017 align:center line:-1
几何学

00:13:04.084 --> 00:13:05.786 align:center line:-1
以及形态的操作

00:13:08.355 --> 00:13:11.391 align:center line:-2
我们新的Swift API
引入了许多新功能

00:13:11.458 --> 00:13:15.562 align:center line:-2
来让大家在Swift中
更容易和简单地使用vImage

00:13:15.629 --> 00:13:17.798 align:center line:-1
我们实现了一个选项集标记

00:13:18.232 --> 00:13:20.801 align:center line:-2
vImages
抛出了Swift错误

00:13:20.868 --> 00:13:23.370 align:center line:-1
我们隐藏了一些可变性的需求

00:13:23.437 --> 00:13:25.806 align:center line:-1
以及处理非托管类型

00:13:27.674 --> 00:13:29.810 align:center line:-2
如果你在使用
Core Graphics图片

00:13:29.877 --> 00:13:31.011 align:center line:-1
这是一个常见的工作流

00:13:31.078 --> 00:13:33.814 align:center line:-2
来将图片数据传入到
一个vImage缓冲中

00:13:35.115 --> 00:13:39.453 align:center line:-2
首先 你需要创建一个
CGImagesFormat描述

00:13:40.320 --> 00:13:42.823 align:center line:-2
接下
实例化一个vImage缓冲

00:13:43.390 --> 00:13:45.425 align:center line:-1
在图片中初始化那个缓冲

00:13:45.492 --> 00:13:48.829 align:center line:-2
最后
以非Swift的方式来检查错误

00:13:49.129 --> 00:13:52.833 align:center line:-2
对于一个常见的操作
有很多样板代码

00:13:54.034 --> 00:13:59.173 align:center line:-2
新的API将所有的那段代码
打包成了一个可抛的初始化器

00:14:04.411 --> 00:14:08.849 align:center line:-2
这是一个使用新的API
分两步实现的类似功能

00:14:09.349 --> 00:14:13.720 align:center line:-2
我们使用一个CGImage为CGImageFormat
添加了一个新的初始化器

00:14:13.787 --> 00:14:16.056 align:center line:-1
和一个额外的缓冲初始化器

00:14:16.123 --> 00:14:19.860 align:center line:-2
它接受了一个CGImage
和一段明确形式的描述

00:14:21.461 --> 00:14:23.497 align:center line:-1
只要你完成了一个缓冲

00:14:23.564 --> 00:14:25.098 align:center line:-1
这是经典的vImage函数

00:14:25.165 --> 00:14:28.335 align:center line:-2
用来在缓冲的内容中
创建一个CGImage

00:14:28.802 --> 00:14:32.072 align:center line:-2
以及我们的新API
也使用一个新的CGImage方法

00:14:32.139 --> 00:14:34.341 align:center line:-1
来简化了那个操作

00:14:34.408 --> 00:14:37.277 align:center line:-1
它使用了我们刚从图片生成的形式

00:14:38.846 --> 00:14:40.781 align:center line:-1
vImage有一个重要的用例

00:14:40.848 --> 00:14:44.585 align:center line:-1
就是在不同的域和形式之间转换

00:14:44.651 --> 00:14:46.620 align:center line:-2
vImage
是一个任意到任意的转换器

00:14:46.687 --> 00:14:49.289 align:center line:-2
能在Core Video和
Core Graphics间转换

00:14:49.656 --> 00:14:52.893 align:center line:-2
且在不同Core Graphics
形式之间转换

00:14:53.961 --> 00:14:59.900 align:center line:-2
比如 你可能想要转换一个CMYK
Core Graphics图片至RGB

00:15:04.271 --> 00:15:07.708 align:center line:-1
接受转换的源和目标格式

00:15:07.774 --> 00:15:09.910 align:center line:-1
返回一个非托管转换器

00:15:11.044 --> 00:15:13.213 align:center line:-1
你获取到转换器的托管引用

00:15:13.280 --> 00:15:15.916 align:center line:-1
传递它给实现转换的函数

00:15:17.918 --> 00:15:20.654 align:center line:-2
我们的新API为已有的转换器类型
添加了一个新的静态make函数

00:15:20.721 --> 00:15:24.925 align:center line:-1
它会返回一个转换器实例

00:15:26.193 --> 00:15:28.395 align:center line:-1
转换由转换器实例的

00:15:28.462 --> 00:15:30.330 align:center line:-1
转换方法完成

00:15:31.131 --> 00:15:35.502 align:center line:-2
最后 我们来了解使用
Core Video图片格式

00:15:35.569 --> 00:15:37.004 align:center line:-1
在一个典型的例子中

00:15:37.070 --> 00:15:39.773 align:center line:-2
你可能想要从
一个Core Video

00:15:39.840 --> 00:15:44.545 align:center line:-2
像素缓冲中创建一个图片格式描述
和计算它的通道数量

00:15:45.445 --> 00:15:48.715 align:center line:-2
这是经典的vImage API
需要从一个像素缓冲中

00:15:48.782 --> 00:15:51.618 align:center line:-1
创建一个图片形式描述的代码

00:15:51.685 --> 00:15:53.153 align:center line:-1
以及获取它的通道数量

00:15:54.421 --> 00:15:56.723 align:center line:-1
新的API用两行代码

00:15:56.790 --> 00:15:58.425 align:center line:-1
提供了相同的功能

00:15:58.792 --> 00:16:01.428 align:center line:-2
你使用一个新的静态make函数
创建了一个来自一个像素

00:16:01.495 --> 00:16:04.965 align:center line:-2
缓冲的Core Video
图片格式的实例

00:16:05.532 --> 00:16:08.969 align:center line:-1
很简单的就访问到它的通道数量属性

00:16:13.307 --> 00:16:16.777 align:center line:-1
这是新的API一小部分的简略介绍

00:16:16.844 --> 00:16:19.146 align:center line:-2
我们现在来看一下
LINPACK基准

00:16:19.213 --> 00:16:21.982 align:center line:-1
来看看它和Accelerate比

00:16:22.049 --> 00:16:23.517 align:center line:-1
有多快和多节能

00:16:24.184 --> 00:16:26.887 align:center line:-2
LINPACK基准
出自于LINPACK库

00:16:26.954 --> 00:16:28.622 align:center line:-1
它开始是一组例程

00:16:28.689 --> 00:16:31.992 align:center line:-1
来提供快速的计算机线性代数

00:16:32.993 --> 00:16:35.829 align:center line:-2
它之后被包含在一个叫做
LApack的库里

00:16:35.896 --> 00:16:37.998 align:center line:-1
它代表着线性代数软件包

00:16:38.899 --> 00:16:41.835 align:center line:-1
LApack被设计用来在调用

00:16:41.902 --> 00:16:43.403 align:center line:-1
缓存时利用好这些新的功能

00:16:43.837 --> 00:16:46.974 align:center line:-1
LApack是由许多阻塞算法组成

00:16:47.040 --> 00:16:50.043 align:center line:-2
这些算法创建在另一个叫做
BLAS库的顶部

00:16:50.110 --> 00:16:53.013 align:center line:-1
它代表着基本的线性代数子例程

00:16:53.981 --> 00:16:56.750 align:center line:-2
我们会在之后的演讲中了解
关于BLAS的更多内容

00:16:56.817 --> 00:16:59.853 align:center line:-1
现在 请记住LINPACK基准

00:16:59.920 --> 00:17:03.023 align:center line:-2
在LApack顶部运行
就是在BLAS的顶部运行

00:17:05.959 --> 00:17:08.161 align:center line:-2
LINPACK基准衡量
一个平台多快能解决一个

00:17:08.228 --> 00:17:12.132 align:center line:-1
一般线性方程组

00:17:12.199 --> 00:17:14.067 align:center line:-1
它包含两个步骤

00:17:14.134 --> 00:17:16.036 align:center line:-1
矩阵分解步骤

00:17:16.103 --> 00:17:18.038 align:center line:-1
接下来的一步是倒推法

00:17:18.472 --> 00:17:19.705 align:center line:-1
通过修正算法

00:17:19.772 --> 00:17:22.041 align:center line:-1
我们能看到不同平台

00:17:22.108 --> 00:17:23.644 align:center line:-1
运行算法时的效果如何

00:17:24.077 --> 00:17:27.513 align:center line:-2
它为我们提供了一个比较
不同平台的方法

00:17:27.881 --> 00:17:30.417 align:center line:-2
LINPACK基准随着时间在
不断发展

00:17:30.684 --> 00:17:34.021 align:center line:-2
最初 它解决了一个
100x100的系统

00:17:34.087 --> 00:17:37.057 align:center line:-1
之后是1000x1000的系统

00:17:38.125 --> 00:17:42.062 align:center line:-2
现在最经常使用的变量
是无拘束变量

00:17:42.296 --> 00:17:45.065 align:center line:-1
问题的尺寸可以是你想要的任何大小

00:17:45.432 --> 00:17:48.068 align:center line:-1
这是我们今天会运行的变量

00:17:49.770 --> 00:17:54.074 align:center line:-2
我们将在一部iPhone 10S
上比较LINPACK的性能表现

00:17:54.141 --> 00:17:55.709 align:center line:-1
最上面 橘色的那个

00:17:55.776 --> 00:17:58.545 align:center line:-2
我们将会运行一个未经优化
的LINPACK

00:17:59.046 --> 00:18:00.247 align:center line:-1
这个Linpack基准

00:18:00.314 --> 00:18:02.683 align:center line:-1
没有使用accelerate框架

00:18:02.983 --> 00:18:07.087 align:center line:-2
它依赖没有优化正在运行
的进程的软件

00:18:07.154 --> 00:18:09.089 align:center line:-1
我们来看看它是怎样的

00:18:11.058 --> 00:18:14.361 align:center line:-2
我们会将它和使用
Accelerate框架做对比

00:18:14.428 --> 00:18:18.732 align:center line:-2
也就是说 我们将会在相同的
平台运行相同的基准

00:18:18.799 --> 00:18:22.836 align:center line:-2
但使用Accelerate框架
它会调整平台

00:18:25.906 --> 00:18:28.775 align:center line:-2
我们能看到使用了
Accelerate框架的那个

00:18:28.842 --> 00:18:31.478 align:center line:-1
快了超过24倍

00:18:31.879 --> 00:18:33.614 align:center line:-1
这不仅会节约时间

00:18:33.680 --> 00:18:36.550 align:center line:-1
也节能 它会延长电池使用寿命

00:18:36.984 --> 00:18:38.385 align:center line:-1
我们现在来改变方式

00:18:38.452 --> 00:18:40.621 align:center line:-1
来看一下LINPACK基准

00:18:40.687 --> 00:18:43.123 align:center line:-1
GEMM的主要使用日常

00:18:45.092 --> 00:18:48.729 align:center line:-2
如我所说 LINPACK
在LApack上运行

00:18:48.795 --> 00:18:50.631 align:center line:-1
创建在BLAS上面

00:18:51.131 --> 00:18:53.200 align:center line:-2
BLAS里的一个叫做
GEMM的例程

00:18:53.267 --> 00:18:56.136 align:center line:-1
它代表着一般的矩阵乘法器

00:18:56.937 --> 00:19:01.208 align:center line:-2
这个例程被用来实现BLAS
中的一些其他阻塞例程

00:19:01.275 --> 00:19:04.611 align:center line:-2
它们在LApack的
阻塞算法中被使用

00:19:04.678 --> 00:19:08.715 align:center line:-1
最显著的是矩阵分解和解算器例程

00:19:09.616 --> 00:19:10.584 align:center line:-1
因此

00:19:10.651 --> 00:19:13.754 align:center line:-2
GEMM有时被用来
作为性能表现的一个代理

00:19:14.021 --> 00:19:15.022 align:center line:-1
为了本次演讲

00:19:15.088 --> 00:19:19.159 align:center line:-2
我们要特别地来看一下GEMM
的单精度变量

00:19:20.527 --> 00:19:23.530 align:center line:-1
这里 我们将要比较Eigen库

00:19:23.597 --> 00:19:25.165 align:center line:-1
和Accelerate的性能表现

00:19:25.465 --> 00:19:28.335 align:center line:-2
Eigen库
和Accelerate框架都

00:19:28.402 --> 00:19:30.704 align:center line:-2
会在一部
iPhone 10S上面运行

00:19:30.971 --> 00:19:34.174 align:center line:-2
它们都会运行一个单精度
的矩阵乘法器

00:19:34.641 --> 00:19:36.844 align:center line:-1
我们来看看Eigen的表现

00:19:38.512 --> 00:19:41.315 align:center line:-2
Eigen的最高速度约为510
亿次浮点运算/秒

00:19:41.381 --> 00:19:44.184 align:center line:-2
现在我们来看一下
Accelerate的表现

00:19:46.153 --> 00:19:49.957 align:center line:-2
可以看到Accelerate框架
在相同的平台

00:19:50.023 --> 00:19:52.192 align:center line:-1
大概比Eigen快了2.5倍

00:19:52.659 --> 00:19:56.663 align:center line:-2
这是因为Accelerate
框架对平台进行了手动调整

00:19:56.730 --> 00:20:00.200 align:center line:-2
它允许我们能完全利用好平台
能提供的优势

00:20:01.101 --> 00:20:03.270 align:center line:-1
那么 如果你是一个开发者

00:20:03.337 --> 00:20:06.473 align:center line:-2
在app中用Accelerate
会提供更好的性能表现

00:20:06.540 --> 00:20:08.876 align:center line:-1
这个性能表现更节能

00:20:08.942 --> 00:20:10.644 align:center line:-1
它意味着更长的电池寿命

00:20:10.711 --> 00:20:14.214 align:center line:-1
和一个对用户整体更好的体验

00:20:15.616 --> 00:20:16.817 align:center line:-1
总结

00:20:16.884 --> 00:20:18.385 align:center line:-1
Accelerat提供了

00:20:18.452 --> 00:20:21.655 align:center line:-1
大规模的数学计算的功能

00:20:21.722 --> 00:20:25.225 align:center line:-1
更快和节能的图像点运算

00:20:25.692 --> 00:20:28.695 align:center line:-2
现在我们加入了一个
Swift友好的API

00:20:28.762 --> 00:20:31.365 align:center line:-1
它让Accelerate库更易用

00:20:31.431 --> 00:20:35.669 align:center line:-2
这样你的用户会从
性能表现和节能中受益

00:20:36.570 --> 00:20:39.373 align:center line:-2
请访问我们的网站
我们提供了示例 文章

00:20:39.439 --> 00:20:41.341 align:center line:-1
和广泛覆盖了整个

00:20:41.408 --> 00:20:44.244 align:center line:-2
Accelerate框架的
参考材料

00:20:44.311 --> 00:20:45.879 align:center line:-1
非常感谢大家

