WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:00.506 --> 00:00:05.516 A:middle
[音乐]

00:00:06.231 --> 00:00:08.231 A:middle
[掌声]

00:00:08.446 --> 00:00:10.006 A:middle
&gt;&gt; 我的名字是 Janum Trivedi

00:00:10.006 --> 00:00:11.466 A:middle
我是 UIKit 框架团队的

00:00:11.496 --> 00:00:12.466 A:middle
一名工程师

00:00:13.696 --> 00:00:15.666 A:middle
首先 我们来谈一谈

00:00:15.666 --> 00:00:18.236 A:middle
构建适用于多个窗口的 App

00:00:18.916 --> 00:00:20.786 A:middle
在 iOS 13 中 支持多个窗口

00:00:20.786 --> 00:00:22.776 A:middle
是一个很好的方法

00:00:22.776 --> 00:00:24.016 A:middle
来使现有的 App 变得更有用

00:00:24.016 --> 00:00:26.006 A:middle
同时大大提高

00:00:26.006 --> 00:00:27.556 A:middle
用户的工作效率

00:00:30.056 --> 00:00:31.576 A:middle
那么今天我们将讨论

00:00:31.576 --> 00:00:32.746 A:middle
三个主要的话题

00:00:33.496 --> 00:00:34.666 A:middle
首先 我们将会

00:00:34.666 --> 00:00:36.436 A:middle
快速浏览一下

00:00:36.436 --> 00:00:38.176 A:middle
对 App 生命周期的更改

00:00:38.226 --> 00:00:39.856 A:middle
它将允许在 iOS 13 上

00:00:39.856 --> 00:00:41.236 A:middle
出现多个窗口

00:00:42.456 --> 00:00:44.856 A:middle
接着 我们会深入研究

00:00:44.856 --> 00:00:47.206 A:middle
新的 UI Scene Delegate

00:00:47.206 --> 00:00:48.436 A:middle
在那里我们还会讨论

00:00:48.436 --> 00:00:49.896 A:middle
你需要完成的工作

00:00:50.486 --> 00:00:52.816 A:middle
最后 我们会回顾一些

00:00:52.816 --> 00:00:54.386 A:middle
ArchitectureKit 中的最佳范例

00:00:54.386 --> 00:00:55.346 A:middle
这样你和你的团队就可以

00:00:55.346 --> 00:00:56.926 A:middle
利用它们来保证

00:00:56.926 --> 00:00:57.906 A:middle
可以给你的用户提供一个

00:00:57.906 --> 00:00:59.506 A:middle
持续的 无缝的

00:00:59.506 --> 00:01:01.236 A:middle
且多任务的体验

00:01:01.796 --> 00:01:06.356 A:middle
那么 首先让我们来看看

00:01:06.356 --> 00:01:07.866 A:middle
在 iOS 12 及之前的版本中

00:01:07.866 --> 00:01:09.046 A:middle
App 代理的一些

00:01:09.106 --> 00:01:10.976 A:middle
作用和职责

00:01:10.976 --> 00:01:14.166 A:middle
App 代理有两个主要的作用

00:01:14.166 --> 00:01:15.436 A:middle
第一是将进程级事件

00:01:15.436 --> 00:01:17.716 A:middle
通知给你的 App

00:01:18.046 --> 00:01:19.286 A:middle
那么 系统会在进程

00:01:19.286 --> 00:01:20.476 A:middle
启动或将要结束的时候

00:01:20.476 --> 00:01:22.656 A:middle
通知你的 App 代理

00:01:23.256 --> 00:01:24.976 A:middle
但它还有第二个作用

00:01:25.326 --> 00:01:26.846 A:middle
就是让你的 App

00:01:26.846 --> 00:01:29.566 A:middle
知道其 UI 的状态

00:01:31.266 --> 00:01:33.446 A:middle
那么 通过一些方法

00:01:33.446 --> 00:01:34.776 A:middle
如 didEnterForeground 和 willResignActive

00:01:34.776 --> 00:01:36.616 A:middle
系统就会让你知道

00:01:36.616 --> 00:01:37.846 A:middle
你的 UI 的状态

00:01:38.446 --> 00:01:41.586 A:middle
这在 iOS 12 及之前的版本中

00:01:41.586 --> 00:01:42.666 A:middle
都是没有问题的

00:01:42.906 --> 00:01:44.686 A:middle
因为 App 有一个进程

00:01:44.686 --> 00:01:46.666 A:middle
同时也只有一个用户界面实例

00:01:46.666 --> 00:01:48.366 A:middle
来与它匹配

00:01:48.936 --> 00:01:51.096 A:middle
那么 今天你的 App 代理

00:01:51.096 --> 00:01:53.976 A:middle
可能看起来会像这样

00:01:53.976 --> 00:01:55.406 A:middle
只是可能没这么短

00:01:55.406 --> 00:01:59.156 A:middle
那么在 didFinishLaunchingWithOptions 中

00:01:59.156 --> 00:02:00.716 A:middle
你完成了几件事

00:02:00.716 --> 00:02:02.706 A:middle
首先你完成了一些

00:02:02.706 --> 00:02:04.536 A:middle
一次性的非 UI 全局设置

00:02:04.596 --> 00:02:05.856 A:middle
比如连接到一个数据库

00:02:05.856 --> 00:02:07.376 A:middle
或者初始化数据结构

00:02:07.996 --> 00:02:09.886 A:middle
之后你立刻设置了

00:02:09.886 --> 00:02:11.136 A:middle
你的用户界面

00:02:11.676 --> 00:02:14.756 A:middle
而同样的 这在 iOS 12

00:02:14.756 --> 00:02:17.006 A:middle
及之前的版本中完全有效

00:02:17.006 --> 00:02:18.156 A:middle
但在 iOS 13 的模式中是无效的

00:02:18.956 --> 00:02:21.186 A:middle
为什么呢 因为现在的 App

00:02:21.466 --> 00:02:23.176 A:middle
虽然只共享一个进程

00:02:23.176 --> 00:02:25.026 A:middle
但可能会有多个

00:02:25.026 --> 00:02:27.576 A:middle
用户界面实例或场景会话

00:02:28.116 --> 00:02:32.406 A:middle
这意味着 App 代理的职责

00:02:32.406 --> 00:02:33.846 A:middle
需要做出一些改变

00:02:34.386 --> 00:02:35.496 A:middle
它仍然会负责

00:02:35.496 --> 00:02:37.106 A:middle
进程事件和生命周期

00:02:37.486 --> 00:02:38.796 A:middle
但它不再负责任何

00:02:38.796 --> 00:02:40.756 A:middle
与 UI 生命周期相关的事情

00:02:41.386 --> 00:02:43.186 A:middle
相反 这些事情都将交给

00:02:43.456 --> 00:02:45.156 A:middle
UI Scene Delegate 来处理

00:02:46.146 --> 00:02:47.716 A:middle
那么 这对你来说意味着什么呢

00:02:48.346 --> 00:02:50.436 A:middle
任何你曾在你的 App 代理中

00:02:50.436 --> 00:02:51.536 A:middle
做过的 UI 设置或拆卸工作

00:02:51.536 --> 00:02:53.716 A:middle
现在都需要迁移到

00:02:53.716 --> 00:02:56.076 A:middle
Scene Delegate 中的相应方法

00:02:56.596 --> 00:02:59.986 A:middle
事实上 在 iOS 13 中

00:02:59.986 --> 00:03:02.006 A:middle
如果你的 App 采用新的

00:03:02.006 --> 00:03:03.876 A:middle
场景生命周期 那 UIKit

00:03:03.876 --> 00:03:05.276 A:middle
将停止调用与 UI 状态相关的

00:03:05.276 --> 00:03:06.976 A:middle
旧的 App 代理方法

00:03:07.686 --> 00:03:09.266 A:middle
相反 我们将会调用新的

00:03:09.696 --> 00:03:11.806 A:middle
Scene Delegate 方法

00:03:11.806 --> 00:03:12.936 A:middle
这很简单 因为这些

00:03:13.406 --> 00:03:15.316 A:middle
大多数都是一一对应的映射

00:03:16.246 --> 00:03:18.346 A:middle
但是不要担心 如果你想要

00:03:18.346 --> 00:03:19.696 A:middle
在 iOS 13 上采用多窗口支持

00:03:19.696 --> 00:03:21.146 A:middle
这并不意味着你需要

00:03:21.146 --> 00:03:23.066 A:middle
丢掉 iOS 12 及之前的支持

00:03:23.776 --> 00:03:25.366 A:middle
如果你要向后部署

00:03:25.366 --> 00:03:26.676 A:middle
你可以简单地将两组方法

00:03:26.676 --> 00:03:28.356 A:middle
都保留下来 UIKit 就会

00:03:28.356 --> 00:03:30.586 A:middle
在运行时调用正确的方法

00:03:31.106 --> 00:03:35.086 A:middle
那么 在我们深入讨论

00:03:35.086 --> 00:03:36.886 A:middle
具体的代理方法之前

00:03:36.886 --> 00:03:37.876 A:middle
App 代理还有

00:03:37.876 --> 00:03:40.206 A:middle
一个另外的职责

00:03:40.466 --> 00:03:41.756 A:middle
即系统会通知

00:03:41.756 --> 00:03:43.436 A:middle
你的 App 代理

00:03:43.436 --> 00:03:44.886 A:middle
当创建一个新的场景会话

00:03:44.886 --> 00:03:48.176 A:middle
或丢弃一个现有的场景会话时

00:03:48.176 --> 00:03:51.276 A:middle
我们来将这个生命周期

00:03:51.326 --> 00:03:52.786 A:middle
变得更具体一点

00:03:53.196 --> 00:03:54.316 A:middle
假设我一直在做

00:03:54.316 --> 00:03:55.806 A:middle
这个蓝色的 App 

00:03:55.806 --> 00:03:57.246 A:middle
而现在我要首次将它启动

00:03:57.456 --> 00:03:58.556 A:middle
我们来看看调用栈

00:03:59.606 --> 00:04:01.826 A:middle
首先 你的 App 代理

00:04:01.826 --> 00:04:02.996 A:middle
要进行相同的 

00:04:02.996 --> 00:04:04.016 A:middle
didFinishLaunchingWithOptions 调用

00:04:04.246 --> 00:04:05.536 A:middle
同样 在这里进行一次性的

00:04:05.536 --> 00:04:07.716 A:middle
非 UI 设置 是没有问题的

00:04:08.276 --> 00:04:10.906 A:middle
之后 系统会立即

00:04:10.906 --> 00:04:12.936 A:middle
创建一个场景会话

00:04:13.906 --> 00:04:15.306 A:middle
但在它创建具体的 UIScene 之前

00:04:15.306 --> 00:04:16.875 A:middle
它会要求我们的 App

00:04:16.875 --> 00:04:19.685 A:middle
进行 UIScene 配置

00:04:20.226 --> 00:04:21.946 A:middle
这个配置会指定

00:04:22.156 --> 00:04:24.086 A:middle
Scene Delegate 和 Storyboard

00:04:24.086 --> 00:04:25.606 A:middle
以及假设你指定了

00:04:25.606 --> 00:04:27.106 A:middle
你想要用什么场景子类

00:04:27.106 --> 00:04:28.116 A:middle
来创建场景

00:04:29.366 --> 00:04:31.376 A:middle
值得注意的是

00:04:31.376 --> 00:04:33.026 A:middle
你可以定义

00:04:33.026 --> 00:04:34.046 A:middle
这些场景配置

00:04:34.046 --> 00:04:36.136 A:middle
可以动态地在代码中定义

00:04:36.136 --> 00:04:38.986 A:middle
或静态地在 info.plist 中定义

00:04:40.326 --> 00:04:43.726 A:middle
这也为你提供了选择正确的配置的机会

00:04:44.116 --> 00:04:45.266 A:middle
你可以有一个主要的场景配置

00:04:45.266 --> 00:04:48.046 A:middle
你也可以有一个附属场景

00:04:48.466 --> 00:04:49.306 A:middle
那么 你应该看看

00:04:49.306 --> 00:04:50.466 A:middle
这里提供的可选参数

00:04:50.466 --> 00:04:52.536 A:middle
并将它作为上下文

00:04:52.536 --> 00:04:55.386 A:middle
来选择正确的场景配置

00:04:55.886 --> 00:05:00.536 A:middle
一旦你定义了这些

00:05:00.536 --> 00:05:02.476 A:middle
比如说在 info.plist 文件中

00:05:02.476 --> 00:05:04.136 A:middle
这个很简单 你只需要按名称引用它

00:05:04.486 --> 00:05:06.436 A:middle
确保你将传入的作用是

00:05:06.436 --> 00:05:08.196 A:middle
引入的会话的作用

00:05:10.536 --> 00:05:12.886 A:middle
好了 现在我们的 App 就启动了

00:05:13.146 --> 00:05:14.626 A:middle
我们有一个场景会话

00:05:14.856 --> 00:05:16.026 A:middle
但我们没有看到任何 UI

00:05:16.026 --> 00:05:17.606 A:middle
这就是我们的 Scene Delegate

00:05:18.406 --> 00:05:21.066 A:middle
连接到场景会话的地方

00:05:22.036 --> 00:05:23.406 A:middle
我们来看看在这里

00:05:23.406 --> 00:05:23.966 A:middle
我们应该做什么呢

00:05:23.966 --> 00:05:25.046 A:middle
在这里 你用新指定的

00:05:25.046 --> 00:05:27.676 A:middle
UI 窗口初始化器

00:05:27.756 --> 00:05:29.516 A:middle
设置 UI 窗口

00:05:29.806 --> 00:05:31.126 A:middle
我们会注意到我们传入了

00:05:31.126 --> 00:05:32.286 A:middle
提供的窗口场景

00:05:32.976 --> 00:05:35.426 A:middle
但重要的是我们还需要

00:05:35.426 --> 00:05:37.636 A:middle
检查任何相关的

00:05:37.636 --> 00:05:40.626 A:middle
用户活动或状态恢复

00:05:40.626 --> 00:05:42.806 A:middle
以配置我们的窗口

00:05:43.376 --> 00:05:45.500 A:middle
我们待会再详细讨论这个

00:05:47.046 --> 00:05:48.746 A:middle
好 现在来看我们的 App

00:05:49.376 --> 00:05:50.856 A:middle
那么 当我们的一个用户

00:05:50.856 --> 00:05:52.996 A:middle
向上划动返回主页时会发生什么呢

00:05:54.426 --> 00:05:57.226 A:middle
我们熟悉的 willResignActive

00:05:57.226 --> 00:05:58.746 A:middle
和 didEnterBackground 方法

00:05:58.746 --> 00:06:01.306 A:middle
会在你的 Scene Delegate 上被调用

00:06:01.956 --> 00:06:03.266 A:middle
但现在有一些有趣的事情

00:06:03.826 --> 00:06:05.586 A:middle
在此之后的某个时刻

00:06:05.816 --> 00:06:07.456 A:middle
你的场景可能会断开连接

00:06:07.736 --> 00:06:08.896 A:middle
那么 这意味着什么呢

00:06:09.116 --> 00:06:10.276 A:middle
好 为了回收资源

00:06:10.276 --> 00:06:13.036 A:middle
系统可能会

00:06:13.036 --> 00:06:14.356 A:middle
在你的场景

00:06:14.356 --> 00:06:15.826 A:middle
进入后台的某个时候

00:06:15.826 --> 00:06:16.786 A:middle
从内存中释放该场景

00:06:17.096 --> 00:06:18.616 A:middle
这也意味着你的

00:06:18.616 --> 00:06:20.096 A:middle
Scene Delegate 将会

00:06:20.386 --> 00:06:21.716 A:middle
从内存中被释放

00:06:21.716 --> 00:06:23.206 A:middle
而该代理中所持有的

00:06:23.436 --> 00:06:25.986 A:middle
任何窗口层级或视图层级也将被释放

00:06:27.236 --> 00:06:29.126 A:middle
这给你提供了机会

00:06:29.126 --> 00:06:31.016 A:middle
来释放 App 中

00:06:31.016 --> 00:06:32.256 A:middle
与此场景相关的 

00:06:32.256 --> 00:06:33.676 A:middle
保留在其他地方的

00:06:33.676 --> 00:06:36.406 A:middle
内存中的任何大型资源

00:06:37.276 --> 00:06:38.916 A:middle
但是重要的是 不要用它

00:06:38.916 --> 00:06:40.336 A:middle
来永久删除任何

00:06:40.336 --> 00:06:41.976 A:middle
用户数据或状态

00:06:42.226 --> 00:06:43.926 A:middle
因为该场景稍后可能会

00:06:43.926 --> 00:06:44.726 A:middle
重新连接并返回

00:06:48.236 --> 00:06:49.966 A:middle
接着我们讨论一下

00:06:49.966 --> 00:06:51.996 A:middle
当我们的用户真的

00:06:51.996 --> 00:06:53.966 A:middle
在切换器上上划一个场景会话

00:06:53.966 --> 00:06:55.436 A:middle
并明确地想要销毁它时

00:06:55.436 --> 00:06:57.526 A:middle
会发生什么呢

00:06:57.746 --> 00:06:59.326 A:middle
那么 系统会调用我们的

00:06:59.326 --> 00:07:01.716 A:middle
App 代理 didDiscardSceneSessions

00:07:04.016 --> 00:07:06.556 A:middle
这让我们终于能够真正永久地

00:07:06.556 --> 00:07:08.106 A:middle
代理任何与该场景有关的

00:07:08.106 --> 00:07:09.296 A:middle
用户状态或数据

00:07:09.296 --> 00:07:11.326 A:middle
比如一个文档编辑 App 中

00:07:11.326 --> 00:07:13.306 A:middle
未保存的草稿

00:07:14.086 --> 00:07:16.176 A:middle
现在 也有可能

00:07:16.176 --> 00:07:17.856 A:middle
你的一个用户从切换器中

00:07:17.856 --> 00:07:19.356 A:middle
移除了一个或多个 UI 场景

00:07:19.356 --> 00:07:21.176 A:middle
通过在你的 App 进程

00:07:21.176 --> 00:07:22.446 A:middle
还未真正运行时向上划动

00:07:23.316 --> 00:07:24.586 A:middle
如果你的进程还没有运行

00:07:24.586 --> 00:07:25.746 A:middle
系统就会记录下
 
00:07:25.746 --> 00:07:27.536 A:middle
被丢弃的会话

00:07:27.536 --> 00:07:28.516 A:middle
在你的 App 下次启动后

00:07:28.516 --> 00:07:29.796 A:middle
快速调用该会话

00:07:34.726 --> 00:07:36.136 A:middle
现在 我们来讨论一些

00:07:36.136 --> 00:07:37.616 A:middle
构建模式 你可以考虑

00:07:37.616 --> 00:07:39.346 A:middle
将它们融入你的 App 中

00:07:39.886 --> 00:07:44.476 A:middle
我们首先来说说状态恢复

00:07:45.786 --> 00:07:48.086 A:middle
在 iOS 13 中 状态恢复

00:07:48.086 --> 00:07:49.536 A:middle
不再是一个好东西

00:07:50.136 --> 00:07:52.216 A:middle
至关重要的是

00:07:52.216 --> 00:07:53.416 A:middle
你的 App 要实现

00:07:53.416 --> 00:07:55.206 A:middle
基于场景的状态恢复

00:07:55.926 --> 00:07:57.126 A:middle
我们来看看这是为什么

00:07:58.426 --> 00:07:59.286 A:middle
这是我们的 App 切换器

00:07:59.406 --> 00:08:01.286 A:middle
我有一个文档 App

00:08:01.286 --> 00:08:02.356 A:middle
我正在计划一次自驾游

00:08:02.436 --> 00:08:03.416 A:middle
我现在打开了四个

00:08:03.416 --> 00:08:04.756 A:middle
不同文档的不同会话

00:08:05.716 --> 00:08:07.006 A:middle
但是我真正关注的

00:08:07.236 --> 00:08:08.506 A:middle
是“行李清单”和“日程安排”

00:08:09.556 --> 00:08:12.176 A:middle
在某一时刻 另外两个

00:08:12.176 --> 00:08:13.226 A:middle
在后台上的“自驾游”

00:08:13.226 --> 00:08:14.486 A:middle
和“出席者”的场景

00:08:14.486 --> 00:08:16.616 A:middle
已经被系统断开连接并释放

00:08:17.466 --> 00:08:18.896 A:middle
如果我在这里

00:08:18.896 --> 00:08:20.886 A:middle
不实现状态恢复的话

00:08:20.886 --> 00:08:21.896 A:middle
当我回到“自驾游”时

00:08:21.896 --> 00:08:23.546 A:middle
我就不会回到之前

00:08:23.546 --> 00:08:24.256 A:middle
所在的状态

00:08:24.256 --> 00:08:25.056 A:middle
我不会回到我之前

00:08:25.056 --> 00:08:26.336 A:middle
正在编辑的文档的场景

00:08:27.136 --> 00:08:28.176 A:middle
而是会直接重新开始

00:08:28.176 --> 00:08:29.296 A:middle
就像打开一个全新的窗口

00:08:29.296 --> 00:08:31.776 A:middle
但这并不是一个很好的用户体验

00:08:33.196 --> 00:08:34.275 A:middle
那么 如何解决这个问题呢

00:08:34.946 --> 00:08:36.645 A:middle
iOS 13 有一个全新的

00:08:37.346 --> 00:08:39.806 A:middle
基于场景的状态恢复的 API

00:08:40.155 --> 00:08:41.576 A:middle
它非常简单

00:08:42.816 --> 00:08:47.486 A:middle
就是不再对视图层级进行编码

00:08:47.606 --> 00:08:49.496 A:middle
而是对允许重新

00:08:49.496 --> 00:08:51.996 A:middle
创建窗口的状态进行编码

00:08:54.356 --> 00:08:56.946 A:middle
这也全部都基于 NSUserActivity

00:08:56.946 --> 00:08:57.856 A:middle
因此 如果你的 App

00:08:57.856 --> 00:08:59.376 A:middle
利用了功能强大的技术

00:08:59.376 --> 00:09:00.696 A:middle
比如聚焦搜索或接力

00:09:00.696 --> 00:09:02.336 A:middle
那你就可以用这些相同的活动

00:09:02.336 --> 00:09:04.136 A:middle
来对你 App 的状态进行编码

00:09:04.796 --> 00:09:06.076 A:middle
我们也要注意

00:09:06.076 --> 00:09:08.196 A:middle
在 iOS 13 中 你返回给

00:09:08.196 --> 00:09:09.646 A:middle
系统的状态恢复存档

00:09:09.646 --> 00:09:13.236 A:middle
将会匹配 App 中的其余部分的

00:09:13.236 --> 00:09:14.336 A:middle
相同数据保护类

00:09:17.756 --> 00:09:20.906 A:middle
这在代码中是怎样的呢

00:09:20.906 --> 00:09:22.156 A:middle
那么 在我们的 Scene Delegate 中

00:09:22.156 --> 00:09:23.356 A:middle
我们实现场景的

00:09:23.356 --> 00:09:25.796 A:middle
状态恢复活动

00:09:25.796 --> 00:09:29.346 A:middle
然后我调用一个方法

00:09:29.346 --> 00:09:31.506 A:middle
来在现有的窗口中寻找

00:09:31.506 --> 00:09:33.496 A:middle
最活跃的相关用户活动表

00:09:34.046 --> 00:09:35.526 A:middle
然后我们回到该表

00:09:36.276 --> 00:09:38.366 A:middle
过一些时候 当该场景

00:09:38.366 --> 00:09:41.746 A:middle
重新进入前台且连接成功时

00:09:41.746 --> 00:09:43.176 A:middle
我们检查该会话是否含有一个

00:09:43.176 --> 00:09:44.286 A:middle
状态恢复活动

00:09:44.896 --> 00:09:47.076 A:middle
如果有 我们就用该活动

00:09:47.586 --> 00:09:48.656 A:middle
如果没有 我们可以创建一个

00:09:48.656 --> 00:09:50.776 A:middle
全新的没有任何状态的窗口

00:09:51.886 --> 00:09:53.546 A:middle
这意味着无论如何

00:09:54.026 --> 00:09:55.396 A:middle
当场景在后台断开连接时

00:09:55.396 --> 00:09:57.026 A:middle
我们的用户永远不会注意到

00:09:57.026 --> 00:09:58.626 A:middle
因为这不应该被注意到

00:10:03.156 --> 00:10:05.346 A:middle
在采用多个窗口的支持时

00:10:05.346 --> 00:10:06.816 A:middle
你可能会遇到的

00:10:06.816 --> 00:10:08.026 A:middle
一个更重要的问题

00:10:08.196 --> 00:10:09.756 A:middle
也就是如何最大程度地

00:10:09.756 --> 00:10:11.496 A:middle
保持 App 场景的同步

00:10:11.496 --> 00:10:13.656 A:middle
让我来把它具体化

00:10:13.796 --> 00:10:15.256 A:middle
我一直在做一个新的

00:10:15.256 --> 00:10:17.396 A:middle
聊天 App 就在这里

00:10:17.396 --> 00:10:18.866 A:middle
而我们可以看到

00:10:18.866 --> 00:10:20.456 A:middle
我最近刚在 iOS 13 上添加了

00:10:20.456 --> 00:10:21.236 A:middle
对多个窗口的支持

00:10:22.636 --> 00:10:23.666 A:middle
我有一个与我的朋友

00:10:23.666 --> 00:10:25.786 A:middle
Giovanni 的聊天

00:10:25.786 --> 00:10:27.086 A:middle
几分钟后他将和我一起上台

00:10:27.736 --> 00:10:28.896 A:middle
注意 我们正在同时

00:10:28.896 --> 00:10:30.046 A:middle
查看相同的对话

00:10:30.046 --> 00:10:31.076 A:middle
在两个不同的视图控制器

00:10:31.076 --> 00:10:32.886 A:middle
及两个不同的场景中

00:10:34.036 --> 00:10:35.276 A:middle
那么 我们假设我要

00:10:35.276 --> 00:10:36.826 A:middle
给 Giovanni 发送一条信息

00:10:36.826 --> 00:10:37.846 A:middle
告诉他我准备好吃午饭了

00:10:39.056 --> 00:10:41.376 A:middle
那么 只有一个场景更新了

00:10:42.176 --> 00:10:43.706 A:middle
所以这是为什么呢

00:10:44.876 --> 00:10:46.816 A:middle
好 这是因为在 iOS 中

00:10:46.816 --> 00:10:47.976 A:middle
许多 App 的结构都是这样

00:10:47.976 --> 00:10:49.486 A:middle
视图控制器会

00:10:49.486 --> 00:10:51.026 A:middle
接收一个事件

00:10:51.446 --> 00:10:52.766 A:middle
可能是通过点击按钮

00:10:52.766 --> 00:10:53.846 A:middle
即我按下发送按钮

00:10:54.426 --> 00:10:56.086 A:middle
然后视图控制器本就

00:10:56.086 --> 00:10:57.786 A:middle
就会更新它自己的 UI

00:10:58.716 --> 00:11:00.166 A:middle
之后 我们的视图控制器

00:11:00.166 --> 00:11:02.436 A:middle
会通知模型或模型控制器

00:11:02.436 --> 00:11:05.266 A:middle
而当我们只讨论

00:11:05.266 --> 00:11:07.046 A:middle
一个用户界面实例时

00:11:07.046 --> 00:11:07.856 A:middle
这基本上是没问题的

00:11:08.466 --> 00:11:10.146 A:middle
但现在如果我们在一个

00:11:10.796 --> 00:11:11.816 A:middle
显示相同数据的不同场景中

00:11:11.816 --> 00:11:13.166 A:middle
引入第二个视图控制器

00:11:13.166 --> 00:11:15.296 A:middle
那么无论什么时候

00:11:15.296 --> 00:11:16.666 A:middle
这个新的视图控制器都不会

00:11:16.906 --> 00:11:18.916 A:middle
收到通知来更新这个新数据

00:11:19.816 --> 00:11:20.446 A:middle
这是一个问题

00:11:20.966 --> 00:11:24.556 A:middle
那么我们可以解决这个问题

00:11:24.606 --> 00:11:25.976 A:middle
在架构上 如果我们的

00:11:25.976 --> 00:11:27.186 A:middle
视图控制器能够

00:11:27.186 --> 00:11:29.536 A:middle
在接收到一个事件后

00:11:29.536 --> 00:11:31.356 A:middle
立即并且只通知

00:11:31.736 --> 00:11:32.986 A:middle
我们的模型控制器 

00:11:32.986 --> 00:11:35.416 A:middle
那我们就可以让模型控制器

00:11:35.416 --> 00:11:36.686 A:middle
通知任何相关的订阅者

00:11:36.686 --> 00:11:37.946 A:middle
或者视图控制器

00:11:37.946 --> 00:11:39.996 A:middle
来更新这个新数据

00:11:41.416 --> 00:11:43.196 A:middle
有许多方法都可以完成这个

00:11:43.196 --> 00:11:45.046 A:middle
我们可以使用代理和通知

00:11:45.376 --> 00:11:46.696 A:middle
我们甚至可以用全新的

00:11:46.696 --> 00:11:48.836 A:middle
今年发布的 Swift Combine 框架

00:11:49.716 --> 00:11:51.116 A:middle
但我们先来看一个

00:11:51.116 --> 00:11:52.526 A:middle
简单的 Swift 示例

00:11:52.526 --> 00:11:54.096 A:middle
你可以考虑将其整合进你的 App 中

00:11:54.666 --> 00:11:55.976 A:middle
这是现在的方法

00:11:55.976 --> 00:11:57.356 A:middle
当我在发送信息时按下

00:11:57.566 --> 00:11:59.336 A:middle
返回键时 它就会被调用

00:11:59.936 --> 00:12:01.426 A:middle
我创建了一个信息模型对象

00:12:02.056 --> 00:12:03.306 A:middle
我的视图控制器更新

00:12:03.306 --> 00:12:03.866 A:middle
其自己的视图

00:12:04.446 --> 00:12:07.096 A:middle
接着我们通知模型控制器

00:12:07.096 --> 00:12:08.746 A:middle
来保存这个

00:12:09.286 --> 00:12:11.056 A:middle
我们首先要做的

00:12:11.056 --> 00:12:11.916 A:middle
就是让该视图控制器

00:12:12.236 --> 00:12:14.406 A:middle
不改变它自己的视图状态

00:12:14.886 --> 00:12:16.646 A:middle
相反 我们要去掉这些代码

00:12:16.746 --> 00:12:18.836 A:middle
稍后我们会把它加回去

00:12:20.846 --> 00:12:22.706 A:middle
现在 我们来看看

00:12:22.706 --> 00:12:25.446 A:middle
该模型控制器 add() 方法到底在做什么

00:12:25.446 --> 00:12:26.576 A:middle
其实很简单

00:12:27.206 --> 00:12:28.406 A:middle
我们要做的就是

00:12:28.406 --> 00:12:29.176 A:middle
保存该新消息

00:12:30.096 --> 00:12:31.286 A:middle
但实际上我们想让

00:12:31.286 --> 00:12:33.556 A:middle
模型控制器立刻进行通知

00:12:33.556 --> 00:12:34.526 A:middle
如果任何其他视图控制器

00:12:34.526 --> 00:12:36.476 A:middle
或连接的场景需要的更新的话

00:12:39.496 --> 00:12:41.186 A:middle
我们如何发送这个更新呢

00:12:41.636 --> 00:12:43.936 A:middle
我们需要一种结构化的方法

00:12:43.936 --> 00:12:46.276 A:middle
来打包这个事件

00:12:46.276 --> 00:12:49.366 A:middle
这样它就成为强类型

00:12:49.616 --> 00:12:51.166 A:middle
且易于调试和测试

00:12:51.446 --> 00:12:52.576 A:middle
那么 我们来继续创建

00:12:52.576 --> 00:12:54.116 A:middle
一个新的类型

00:12:54.116 --> 00:12:55.206 A:middle
我们称之为 UpdateEvent

00:12:55.206 --> 00:12:57.536 A:middle
它是一个带有相关值的 Swift 枚举

00:12:58.066 --> 00:13:00.026 A:middle
我们将添加一个新的消息类型

00:13:00.676 --> 00:13:02.276 A:middle
这是我们的模型控制器

00:13:02.276 --> 00:13:03.506 A:middle
将要在接收新的消息时

00:13:03.506 --> 00:13:04.836 A:middle
创建的对象

00:13:04.836 --> 00:13:06.626 A:middle
然后会发送给任何的

00:13:06.626 --> 00:13:08.456 A:middle
相关的视图控制器或场景

00:13:09.656 --> 00:13:10.896 A:middle
因为我们想发送这个

00:13:10.896 --> 00:13:12.496 A:middle
我们将用 NSNotificationCenter

00:13:12.716 --> 00:13:14.076 A:middle
作为这个的备份存储

00:13:14.076 --> 00:13:15.826 A:middle
因此 我们会添加这个便利的

00:13:15.826 --> 00:13:17.636 A:middle
post() 方法 它允许我们在一行中

00:13:17.846 --> 00:13:19.286 A:middle
创建一个新的更新事件

00:13:19.286 --> 00:13:20.896 A:middle
然后将其发送给任何订阅者

00:13:21.456 --> 00:13:25.166 A:middle
实现这个相当简单

00:13:25.236 --> 00:13:27.006 A:middle
我们只要发送一个通知

00:13:27.006 --> 00:13:29.646 A:middle
到新消息的通知名称通道

00:13:30.126 --> 00:13:31.376 A:middle
但这里的技巧是

00:13:31.376 --> 00:13:32.696 A:middle
我们要将更新事件对象本身

00:13:32.926 --> 00:13:35.766 A:middle
包含在通知对象中

00:13:35.766 --> 00:13:37.096 A:middle
这会派上用场

00:13:37.096 --> 00:13:41.446 A:middle
我们很快就会看到

00:13:41.576 --> 00:13:42.956 A:middle
现在 当我们的模型控制器

00:13:42.956 --> 00:13:44.166 A:middle
被通知添加了一个新消息时

00:13:44.166 --> 00:13:45.926 A:middle
在我们保存它之后

00:13:46.196 --> 00:13:47.166 A:middle
我们就可以创建这个新事件

00:13:47.166 --> 00:13:49.066 A:middle
并调用 post()

00:13:51.546 --> 00:13:53.466 A:middle
接着 如果我们看看

00:13:53.496 --> 00:13:54.696 A:middle
要如何改变我们的视图控制器

00:13:55.436 --> 00:13:57.396 A:middle
我们会注意到这个新事件

00:13:57.676 --> 00:13:59.836 A:middle
在本例里 就是新消息通知名称

00:14:03.366 --> 00:14:06.066 A:middle
从参数中获取通知

00:14:06.816 --> 00:14:08.126 A:middle
记住 当我们将更新事件

00:14:08.126 --> 00:14:12.426 A:middle
作为通知对象进行传递时

00:14:12.546 --> 00:14:14.076 A:middle
我们现在就可以从通知中

00:14:14.076 --> 00:14:15.426 A:middle
直接拉出该事件

00:14:15.946 --> 00:14:18.736 A:middle
然后我们可以很容易地

00:14:18.736 --> 00:14:20.506 A:middle
打开这种事件类型情况

00:14:21.796 --> 00:14:22.886 A:middle
因为我们创建了一个相关枚举

00:14:22.886 --> 00:14:26.726 A:middle
我们就可以把信息拉出来

00:14:26.986 --> 00:14:29.326 A:middle
现在 我们可以更新这里的用户界面

00:14:32.536 --> 00:14:33.736 A:middle
那么 让我们来看看

00:14:33.736 --> 00:14:34.896 A:middle
在实现这个新的构架之后

00:14:34.896 --> 00:14:37.496 A:middle
当我向 Giovanni 发送相同的消息时会发生什么呢

00:14:38.196 --> 00:14:39.696 A:middle
好了 所有的场景都更新了

00:14:41.516 --> 00:14:45.876 A:middle
[掌声]

00:14:46.376 --> 00:14:47.866 A:middle
那么 我们今天讲了很多

00:14:48.076 --> 00:14:48.976 A:middle
我们已经讲了一些

00:14:48.976 --> 00:14:51.736 A:middle
App 代理和 Scene Delegate 的不同

00:14:51.736 --> 00:14:53.296 A:middle
及其职责的不同

00:14:53.696 --> 00:14:54.806 A:middle
我们之前还说了一些

00:14:54.806 --> 00:14:57.586 A:middle
主要的 Scene Delegate 方法

00:14:57.586 --> 00:14:59.066 A:middle
及你应该做的工作

00:15:01.306 --> 00:15:02.736 A:middle
状态恢复在你使用

00:15:02.736 --> 00:15:04.616 A:middle
iOS 13 时是如此的重要

00:15:04.616 --> 00:15:06.726 A:middle
以及如何利用新的

00:15:06.896 --> 00:15:07.926 A:middle
基于场景的 API 来完成它

00:15:08.606 --> 00:15:11.166 A:middle
最后 我们说了一些

00:15:11.166 --> 00:15:12.596 A:middle
创建一个单向数据流的

00:15:12.596 --> 00:15:14.066 A:middle
高级的模式 这样我们

00:15:14.066 --> 00:15:15.296 A:middle
就可以在共享相同的数据时

00:15:15.296 --> 00:15:17.716 A:middle
保持所有的场景同步 谢谢

00:15:19.508 --> 00:15:21.508 A:middle
[掌声]

