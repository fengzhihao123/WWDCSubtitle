WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:07.007 --> 00:00:12.079 align:center line:0
（Foundation进阶）

00:00:12.813 --> 00:00:14.014 align:center line:-1
大家好

00:00:14.381 --> 00:00:15.682 align:center line:-1
我是Tina

00:00:16.183 --> 00:00:18.585 align:center line:-2
我是Foundation团队的
一名工程师

00:00:18.652 --> 00:00:22.689 align:center line:-2
我将会讲解我们为Foundation
添加新API的亮点

00:00:22.756 --> 00:00:25.325 align:center line:-2
现在 我们开始介绍
这些API亮点

00:00:25.859 --> 00:00:29.029 align:center line:-1
我们今天会介绍很多不同的内容

00:00:31.665 --> 00:00:34.034 align:center line:-1
我们从有序集合的diff比较开始

00:00:34.535 --> 00:00:38.071 align:center line:-2
它是一个API
这个API允许你在不同集合之间

00:00:38.138 --> 00:00:40.874 align:center line:-1
计算 编码以及比较之间的差异

00:00:41.642 --> 00:00:44.411 align:center line:-1
我用一个故事来向你们说明

00:00:44.912 --> 00:00:48.615 align:center line:-2
一个bear字符非常
想转换成为bird字符

00:00:49.183 --> 00:00:50.684 align:center line:-1
我们来了解如何实现

00:00:50.751 --> 00:00:52.319 align:center line:-1
（有序集合的diff比较）

00:00:52.386 --> 00:00:56.723 align:center line:-2
我们注意到bird中
没有bear的E和A

00:00:57.558 --> 00:01:00.794 align:center line:-1
它还需要bird中的I和D

00:01:01.962 --> 00:01:05.199 align:center line:-1
那么 我们来移掉E和A

00:01:05.766 --> 00:01:07.634 align:center line:-1
在中间插入一个I

00:01:08.302 --> 00:01:09.570 align:center line:-1
在最后插入一个D

00:01:10.771 --> 00:01:13.807 align:center line:-2
这样我们移除了两个
又增加了两个

00:01:13.874 --> 00:01:16.543 align:center line:-1
来将bear变为bird

00:01:18.545 --> 00:01:22.282 align:center line:-2
使用有序集合diff比较的API
可以非常容易实现

00:01:24.418 --> 00:01:27.287 align:center line:-2
这里的diff是一个集合的
difference类型

00:01:27.855 --> 00:01:30.791 align:center line:-1
它是插入和移除的一个集合

00:01:31.058 --> 00:01:34.661 align:center line:-1
表示插入和移除的元素

00:01:35.262 --> 00:01:37.898 align:center line:-1
以及集合中元素的偏移量

00:01:38.765 --> 00:01:42.769 align:center line:-2
你刚才看到的 它包含了两个
插入和两个移除

00:01:45.105 --> 00:01:48.742 align:center line:-2
我们可以在bear上使用diff
来得到一个新的bird字符串

00:01:49.476 --> 00:01:53.447 align:center line:-2
这是一个非常强大的API
它不仅仅运用于字符串上

00:01:53.714 --> 00:01:55.048 align:center line:-1
任何集合类型都可以

00:01:55.115 --> 00:01:57.084 align:center line:-1
这就是有序集合的diff比较

00:01:57.451 --> 00:01:59.953 align:center line:-1
下面 我们来讲一下数据和连续性

00:02:01.121 --> 00:02:05.292 align:center line:-2
你的app可能会在硬盘里创建
图片或其他类型的文件

00:02:05.859 --> 00:02:09.963 align:center line:-1
通常 这些样式的数据

00:02:10.030 --> 00:02:12.366 align:center line:-1
能很容易地在内存中相连区中展示

00:02:14.001 --> 00:02:15.102 align:center line:-1
另一方面

00:02:15.435 --> 00:02:18.172 align:center line:-2
你的app可能使用比如调度数据
或URL会话

00:02:18.238 --> 00:02:21.608 align:center line:-1
从互联网上下载数据

00:02:22.309 --> 00:02:23.610 align:center line:-1
这会产生字节

00:02:23.677 --> 00:02:26.547 align:center line:-1
在不同时间产生多个块

00:02:26.813 --> 00:02:29.950 align:center line:-1
占据内存中的相连区域

00:02:32.219 --> 00:02:33.754 align:center line:-1
在Swift 5以前

00:02:34.021 --> 00:02:38.192 align:center line:-1
数据结构表示连续和不连续区域

00:02:38.825 --> 00:02:41.929 align:center line:-1
这个统一的界面使用起来很简单

00:02:42.663 --> 00:02:45.532 align:center line:-1
但是它也代表将整个缓存

00:02:45.599 --> 00:02:47.267 align:center line:-1
放置底层原始字节

00:02:47.601 --> 00:02:51.305 align:center line:-2
我们需要复制这个区域
到一个连续的区域

00:02:53.106 --> 00:02:56.677 align:center line:-2
这意味着有时候会有无法预知的
行为表现

00:02:57.277 --> 00:03:01.415 align:center line:-1
事实上 我们知道数据真实使用情况

00:03:02.015 --> 00:03:03.884 align:center line:-1
每个不连续的数据

00:03:03.951 --> 00:03:06.620 align:center line:-1
在它的生命周期中有时畅通无阻

00:03:09.022 --> 00:03:13.660 align:center line:-2
所以 从Swift 5开始
我们将结构数据定义为

00:03:13.727 --> 00:03:15.562 align:center line:-1
一个连续的缓存类型

00:03:16.296 --> 00:03:21.935 align:center line:-2
为在语法中施行该协议 我们引入了
ContiguousBytes协议

00:03:23.203 --> 00:03:25.372 align:center line:-1
为了遵循这个协议

00:03:25.439 --> 00:03:29.309 align:center line:-1
这个类型提供以直接

00:03:29.610 --> 00:03:31.078 align:center line:-1
连续的方式进入底层原始字节

00:03:31.545 --> 00:03:32.913 align:center line:-1
所以 你再也不必担心

00:03:32.980 --> 00:03:35.749 align:center line:-1
意外地接触到你的数据了

00:03:37.084 --> 00:03:40.320 align:center line:-1
现在 我们是如何处理其他

00:03:40.387 --> 00:03:42.289 align:center line:-1
不连续的缓存类型的呢？

00:03:44.424 --> 00:03:49.329 align:center line:-1
我们介绍了两个新的协议

00:03:49.596 --> 00:03:51.865 align:center line:-1
将结构数据的界面从独立变为连续

00:03:52.132 --> 00:03:55.068 align:center line:-1
将它推广到不同的缓存类型

00:03:55.469 --> 00:03:58.005 align:center line:-1
我们来看DataProtocol

00:03:58.705 --> 00:04:02.943 align:center line:-2
这是一个字节的集合
MutableDataProtocol

00:04:03.277 --> 00:04:05.946 align:center line:-1
提供了额外的多变性保证

00:04:08.882 --> 00:04:13.020 align:center line:-2
Buffer类型是由Swift
标准库Foundation提供的

00:04:13.086 --> 00:04:16.790 align:center line:-1
调度框架采用了这些协议

00:04:17.524 --> 00:04:19.692 align:center line:-1
你可能已经用过其中的一些类型

00:04:19.760 --> 00:04:24.298 align:center line:-2
包括Data、UInt8数组和
DispatchData

00:04:25.465 --> 00:04:28.936 align:center line:-2
我们建议你也在你的类型或方法
也采用它们

00:04:29.002 --> 00:04:30.637 align:center line:-1
作为一个通用的约束

00:04:33.974 --> 00:04:35.709 align:center line:-1
现在我们来看一下约束

00:04:36.743 --> 00:04:40.380 align:center line:-2
通常 你想要将你的数据
尽可能地变小

00:04:41.081 --> 00:04:42.482 align:center line:-1
你的app可能在有限的

00:04:42.549 --> 00:04:45.652 align:center line:-1
磁盘空间的设备上运行

00:04:46.053 --> 00:04:49.590 align:center line:-2
或者你需要在网上
上传或下载资源

00:04:51.325 --> 00:04:53.093 align:center line:-1
这是一个非常常见的任务

00:04:53.460 --> 00:04:56.730 align:center line:-2
所以我们在Swift上的数据
引入了这个压缩API

00:04:57.397 --> 00:04:58.899 align:center line:-1
它现在很简单

00:04:59.600 --> 00:05:00.434 align:center line:-1
谢谢

00:05:03.136 --> 00:05:05.572 align:center line:-1
它只是一行代码

00:05:07.541 --> 00:05:10.844 align:center line:-1
这个API也支持4种压缩算法

00:05:11.411 --> 00:05:14.648 align:center line:-1
基于速度 内存和压缩率

00:05:14.715 --> 00:05:16.850 align:center line:-1
来为你提供不同的平衡区

00:05:17.451 --> 00:05:20.587 align:center line:-2
我相信你能从中找到
一个最适合你的

00:05:22.489 --> 00:05:23.323 align:center line:-1
（单元）

00:05:23.390 --> 00:05:25.025 align:center line:-1
现在 我们来讲单元

00:05:25.759 --> 00:05:30.531 align:center line:-2
Foundation已经支持了
21种类型来表示通常的物理单元

00:05:30.898 --> 00:05:33.934 align:center line:-1
比如长度 速度和时长

00:05:35.102 --> 00:05:39.840 align:center line:-1
我们扩展了单元时长类型

00:05:39.907 --> 00:05:41.542 align:center line:-1
将亚秒单元提升至了皮秒

00:05:41.942 --> 00:05:44.278 align:center line:-1
这是万亿分之一秒

00:05:45.445 --> 00:05:49.650 align:center line:-2
现在 单元频率类型使用赫兹
来作为基本单元

00:05:50.150 --> 00:05:52.786 align:center line:-2
今年 我们引入了
framesPerSecond

00:05:53.687 --> 00:05:55.956 align:center line:-1
它和赫兹的功能相同

00:05:56.390 --> 00:06:01.628 align:center line:-1
但它非常适合度量设备的FPS

00:06:04.364 --> 00:06:07.100 align:center line:-2
UnitInformationStorage
是一个新的类型

00:06:07.968 --> 00:06:11.605 align:center line:-1
它能被用来表示数码信息的数量

00:06:12.639 --> 00:06:15.909 align:center line:-1
基本单元是位 字节和四位元

00:06:16.643 --> 00:06:22.850 align:center line:-2
通常使用的前缀为
SI-和binary-的单元

00:06:22.916 --> 00:06:26.520 align:center line:-2
从kilo和kibi
到同样支持的yotta和yobi

00:06:27.721 --> 00:06:31.058 align:center line:-1
使用MeasurementFormatter一起

00:06:31.124 --> 00:06:33.293 align:center line:-1
来设计格式 比如数据大小

00:06:33.760 --> 00:06:38.165 align:center line:-2
或使用ByteCountFormatter
一起来做更精准的控制

00:06:40.400 --> 00:06:42.236 align:center line:-1
我们为你提供了更多的格式器

00:06:42.302 --> 00:06:43.237 align:center line:-1
（展示一个日期或时间）

00:06:43.303 --> 00:06:46.473 align:center line:-1
你可能每天都看到过这些字符串

00:06:47.074 --> 00:06:50.777 align:center line:-2
比如 一则你发送的消息状态
一小时前已读

00:06:51.278 --> 00:06:53.947 align:center line:-1
或是明天的一项付款

00:06:54.481 --> 00:06:58.886 align:center line:-2
它是当前展示的
一个相关的日期或时间

00:07:00.954 --> 00:07:04.258 align:center line:-2
对于所有语言环境来说
修正它并不重要

00:07:04.992 --> 00:07:08.529 align:center line:-2
我们引入了RelativeDateTimeFormatter
来协助你

00:07:14.635 --> 00:07:15.469 align:center line:-1
谢谢

00:07:15.836 --> 00:07:20.174 align:center line:-2
和其他格式器类似
返回的字符串是对语言环境友好的

00:07:20.440 --> 00:07:22.910 align:center line:-1
你可以选择的类型有很多

00:07:23.243 --> 00:07:24.378 align:center line:-1
（相对的时间日期格式器）

00:07:24.912 --> 00:07:27.581 align:center line:-1
你想要的另一个样式可能是一个列表

00:07:28.415 --> 00:07:32.519 align:center line:-2
我们也引入了ListFormatter
来为你提供便利

00:07:32.586 --> 00:07:37.324 align:center line:-1
（列表格式器）

00:07:37.391 --> 00:07:41.328 align:center line:-2
它将使用正确的分隔符将
一个列表转变为一个字符串

00:07:41.395 --> 00:07:43.630 align:center line:-1
连接了所有的语言环境

00:07:44.831 --> 00:07:46.266 align:center line:-1
这是另一个例子

00:07:46.934 --> 00:07:48.836 align:center line:-1
一个事件会在

00:07:48.902 --> 00:07:51.071 align:center line:-1
三个不同的日期发生

00:07:51.638 --> 00:07:54.975 align:center line:-1
所以你会想要展现一个像上面的或是

00:07:55.742 --> 00:07:57.077 align:center line:-1
下面的字符串

00:07:57.144 --> 00:08:00.514 align:center line:-1
在你的事件页面罗列出月份

00:08:02.249 --> 00:08:04.218 align:center line:-2
以及 当然 你会想要使用
正确的格式

00:08:04.284 --> 00:08:08.088 align:center line:-1
和不同语言环境的本地化名字来展示

00:08:08.689 --> 00:08:11.992 align:center line:-2
这很重要 因为 比如
在欧洲

00:08:12.559 --> 00:08:15.395 align:center line:-2
通常在书面形式上
日在月的前面

00:08:16.663 --> 00:08:19.766 align:center line:-2
也可用ListFormatter
非常简单地实现

00:08:22.102 --> 00:08:25.038 align:center line:-2
它有一个属性叫做
itemFormatter

00:08:25.405 --> 00:08:28.342 align:center line:-1
规定列表上的每一项的格式

00:08:28.909 --> 00:08:31.945 align:center line:-2
在这种情况下 我想要
格式化列表的日期

00:08:32.779 --> 00:08:35.582 align:center line:-2
我们知道Foundation的
DateFormatter

00:08:35.649 --> 00:08:37.083 align:center line:-1
支持日期格式化

00:08:37.751 --> 00:08:40.754 align:center line:-2
所以 我们使用它作为我们日期的
itemFormatter

00:08:41.922 --> 00:08:43.390 align:center line:-1
这就是我们想要的

00:08:43.823 --> 00:08:44.892 align:center line:-1
完成了

00:08:45.792 --> 00:08:49.763 align:center line:-1
这就是示例底部的本地化字符串

00:08:53.133 --> 00:08:57.371 align:center line:-2
你很容易通过设置DateFormatter
的属性来改变日期形式

00:08:58.238 --> 00:09:02.676 align:center line:-2
ListFormatter适用于
所有的格式器 所以请好好利用它

00:09:02.743 --> 00:09:06.914 align:center line:-2
为你的app提供更好的
本地化字符串

00:09:10.150 --> 00:09:11.718 align:center line:-1
这就是格式器

00:09:12.152 --> 00:09:14.254 align:center line:-1
下面 我们来介绍操作队列

00:09:14.321 --> 00:09:15.389 align:center line:-1
（操作队列）

00:09:15.455 --> 00:09:16.723 align:center line:-1
想象一下 在你的app中

00:09:16.990 --> 00:09:20.127 align:center line:-1
有一些后台任务在同时运行

00:09:21.762 --> 00:09:22.763 align:center line:-1
现在

00:09:23.096 --> 00:09:25.899 align:center line:-1
用户想保存这个运行中app的状态

00:09:26.466 --> 00:09:27.935 align:center line:-1
那么 你要如何实现呢

00:09:28.936 --> 00:09:32.105 align:center line:-1
那么 你想要确认所有运行中的

00:09:32.172 --> 00:09:33.540 align:center line:-1
任务在你能保存之前会结束

00:09:34.341 --> 00:09:37.477 align:center line:-1
所以它可能需要这样实现

00:09:39.446 --> 00:09:42.416 align:center line:-1
你检查当前队列中

00:09:42.482 --> 00:09:43.750 align:center line:-1
运行操作的数量

00:09:44.318 --> 00:09:45.986 align:center line:-1
如果没有

00:09:46.053 --> 00:09:49.223 align:center line:-2
它就说明我们之前规划的任务
一定结束了

00:09:49.590 --> 00:09:51.325 align:center line:-1
所以我们可以保存了 是吗？

00:09:52.192 --> 00:09:53.727 align:center line:-1
不是的

00:09:54.161 --> 00:09:55.495 align:center line:-1
请不要这么做

00:09:58.465 --> 00:10:00.501 align:center line:-1
在它们所有的线程中

00:10:00.567 --> 00:10:03.604 align:center line:-1
其他的任务有可能在同时运行

00:10:03.904 --> 00:10:08.342 align:center line:-2
比如 它在检查之后
保存之前发生

00:10:09.710 --> 00:10:14.648 align:center line:-2
你这里需要的是一个屏障
来保证安全操作

00:10:14.715 --> 00:10:19.586 align:center line:-2
在app状态被保存时
保证没有其他任务在运行

00:10:20.621 --> 00:10:21.688 align:center line:-1
像这样

00:10:24.191 --> 00:10:28.962 align:center line:-2
所以 我们很兴奋地告诉你
操作队列现在支持屏障

00:10:29.563 --> 00:10:31.398 align:center line:-1
你应添加BarrierBlock

00:10:31.465 --> 00:10:34.401 align:center line:-1
在屏障内进行保存操作

00:10:35.102 --> 00:10:37.638 align:center line:-1
这会保证在那段特定的时间

00:10:37.704 --> 00:10:41.542 align:center line:-1
保存操作是唯一在运行的任务

00:10:42.242 --> 00:10:46.313 align:center line:-2
以及 它只会在所有任务运行结束后
执行

00:10:46.747 --> 00:10:50.918 align:center line:-2
在它结束前不会有其他
新任务运行

00:10:57.958 --> 00:11:01.562 align:center line:-2
操作队列另一个更新的点是
进度报告

00:11:02.396 --> 00:11:04.965 align:center line:-1
有时你可能想要追踪你当前

00:11:05.032 --> 00:11:06.533 align:center line:-1
所有任务的所有的进程

00:11:06.834 --> 00:11:09.670 align:center line:-1
在你的UI中展示一个进度栏

00:11:10.370 --> 00:11:13.774 align:center line:-1
你现在可以通过设置操作队列中的

00:11:13.841 --> 00:11:17.177 align:center line:-2
进程属性
totalUnitCount实现

00:11:17.244 --> 00:11:18.312 align:center line:-1
（操作队列）

00:11:18.378 --> 00:11:21.381 align:center line:-2
你在操作队列上加入的
每一个操作

00:11:21.448 --> 00:11:25.485 align:center line:-1
在操作结束后 计数器为所有的

00:11:25.552 --> 00:11:27.221 align:center line:-1
进程创建一个完成单元

00:11:32.626 --> 00:11:34.127 align:center line:-1
接下来是文件系统

00:11:34.194 --> 00:11:35.128 align:center line:-2
（为iOS上的
USB和SMB做好准备）

00:11:35.195 --> 00:11:40.300 align:center line:-2
iOS现在支持USB和SMB卷
它是一个网络文件系统

00:11:41.101 --> 00:11:43.904 align:center line:-1
这代表着你应该为处理可能在

00:11:43.971 --> 00:11:46.006 align:center line:-1
其他卷上的文件做好准备

00:11:46.940 --> 00:11:50.844 align:center line:-2
在如下场景 请确保使用FileManager
的itemReplacementDirectory

00:11:51.111 --> 00:11:54.414 align:center line:-1
当你为写入新的文件内容选择地方时

00:11:54.481 --> 00:11:57.484 align:center line:-1
当你操作原子级的安全保存时

00:11:59.620 --> 00:12:03.390 align:center line:-1
接下来 如果用户弹出USB设备

00:12:03.457 --> 00:12:07.995 align:center line:-1
或失去与SMB服务器网络连接

00:12:08.061 --> 00:12:09.496 align:center line:-1
你要在卷完全消失之前做好准备

00:12:10.631 --> 00:12:14.268 align:center line:-2
如果你在读取数据对象时
选择内存映射文件

00:12:14.835 --> 00:12:18.839 align:center line:-2
确保使用mappedIfSafe
为你的读取选项

00:12:19.673 --> 00:12:23.577 align:center line:-1
这会允许系统映射文件至虚拟内存中

00:12:24.144 --> 00:12:28.215 align:center line:-1
但仅当文件处于不可移动的卷时

00:12:28.815 --> 00:12:33.187 align:center line:-2
从USB或SMB盘上读取文件
可能比

00:12:33.253 --> 00:12:35.856 align:center line:-1
内置存储器慢很多

00:12:36.890 --> 00:12:38.692 align:center line:-1
所以 如果你还没有实现它

00:12:39.059 --> 00:12:42.629 align:center line:-1
请将文件系统放置到非主线程里

00:12:42.696 --> 00:12:45.232 align:center line:-1
来保持你的app持续相应

00:12:46.800 --> 00:12:50.571 align:center line:-2
在使用它们之前 你可能需要测试
文件系统的性能

00:12:51.371 --> 00:12:52.372 align:center line:-1
比如

00:12:52.773 --> 00:12:56.243 align:center line:-1
你熟悉的APFS功能 比如克隆

00:12:57.044 --> 00:13:00.547 align:center line:-1
在当你通过USB或SMB

00:13:00.614 --> 00:13:02.549 align:center line:-1
访问其他卷时可能不可用

00:13:03.784 --> 00:13:06.720 align:center line:-1
你可以通过

00:13:06.787 --> 00:13:09.223 align:center line:-1
大量的URL资源关键字事件

00:13:09.957 --> 00:13:14.695 align:center line:-2
或在处理收取错误时做好准备
来测试这些性能

00:13:15.696 --> 00:13:18.131 align:center line:-2
你可以在文件管理
和QuickLook的新功能

00:13:18.198 --> 00:13:22.102 align:center line:-1
的演讲上了解关于它的更多信息

00:13:25.706 --> 00:13:27.407 align:center line:-1
接下来 Swift更新

00:13:27.474 --> 00:13:28.642 align:center line:-1
（Swift更新了扫描仪）

00:13:28.709 --> 00:13:33.280 align:center line:-2
一些Swift的API最开始基于
Objective-C的理念设计

00:13:34.047 --> 00:13:37.651 align:center line:-1
我们这些年在不断提升它们

00:13:38.452 --> 00:13:39.720 align:center line:-1
首先是扫描仪

00:13:41.588 --> 00:13:43.690 align:center line:-1
这是Swift 4上的API

00:13:44.458 --> 00:13:46.426 align:center line:-1
它之前被用来使用NSString

00:13:47.528 --> 00:13:49.496 align:center line:-1
和通过引用返回对象

00:13:51.265 --> 00:13:56.904 align:center line:-2
在Swift 5.1
我们将这个界面简化为了一行代码

00:13:58.639 --> 00:14:03.443 align:center line:-2
以及这个新的API使用了
Swift的字符串类型

00:14:03.977 --> 00:14:06.880 align:center line:-1
字符串是图新的集合

00:14:06.947 --> 00:14:08.582 align:center line:-1
而不是代码点

00:14:09.349 --> 00:14:12.519 align:center line:-1
这意味着使用新的扫描仪的API

00:14:12.586 --> 00:14:16.623 align:center line:-2
你现在能处理复杂的序列
比如颜文字

00:14:18.659 --> 00:14:19.893 align:center line:-1
（SWIFT更新了文件句柄）

00:14:19.960 --> 00:14:22.095 align:center line:-1
另一个提升的地方是文件句柄

00:14:22.996 --> 00:14:25.799 align:center line:-1
它以前被用来处理当错误发生时

00:14:25.866 --> 00:14:28.268 align:center line:-1
在底层的文件描述符抛出异常

00:14:29.269 --> 00:14:32.406 align:center line:-1
今年 我们引入了基于错误的API

00:14:32.840 --> 00:14:36.577 align:center line:-1
现在你能立刻调用站点处理错误

00:14:37.878 --> 00:14:41.748 align:center line:-2
这个为写入数据创建的API
现在也支持数据协议了

00:14:42.316 --> 00:14:45.719 align:center line:-1
它也为非连续数据做了优化

00:14:48.455 --> 00:14:51.091 align:center line:-1
这些就是新API的亮点

00:14:51.725 --> 00:14:56.263 align:center line:-2
我们鼓励你在新的Xcode中
尝试使用这些新的功能

00:14:56.330 --> 00:14:57.164 align:center line:-1
（试一试）

00:14:57.231 --> 00:15:00.300 align:center line:-1
当使用二进制数据创建新方法时

00:15:00.934 --> 00:15:04.004 align:center line:-1
考虑为它们绑定数据协议类型

00:15:04.404 --> 00:15:09.243 align:center line:-2
而不是请求特殊的集合
比如UInt8数组

00:15:10.477 --> 00:15:15.382 align:center line:-2
如果你在UI上以字符串的形式
展示日期或列表

00:15:16.550 --> 00:15:20.754 align:center line:-2
使用RelativeDateTimeFormatter
或一个ListFormatter

00:15:20.821 --> 00:15:23.524 align:center line:-2
来让字符串在每个语言环境都能
正常运行

00:15:25.225 --> 00:15:28.328 align:center line:-1
我们强烈向你推荐操作队列的屏障

00:15:28.395 --> 00:15:30.197 align:center line:-1
来避免竞太条件

00:15:31.131 --> 00:15:34.601 align:center line:-1
如果你使用了一些进程报告机制

00:15:35.135 --> 00:15:38.138 align:center line:-1
转换成操作队列提供的那个吧

00:15:38.972 --> 00:15:39.806 align:center line:-1
谢谢

00:15:42.109 --> 00:15:45.812 align:center line:-1
（更多信息）

