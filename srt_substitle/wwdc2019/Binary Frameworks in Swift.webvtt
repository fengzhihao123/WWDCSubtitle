WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:01.176 --> 00:00:06.516 A:middle
[音乐]

00:00:07.516 --> 00:00:11.906 A:middle
[掌声和欢呼]

00:00:12.406 --> 00:00:13.346 A:middle
&gt;&gt; 大家下午好

00:00:14.286 --> 00:00:15.266 A:middle
我叫 Harlan

00:00:15.266 --> 00:00:16.966 A:middle
我非常高兴能和

00:00:16.966 --> 00:00:19.296 A:middle
你们讨论 Xcode 11 是如何允许

00:00:19.296 --> 00:00:20.886 A:middle
你们在 Swift 中创建和分发

00:00:21.156 --> 00:00:22.896 A:middle
二进制框架的

00:00:24.126 --> 00:00:25.376 A:middle
在讨论二进制框架之前

00:00:25.376 --> 00:00:26.856 A:middle
我想先花点时间

00:00:26.856 --> 00:00:29.106 A:middle
谈谈 Swift 包

00:00:30.196 --> 00:00:31.386 A:middle
借助 Xcode 11 中

00:00:31.386 --> 00:00:33.926 A:middle
对 Swift 包的新支持

00:00:33.926 --> 00:00:35.616 A:middle
你们可以轻松地在项目中

00:00:35.616 --> 00:00:38.136 A:middle
创建和使用它们并将其分发给其他人

00:00:38.586 --> 00:00:41.196 A:middle
Swift 包是

00:00:41.196 --> 00:00:42.416 A:middle
分发代码的好方法

00:00:42.756 --> 00:00:43.956 A:middle
因为 Xcode 知道如何

00:00:43.956 --> 00:00:45.746 A:middle
管理它们的依赖关系

00:00:45.746 --> 00:00:47.696 A:middle
它会自动找出

00:00:47.696 --> 00:00:49.626 A:middle
要使用的包版本

00:00:50.236 --> 00:00:52.346 A:middle
由于它们是以

00:00:52.346 --> 00:00:54.716 A:middle
源代码形式进行分发的

00:00:54.716 --> 00:00:56.396 A:middle
因此无需保持

00:00:56.396 --> 00:00:57.946 A:middle
与客户端的二进制兼容性

00:00:58.676 --> 00:01:00.536 A:middle
如果你有能力

00:01:00.716 --> 00:01:02.146 A:middle
提供项目的源代码

00:01:02.746 --> 00:01:04.775 A:middle
那么 Swift 包

00:01:04.936 --> 00:01:06.266 A:middle
真的很棒

00:01:07.496 --> 00:01:09.166 A:middle
但并不是每个人都有能力

00:01:09.166 --> 00:01:10.226 A:middle
发布其库的源代码

00:01:10.226 --> 00:01:12.366 A:middle
如果你没有这个能力

00:01:13.376 --> 00:01:14.646 A:middle
那么 Xcode 11 支持使用

00:01:14.646 --> 00:01:16.386 A:middle
新的 XC 框架格式

00:01:16.456 --> 00:01:18.616 A:middle
分发二进制库

00:01:19.516 --> 00:01:24.186 A:middle
[掌声]

00:01:24.686 --> 00:01:25.766 A:middle
因此在这次演讲中

00:01:25.766 --> 00:01:27.766 A:middle
我将向你介绍 XC 框架

00:01:28.106 --> 00:01:29.486 A:middle
这是一种受支持的

00:01:29.486 --> 00:01:31.116 A:middle
分发二进制框架的新方法

00:01:31.856 --> 00:01:33.156 A:middle
我还将讨论一些

00:01:33.156 --> 00:01:34.566 A:middle
客户在选择

00:01:34.566 --> 00:01:36.096 A:middle
使用第三方代码时

00:01:36.096 --> 00:01:38.956 A:middle
应该考虑的事情

00:01:39.166 --> 00:01:40.756 A:middle
接下来

00:01:40.816 --> 00:01:43.026 A:middle
我将讨论 XC 框中的内容

00:01:43.026 --> 00:01:44.346 A:middle
以及如何为项目

00:01:44.346 --> 00:01:45.116 A:middle
创建一个 XC 框架

00:01:46.476 --> 00:01:48.466 A:middle
最后我的同事

00:01:48.466 --> 00:01:50.126 A:middle
Jordan 会来和你们讨论

00:01:50.126 --> 00:01:51.106 A:middle
一些框架作者

00:01:51.106 --> 00:01:52.176 A:middle
应该考虑的事情

00:01:52.176 --> 00:01:53.996 A:middle
以便让他们的

00:01:53.996 --> 00:01:55.926 A:middle
框架尽可能的顺畅

00:01:58.476 --> 00:02:02.056 A:middle
XC 框架是一种新的方法

00:02:02.056 --> 00:02:04.186 A:middle
这个方法可以将

00:02:04.186 --> 00:02:06.876 A:middle
框架的多个变体捆绑在一起

00:02:06.876 --> 00:02:08.786 A:middle
使其能够在以后的

00:02:08.786 --> 00:02:09.526 A:middle
Xcode 版本中工作

00:02:10.166 --> 00:02:13.836 A:middle
单个 XC 框架可以

00:02:13.836 --> 00:02:16.776 A:middle
包含模拟器和设备的变体

00:02:17.516 --> 00:02:21.606 A:middle
[掌声]

00:02:22.106 --> 00:02:24.856 A:middle
还没有结束 因为单个 XC 框架 

00:02:24.856 --> 00:02:26.866 A:middle
也可以包含

00:02:26.866 --> 00:02:28.926 A:middle
Xcode 支持的任何平台的变体

00:02:29.516 --> 00:02:33.546 A:middle
[掌声]

00:02:34.046 --> 00:02:35.376 A:middle
对于使用 AppKit 的 Mac App

00:02:35.376 --> 00:02:37.676 A:middle
你也可以有一个变体

00:02:37.676 --> 00:02:38.866 A:middle
对于使用 UIKit 的 Mac App

00:02:38.866 --> 00:02:39.406 A:middle
你也可以有一个变体

00:02:39.806 --> 00:02:41.136 A:middle
因此无论你的客户端

00:02:41.136 --> 00:02:42.986 A:middle
想要使用哪种 API

00:02:42.986 --> 00:02:44.256 A:middle
他们都能够有效地

00:02:44.256 --> 00:02:44.876 A:middle
使用你的框架

00:02:45.406 --> 00:02:48.396 A:middle
你不仅可以捆绑框架

00:02:48.396 --> 00:02:50.556 A:middle
还可以使用

00:02:50.556 --> 00:02:53.656 A:middle
XC 框架捆绑静态库及其

00:02:53.656 --> 00:02:54.746 A:middle
相应的头文件

00:02:54.956 --> 00:02:56.096 A:middle
Xcode 将自动设置

00:02:56.096 --> 00:02:57.806 A:middle
客户端的搜索板

00:02:59.046 --> 00:02:59.936 A:middle
而且当然 - 

00:03:04.076 --> 00:03:05.636 A:middle
XC 框架支持

00:03:05.636 --> 00:03:07.356 A:middle
基于 Swift 和 C 代码的

00:03:07.426 --> 00:03:10.306 A:middle
二进制分发

00:03:10.516 --> 00:03:11.706 A:middle
现在我想向

00:03:11.706 --> 00:03:13.126 A:middle
你们展示使用

00:03:13.126 --> 00:03:14.926 A:middle
XC 框架是多么容易

00:03:17.936 --> 00:03:19.576 A:middle
这里我有一个

00:03:19.606 --> 00:03:20.646 A:middle
非常简单的 iOS App

00:03:20.646 --> 00:03:22.906 A:middle
我将继续并单击

00:03:22.906 --> 00:03:24.916 A:middle
Run 以在 iPad

00:03:24.916 --> 00:03:25.436 A:middle
模拟器上运行它

00:03:25.616 --> 00:03:27.096 A:middle
你可以看到

00:03:27.096 --> 00:03:28.266 A:middle
它有一个很大的蓝色启动按钮

00:03:28.296 --> 00:03:30.336 A:middle
当你点击它时它什么都不做

00:03:30.336 --> 00:03:32.516 A:middle
这是因为它

00:03:32.516 --> 00:03:33.956 A:middle
连接到这个发射方法

00:03:33.956 --> 00:03:36.246 A:middle
它的主体是空的

00:03:37.466 --> 00:03:39.046 A:middle
我有一个很棒的 XC 框架

00:03:39.166 --> 00:03:40.766 A:middle
我想使用它

00:03:40.766 --> 00:03:42.666 A:middle
它的名字是 FlightKit

00:03:44.646 --> 00:03:46.106 A:middle
FlightKit 给了我

00:03:46.306 --> 00:03:47.416 A:middle
一些我想要在我

00:03:47.416 --> 00:03:48.156 A:middle
App 中呈现的 UI

00:03:49.136 --> 00:03:50.706 A:middle
因此为了能够实际使用

00:03:50.736 --> 00:03:52.976 A:middle
FlightKit XC 框架

00:03:52.976 --> 00:03:54.496 A:middle
我只需单击

00:03:54.496 --> 00:03:55.566 A:middle
项目导航栏中的项目

00:03:55.566 --> 00:03:58.396 A:middle
选择我的 Target

00:03:58.396 --> 00:04:00.006 A:middle
并确保选择了 General 选项卡

00:04:01.286 --> 00:04:02.576 A:middle
然后我将向下

00:04:02.576 --> 00:04:04.996 A:middle
滚动到
Frameworks, Libraries and Embedded Content

00:04:07.176 --> 00:04:10.916 A:middle
然后我将只是拖入我的 XC 框架

00:04:10.916 --> 00:04:12.276 A:middle
并且已经自动连接

00:04:12.276 --> 00:04:13.766 A:middle
为我的 Target 的依赖项

00:04:15.076 --> 00:04:16.226 A:middle
让我们回到代码

00:04:16.226 --> 00:04:17.486 A:middle
并开始使用它

00:04:18.516 --> 00:04:20.576 A:middle
就像你已经习惯

00:04:20.576 --> 00:04:21.696 A:middle
使用的任何框架一样

00:04:21.875 --> 00:04:23.766 A:middle
你要做的第一件事就是导入它

00:04:25.196 --> 00:04:26.356 A:middle
现在我想继续

00:04:26.356 --> 00:04:27.556 A:middle
使用 FlightKit

00:04:27.556 --> 00:04:28.816 A:middle
的一些 API

00:04:29.366 --> 00:04:30.456 A:middle
所以要么我可以

00:04:30.456 --> 00:04:33.446 A:middle
去查看文档

00:04:33.446 --> 00:04:34.376 A:middle
要么我可以按住 Command 单击

00:04:34.376 --> 00:04:35.546 A:middle
名称 FlightKit

00:04:35.546 --> 00:04:36.166 A:middle
然后单击 Jump to Definition

00:04:37.146 --> 00:04:38.106 A:middle
这会把我带到为

00:04:38.106 --> 00:04:41.156 A:middle
FlightKit 生成的接口

00:04:42.136 --> 00:04:44.146 A:middle
这显示了所有公共 API

00:04:44.146 --> 00:04:47.626 A:middle
每个公共类型 公共方法

00:04:47.626 --> 00:04:49.116 A:middle
我导入 FlightKit 时可以使用的所有内容

00:04:49.856 --> 00:04:52.006 A:middle
我可以看到

00:04:52.126 --> 00:04:53.606 A:middle
这有一个 LaunchViewController

00:04:53.606 --> 00:04:55.116 A:middle
它是 UIViewController 的子类

00:04:55.976 --> 00:04:57.226 A:middle
这似乎是我可能

00:04:57.226 --> 00:04:58.786 A:middle
希望展示的一小部分 UI

00:05:02.386 --> 00:05:03.406 A:middle
所以现在我需要知道

00:05:03.406 --> 00:05:05.026 A:middle
如何创建这些

00:05:05.026 --> 00:05:06.176 A:middle
我可以看到在界面

00:05:06.176 --> 00:05:07.606 A:middle
有一个初始化程序

00:05:07.606 --> 00:05:08.256 A:middle
需要构造一个 Spaceship

00:05:08.846 --> 00:05:10.216 A:middle
Spaceship 也是 

00:05:10.216 --> 00:05:10.766 A:middle
FlightKit 的一部分

00:05:12.196 --> 00:05:13.666 A:middle
如果我跳转到它的定义

00:05:13.776 --> 00:05:15.106 A:middle
它将进一步将我

00:05:15.106 --> 00:05:16.816 A:middle
代入到生成的界面中

00:05:16.816 --> 00:05:17.946 A:middle
并向我展示所有我可以

00:05:17.946 --> 00:05:19.456 A:middle
在 Spaceship 中使用的内容

00:05:20.006 --> 00:05:23.746 A:middle
我可以看到

00:05:23.746 --> 00:05:26.926 A:middle
有一个称为 name 的公共存储属性

00:05:26.926 --> 00:05:28.396 A:middle
并且还有一个输入 name 的公共 init 程序

00:05:29.836 --> 00:05:31.246 A:middle
好吧这样我就可以创建

00:05:31.246 --> 00:05:32.766 A:middle
一个太空船

00:05:32.766 --> 00:05:34.166 A:middle
并且我可以创建一个 LaunchViewController

00:05:34.166 --> 00:05:34.796 A:middle
然后我可以呈现它

00:05:36.186 --> 00:05:37.396 A:middle
那么让我们回到代码中

00:05:37.396 --> 00:05:38.346 A:middle
并准确地做到这一点

00:05:39.376 --> 00:05:40.576 A:middle
首先我要创建一个船

00:05:41.576 --> 00:05:42.566 A:middle
我可以看到

00:05:42.566 --> 00:05:43.886 A:middle
自动补全已经向我

00:05:43.886 --> 00:05:45.446 A:middle
暗示了所有在

00:05:45.446 --> 00:05:47.326 A:middle
FlightKit 中的成分

00:05:47.326 --> 00:05:48.306 A:middle
就像你已经习惯

00:05:48.306 --> 00:05:49.336 A:middle
使用的框架一样

00:05:50.276 --> 00:05:51.186 A:middle
我可以接受自动补全

00:05:51.186 --> 00:05:53.086 A:middle
然后我将为我的船

00:05:53.086 --> 00:05:53.866 A:middle
选择一个名字

00:05:54.506 --> 00:05:55.456 A:middle
好吧我已经有了

00:05:55.456 --> 00:05:57.066 A:middle
这一数组的船名

00:05:57.066 --> 00:05:58.186 A:middle
其中任何一个

00:05:58.186 --> 00:05:58.696 A:middle
都将是这艘船的好名字

00:05:59.646 --> 00:06:02.896 A:middle
我将从船名数组中

00:06:02.896 --> 00:06:03.716 A:middle
随机抽取一个元素

00:06:04.306 --> 00:06:07.206 A:middle
现在我将创建

00:06:07.206 --> 00:06:10.506 A:middle
一个 LaunchViewController

00:06:10.676 --> 00:06:12.416 A:middle
并将它传递给我刚刚创建的船

00:06:12.956 --> 00:06:15.776 A:middle
最后并显示

00:06:15.776 --> 00:06:18.136 A:middle
控制器自己作为发送者

00:06:18.706 --> 00:06:21.866 A:middle
在创建了一艘船和一些 UI 之后

00:06:21.866 --> 00:06:23.666 A:middle
我现在将进行展示

00:06:24.706 --> 00:06:26.866 A:middle
我将构建并在模拟器中运行我的程序

00:06:26.866 --> 00:06:28.776 A:middle
当我点击启 Launch 时

00:06:28.776 --> 00:06:30.416 A:middle
它会随机选择一个名字

00:06:30.416 --> 00:06:31.466 A:middle
然后启动 UI

00:06:31.466 --> 00:06:34.586 A:middle
如果我再次点击它

00:06:34.586 --> 00:06:37.896 A:middle
它会选择一个名字和另一个名字 你懂了吧

00:06:39.186 --> 00:06:41.636 A:middle
这就是如何在一个平台上

00:06:41.636 --> 00:06:43.136 A:middle
使用 XC 框架

00:06:43.136 --> 00:06:44.436 A:middle
但 XC 框架的一大优点是

00:06:44.546 --> 00:06:47.526 A:middle
可以将多个变体

00:06:47.526 --> 00:06:48.916 A:middle
放在同一个包中

00:06:49.606 --> 00:06:50.996 A:middle
因此只需将一个

00:06:50.996 --> 00:06:52.956 A:middle
XC 框架拖入其中

00:06:52.956 --> 00:06:54.036 A:middle
我不仅能够为

00:06:54.036 --> 00:06:57.196 A:middle
模拟器构建和运行

00:06:57.196 --> 00:07:00.356 A:middle
而且如果我选择 Generic iOS Device

00:07:00.356 --> 00:07:02.326 A:middle
那么我可以转到

00:07:02.326 --> 00:07:03.686 A:middle
Product Archive

00:07:03.686 --> 00:07:04.006 A:middle
并为 App Store 构建存档

00:07:04.676 --> 00:07:10.036 A:middle
从代码中使用 XC 框架

00:07:10.036 --> 00:07:11.456 A:middle
是多么容易啊

00:07:12.516 --> 00:07:18.546 A:middle
[掌声]

00:07:19.046 --> 00:07:20.206 A:middle
因此当你选择

00:07:20.206 --> 00:07:23.346 A:middle
使用框架时

00:07:23.386 --> 00:07:24.766 A:middle
了解你向第三方代码

00:07:24.766 --> 00:07:27.046 A:middle
提供哪些内容非常重要

00:07:28.426 --> 00:07:30.196 A:middle
重要的是

00:07:30.196 --> 00:07:33.156 A:middle
你希望确保信任框架的来源

00:07:34.156 --> 00:07:35.226 A:middle
你相信他们不会

00:07:35.226 --> 00:07:36.986 A:middle
给你的 App 带来漏洞或不稳定

00:07:36.986 --> 00:07:38.946 A:middle
你相信他们

00:07:38.946 --> 00:07:40.806 A:middle
会尊重你用户的隐私

00:07:41.346 --> 00:07:44.366 A:middle
例如如果你

00:07:44.366 --> 00:07:47.546 A:middle
已经为你的 App 授予了权限

00:07:47.546 --> 00:07:49.626 A:middle
并且你使用了一个框架

00:07:49.696 --> 00:07:51.276 A:middle
那么该框架也将被授予这些权限

00:07:51.806 --> 00:07:53.416 A:middle
以及那些许可也是一样

00:07:53.416 --> 00:07:54.766 A:middle
如果你的用户给了许可的话

00:07:56.736 --> 00:07:58.716 A:middle
此外如果你采用的框架

00:07:58.716 --> 00:08:00.256 A:middle
需要某种权限才能使用

00:08:00.256 --> 00:08:01.246 A:middle
那么你需要负责

00:08:01.246 --> 00:08:06.186 A:middle
将该权限添加到你的 App 中

00:08:07.836 --> 00:08:09.786 A:middle
关于使用框架

00:08:09.786 --> 00:08:11.036 A:middle
需要考虑的另一件事是

00:08:11.586 --> 00:08:12.436 A:middle
有时你会使用

00:08:12.436 --> 00:08:16.466 A:middle
一个带有自己依赖项的框架

00:08:16.466 --> 00:08:20.396 A:middle
这些依赖项可能也有自己的依赖项

00:08:20.396 --> 00:08:21.966 A:middle
你不仅有义务要

00:08:21.966 --> 00:08:23.276 A:middle
将所有这些添加到项目中

00:08:23.966 --> 00:08:25.836 A:middle
还要对它们每个部分

00:08:25.836 --> 00:08:27.966 A:middle
扩展同样的信任

00:08:27.966 --> 00:08:30.896 A:middle
现在值得注意的是

00:08:30.966 --> 00:08:34.086 A:middle
这种信任也扩展到了

00:08:34.086 --> 00:08:35.186 A:middle
使用 Swift 包

00:08:36.126 --> 00:08:38.525 A:middle
包相对于二进制框架的一个优点是

00:08:38.525 --> 00:08:40.116 A:middle
你可以检查代码

00:08:40.116 --> 00:08:41.676 A:middle
并且可以在调试时深入查看

00:08:42.285 --> 00:08:43.716 A:middle
如果你想了解

00:08:43.716 --> 00:08:45.006 A:middle
更多关于在 Xcode

00:08:45.046 --> 00:08:47.066 A:middle
中使用 Swift 包的信息

00:08:47.066 --> 00:08:48.066 A:middle
我向你推荐本周早些时候的会议

00:08:48.666 --> 00:08:52.126 A:middle
但无论你使用的

00:08:52.126 --> 00:08:54.096 A:middle
是包还是二进制框架

00:08:54.516 --> 00:08:56.606 A:middle
Xcode 11 都可以让你

00:08:56.606 --> 00:09:00.686 A:middle
轻松使用你信任的第三方代码

00:09:02.206 --> 00:09:03.846 A:middle
现在我想谈谈

00:09:03.846 --> 00:09:05.706 A:middle
如何创建一个 XC 框架

00:09:06.846 --> 00:09:08.226 A:middle
你要做的第一件事

00:09:08.226 --> 00:09:10.086 A:middle
就是有一些你

00:09:10.086 --> 00:09:11.386 A:middle
想要发布的源代码

00:09:11.386 --> 00:09:14.196 A:middle
让我们来看一下

00:09:14.196 --> 00:09:16.826 A:middle
早前 FlightKit 的一些源代码

00:09:18.056 --> 00:09:21.666 A:middle
这只是 FlightKit 中对象的子集 仅仅用来举例

00:09:22.346 --> 00:09:24.886 A:middle
但是你可以

00:09:24.916 --> 00:09:26.686 A:middle
看到我们之前看过的 Spaceship 类型

00:09:28.136 --> 00:09:29.806 A:middle
你还可以看到

00:09:29.806 --> 00:09:31.606 A:middle
一个名为 Speed 的枚举

00:09:31.606 --> 00:09:32.716 A:middle
它描述了事物在太空中移动的速度

00:09:34.066 --> 00:09:35.296 A:middle
你还会看到一个名为

00:09:35.296 --> 00:09:36.926 A:middle
Location 的结构体

00:09:36.926 --> 00:09:38.676 A:middle
用于描述对象在空间中的位置

00:09:40.156 --> 00:09:42.566 A:middle
太好了 我们有这个代码

00:09:43.196 --> 00:09:44.336 A:middle
现在我们将如何确保

00:09:44.336 --> 00:09:45.736 A:middle
我们构建此库

00:09:45.736 --> 00:09:46.496 A:middle
是用于分发？

00:09:47.446 --> 00:09:49.436 A:middle
在 Xcode 11 中

00:09:49.436 --> 00:09:51.046 A:middle
有一个新的构建设置

00:09:51.046 --> 00:09:52.576 A:middle
称为 Build Libraries for Distribution

00:09:53.556 --> 00:09:54.786 A:middle
它做的确实是这件事

00:09:54.966 --> 00:09:58.116 A:middle
它开启了所有构建库所需的特性

00:09:58.116 --> 00:10:00.496 A:middle
以便以一种可分发的方式构建库

00:10:02.046 --> 00:10:04.166 A:middle
现在我们来谈谈

00:10:04.166 --> 00:10:05.386 A:middle
其中一个特性

00:10:06.906 --> 00:10:08.536 A:middle
如果你以前尝试过

00:10:08.756 --> 00:10:10.586 A:middle
向某人发送已构建的 Swift 框架

00:10:11.286 --> 00:10:13.536 A:middle
那么你可能已经看到了这种错误的变体

00:10:14.956 --> 00:10:17.126 A:middle
已编译模块是由

00:10:17.126 --> 00:10:18.446 A:middle
较新版本的编译器创建的

00:10:18.986 --> 00:10:21.976 A:middle
这个错误到底意味着什么

00:10:23.506 --> 00:10:24.626 A:middle
当 Swift 编译器

00:10:24.626 --> 00:10:26.656 A:middle
导入一个模块时

00:10:26.656 --> 00:10:27.956 A:middle
它会为这个库

00:10:27.956 --> 00:10:30.156 A:middle
查找一个名为 Compiled Module 的文件

00:10:31.676 --> 00:10:33.286 A:middle
如果找到其中一个文件

00:10:33.646 --> 00:10:35.206 A:middle
它将读取可以调用的

00:10:35.246 --> 00:10:36.946 A:middle
公共 API 的 Manifest

00:10:36.946 --> 00:10:39.996 A:middle
并让你使用它们

00:10:40.326 --> 00:10:45.746 A:middle
现在这个已编译模块格式是二进制格式

00:10:45.746 --> 00:10:47.876 A:middle
基本上包含

00:10:47.876 --> 00:10:49.236 A:middle
内部编译器数据结构

00:10:50.096 --> 00:10:52.996 A:middle
由于它们只是内部数据结构

00:10:52.996 --> 00:10:55.116 A:middle
所以随着 Swift 编译器的每个版本

00:10:55.116 --> 00:10:58.986 A:middle
它们都可能发生变化 这意味着

00:10:59.216 --> 00:11:00.756 A:middle
如果一个人试图

00:11:00.756 --> 00:11:02.566 A:middle
用一个版本的 Swift 

00:11:02.566 --> 00:11:04.436 A:middle
导入一个模块

00:11:04.496 --> 00:11:05.596 A:middle
而这个模块是由

00:11:05.596 --> 00:11:07.666 A:middle
另一个版本的 Swift 创建的

00:11:07.666 --> 00:11:08.806 A:middle
他们的编译器将无法理解这个模块

00:11:08.806 --> 00:11:10.126 A:middle
他们也无法使用这个模块

00:11:11.176 --> 00:11:13.516 A:middle
为了解决

00:11:13.516 --> 00:11:16.406 A:middle
这个版本锁定问题

00:11:16.406 --> 00:11:17.916 A:middle
Xcode 11 为 Swift 模块

00:11:17.916 --> 00:11:19.586 A:middle
引入了一种新的格式

00:11:19.586 --> 00:11:20.746 A:middle
称为 Swift 模块接口

00:11:21.886 --> 00:11:23.186 A:middle
就像已编译模块格式一样

00:11:23.186 --> 00:11:27.756 A:middle
它们列出了模块的所有公共 API

00:11:27.756 --> 00:11:29.956 A:middle
但使用的是

00:11:29.956 --> 00:11:30.966 A:middle
更像源代码的文本形式

00:11:32.086 --> 00:11:33.356 A:middle
由于它们的行为

00:11:33.356 --> 00:11:35.546 A:middle
类似于源代码

00:11:35.546 --> 00:11:37.006 A:middle
那么 Swift 编译器的未来版本

00:11:37.436 --> 00:11:39.026 A:middle
将能够导入

00:11:39.026 --> 00:11:41.066 A:middle
使用旧版本创建的模块接口

00:11:41.716 --> 00:11:46.696 A:middle
当你启用 Build Libraries for Distribution 时

00:11:47.416 --> 00:11:48.606 A:middle
你是在告诉编译器

00:11:48.606 --> 00:11:50.076 A:middle
在编译器构建框架时

00:11:50.076 --> 00:11:52.926 A:middle
去生成一个稳定的接口

00:11:53.606 --> 00:11:57.406 A:middle
那么这些接口

00:11:57.406 --> 00:11:58.836 A:middle
实际上是什么样的呢？

00:11:59.586 --> 00:12:01.176 A:middle
让我们再次看看

00:12:01.176 --> 00:12:02.566 A:middle
FlightKit 的源代码

00:12:03.716 --> 00:12:05.326 A:middle
这就是来自 FlightKit 的源代码

00:12:05.326 --> 00:12:08.116 A:middle
在右侧你将

00:12:08.116 --> 00:12:09.606 A:middle
看到 FlightKit 的模块接口

00:12:10.286 --> 00:12:11.546 A:middle
现在这有点多

00:12:11.546 --> 00:12:12.816 A:middle
而且它从屏幕上消失了

00:12:12.816 --> 00:12:15.206 A:middle
所以我们要一块一块地看

00:12:15.416 --> 00:12:17.916 A:middle
首先你会看到这部分元数据

00:12:18.826 --> 00:12:22.116 A:middle
这包括生成这个接口的编译器版本

00:12:22.116 --> 00:12:24.276 A:middle
但它也包含

00:12:24.306 --> 00:12:26.026 A:middle
命令行标记的子集

00:12:26.316 --> 00:12:27.696 A:middle
Swift 编译器需要

00:12:27.696 --> 00:12:29.256 A:middle
将其作为模块导入

00:12:32.156 --> 00:12:34.636 A:middle
接下来你将看到

00:12:34.636 --> 00:12:36.986 A:middle
这个框架导入的所有模块

00:12:37.836 --> 00:12:39.306 A:middle
然后我们将开始

00:12:39.306 --> 00:12:41.096 A:middle
查看作为该接口一部分的一些类型

00:12:42.356 --> 00:12:44.846 A:middle
这是 Spaceship 类的公共 API

00:12:44.976 --> 00:12:46.926 A:middle
现在我希望

00:12:46.926 --> 00:12:48.126 A:middle
你注意到这三件事

00:12:48.766 --> 00:12:50.516 A:middle
第一

00:12:50.516 --> 00:12:52.706 A:middle
公共 name 属性

00:12:52.706 --> 00:12:54.806 A:middle
包含在接口中

00:12:54.806 --> 00:12:56.706 A:middle
但是私有 currentLocation 属性不包含

00:12:57.896 --> 00:13:00.686 A:middle
它不是公共 API 的一部分

00:13:01.426 --> 00:13:04.176 A:middle
接下来

00:13:04.216 --> 00:13:06.356 A:middle
请注意接口中包含了公共初始化器

00:13:06.496 --> 00:13:07.876 A:middle
和 fly 方法

00:13:09.006 --> 00:13:10.796 A:middle
但是它们的主体

00:13:10.796 --> 00:13:11.986 A:middle
没有被包括进去

00:13:11.986 --> 00:13:14.116 A:middle
同样也是因为它们不是公共 API 的一部分

00:13:15.276 --> 00:13:16.656 A:middle
最后请注意

00:13:16.656 --> 00:13:18.596 A:middle
该类在接口中

00:13:18.596 --> 00:13:20.286 A:middle
有一个取消初始化程序

00:13:20.286 --> 00:13:21.416 A:middle
但是在原始源代码中

00:13:21.416 --> 00:13:22.626 A:middle
却没有进行写入

00:13:23.186 --> 00:13:27.676 A:middle
现在当你在 Swift 中编写类

00:13:27.676 --> 00:13:29.456 A:middle
并且没有提供显式取消初始化程序时

00:13:29.456 --> 00:13:31.086 A:middle
编译器将为你生成一个

00:13:31.616 --> 00:13:35.666 A:middle
这强调了模块接口

00:13:35.666 --> 00:13:36.606 A:middle
的一个基本原则

00:13:37.146 --> 00:13:38.416 A:middle
如果这种格式

00:13:38.416 --> 00:13:42.156 A:middle
在编译器的不同版本之间

00:13:42.156 --> 00:13:43.976 A:middle
应该是稳定的

00:13:44.196 --> 00:13:45.886 A:middle
那么编译器不应该对底层源代码做任何假设

00:13:46.786 --> 00:13:48.926 A:middle
因此我们将其包含在模块接口中

00:13:49.506 --> 00:13:53.516 A:middle
接下来让我们看一下 Speed 枚举

00:13:54.466 --> 00:13:55.666 A:middle
首先要看到的是

00:13:55.666 --> 00:13:58.316 A:middle
两个枚举都被包含了

00:13:58.506 --> 00:14:02.086 A:middle
这些是公共 API 的一部分

00:14:02.086 --> 00:14:03.956 A:middle
然而在接口中

00:14:03.956 --> 00:14:06.316 A:middle
对于哈希需要明确的遵守

00:14:07.116 --> 00:14:08.876 A:middle
我们列出了

00:14:08.876 --> 00:14:11.476 A:middle
遵循哈希和相等

00:14:11.476 --> 00:14:12.566 A:middle
所需的方法

00:14:13.396 --> 00:14:14.846 A:middle
这是因为在 Swift 中

00:14:15.146 --> 00:14:16.666 A:middle
如果你生成了一个

00:14:16.666 --> 00:14:19.496 A:middle
没有任何关联值的枚举

00:14:19.496 --> 00:14:22.626 A:middle
那么编译器就会隐式地

00:14:22.626 --> 00:14:24.546 A:middle
使其符合哈希和相等

00:14:24.546 --> 00:14:26.276 A:middle
并自动派生出所需的方法

00:14:26.916 --> 00:14:29.306 A:middle
因此本着明确的精神

00:14:29.306 --> 00:14:32.576 A:middle
它被包含在模块接口中

00:14:33.956 --> 00:14:36.476 A:middle
最后 Location 结构体

00:14:36.656 --> 00:14:38.746 A:middle
以现在方式包含在内

00:14:38.746 --> 00:14:39.876 A:middle
因为它只有

00:14:39.876 --> 00:14:41.626 A:middle
公共存储的属性

00:14:41.626 --> 00:14:42.696 A:middle
并且不声明任何遵循

00:14:43.326 --> 00:14:46.976 A:middle
以上就是 FlightKit 的模块接口

00:14:51.496 --> 00:14:54.966 A:middle
现在你已经了解了框架内部的内容

00:14:54.966 --> 00:14:56.296 A:middle
接下来让我们

00:14:56.336 --> 00:14:58.766 A:middle
讨论如何自己构建一个

00:14:58.766 --> 00:14:59.156 A:middle
可分发的二进制 XC 框架

00:14:59.746 --> 00:15:03.936 A:middle
构建框架的第一步

00:15:03.936 --> 00:15:04.406 A:middle
是构建存档

00:15:05.326 --> 00:15:06.626 A:middle
归档你的框架

00:15:06.626 --> 00:15:08.656 A:middle
将在发布模式下构建它

00:15:08.656 --> 00:15:09.576 A:middle
并将其打包以进行分发

00:15:09.576 --> 00:15:12.716 A:middle
你可以在管理器窗口中看到它

00:15:13.746 --> 00:15:15.636 A:middle
此外作为附加优势

00:15:15.686 --> 00:15:17.376 A:middle
此存档还将包含

00:15:17.376 --> 00:15:18.776 A:middle
与框架的该版本

00:15:18.776 --> 00:15:20.196 A:middle
对应的调试信息

00:15:20.196 --> 00:15:21.906 A:middle
这意味着

00:15:21.906 --> 00:15:23.776 A:middle
如果客户端有任何崩溃

00:15:26.526 --> 00:15:27.936 A:middle
他们将能够将其

00:15:27.936 --> 00:15:29.056 A:middle
发送给你

00:15:29.146 --> 00:15:31.606 A:middle
而你将能够查看符号并调试它

00:15:32.336 --> 00:15:34.626 A:middle
要存档框架

00:15:34.626 --> 00:15:36.776 A:middle
你可以使用 xcodebuild 存档命令

00:15:37.836 --> 00:15:39.166 A:middle
你将输入项目中

00:15:39.166 --> 00:15:40.596 A:middle
框架的 scheme

00:15:41.606 --> 00:15:44.406 A:middle
并列出要为其编译的目标

00:15:45.186 --> 00:15:46.606 A:middle
因此如果你正在为 iOS 构建

00:15:46.976 --> 00:15:47.836 A:middle
可以是一个用于模拟器

00:15:47.836 --> 00:15:49.676 A:middle
一个用于设备以及

00:15:50.266 --> 00:15:52.216 A:middle
一个用于运行 UIKit 的 Mac

00:15:52.836 --> 00:15:55.486 A:middle
你还需要通过

00:15:55.486 --> 00:15:57.416 A:middle
Skip Install 生成设置

00:15:57.416 --> 00:15:58.276 A:middle
并将其设置为 No

00:15:59.096 --> 00:16:01.316 A:middle
这告诉 xcodebuild 存档

00:16:01.316 --> 00:16:04.286 A:middle
在生成的存档中安装框架

00:16:04.926 --> 00:16:09.276 A:middle
因此通过执行此操作

00:16:09.276 --> 00:16:11.636 A:middle
你将构建框架的

00:16:11.636 --> 00:16:13.666 A:middle
每个变体的存档

00:16:13.666 --> 00:16:15.056 A:middle
这些存档

00:16:15.056 --> 00:16:17.186 A:middle
将在 Preference 窗口中的

00:16:17.186 --> 00:16:20.096 A:middle
Location 选项卡中的 Archive 目录可用

00:16:20.606 --> 00:16:24.186 A:middle
构建这些存档后

00:16:24.186 --> 00:16:25.966 A:middle
你可以提取框架

00:16:25.966 --> 00:16:27.456 A:middle
并将它们捆绑在

00:16:27.456 --> 00:16:29.546 A:middle
一个 XC 框架中

00:16:30.056 --> 00:16:32.486 A:middle
为此你将运行 

00:16:32.486 --> 00:16:35.366 A:middle
xcodebuild -create-xcframework 命令

00:16:36.456 --> 00:16:40.186 A:middle
你将输入磁盘上每个框架的路径

00:16:40.186 --> 00:16:41.956 A:middle
然后提供你希望

00:16:42.006 --> 00:16:46.456 A:middle
输出 XC 框架输出到的路径

00:16:46.696 --> 00:16:49.526 A:middle
以上就是如何构建 XC 框架

00:16:49.526 --> 00:16:51.946 A:middle
总而言之请记住

00:16:51.946 --> 00:16:53.916 A:middle
你需要启用

00:16:53.916 --> 00:16:55.626 A:middle
Build Libraries for Distribution

00:16:55.626 --> 00:16:57.356 A:middle
以确保你的库是为了分发而构建的

00:16:57.436 --> 00:17:00.996 A:middle
你将运行 xcodebuild 归档

00:17:01.536 --> 00:17:02.536 A:middle
以构建框架的归档

00:17:02.536 --> 00:17:05.576 A:middle
最后运行 

00:17:05.576 --> 00:17:06.536 A:middle
xcodebuild -create-xcframework

00:17:06.566 --> 00:17:10.705 A:middle
将其打包以便分发

00:17:11.146 --> 00:17:12.165 A:middle
然后你可以开始

00:17:12.165 --> 00:17:13.205 A:middle
将其发送给你的客户

00:17:13.205 --> 00:17:14.586 A:middle
然后他们可以开始采用它

00:17:15.195 --> 00:17:16.925 A:middle
这就是 XC 框架

00:17:18.326 --> 00:17:19.846 A:middle
现在我的同事 Jordan 

00:17:19.846 --> 00:17:21.026 A:middle
将向你介绍作为一个框架作者

00:17:21.026 --> 00:17:22.656 A:middle
你应该考虑哪些内容

00:17:22.656 --> 00:17:26.185 A:middle
以使你的框架尽可能

00:17:26.185 --> 00:17:26.685 A:middle
顺畅地使用

00:17:28.516 --> 00:17:34.546 A:middle
[掌声和欢呼]

00:17:35.046 --> 00:17:35.736 A:middle
&gt;&gt; 谢谢 Harlan

00:17:36.006 --> 00:17:38.086 A:middle
好的 我们看到

00:17:38.376 --> 00:17:39.876 A:middle
将这些 XC 框架中的一个

00:17:40.066 --> 00:17:42.256 A:middle
引入作为框架客户端的 App

00:17:42.256 --> 00:17:43.906 A:middle
是多么容易

00:17:43.906 --> 00:17:45.556 A:middle
我们看到了生成

00:17:45.586 --> 00:17:46.276 A:middle
XC 框架所需的步骤

00:17:47.016 --> 00:17:48.316 A:middle
但这只是第一步

00:17:48.576 --> 00:17:49.476 A:middle
因为你是框架作者

00:17:49.476 --> 00:17:53.326 A:middle
并且你每年都在开发新功能

00:17:53.326 --> 00:17:55.446 A:middle
并为客户端做得更好

00:17:56.236 --> 00:17:57.296 A:middle
因此在这一节中

00:17:57.296 --> 00:17:58.926 A:middle
我将讨论

00:17:58.926 --> 00:17:59.456 A:middle
三件主要的事情

00:18:01.556 --> 00:18:02.556 A:middle
逐步发展你的框架

00:18:03.366 --> 00:18:05.936 A:middle
利用 Swift 提供的一些灵活性

00:18:05.936 --> 00:18:07.546 A:middle
来优化客户端

00:18:08.296 --> 00:18:09.536 A:middle
并帮助客户端

00:18:09.536 --> 00:18:10.606 A:middle
获得尽可能

00:18:10.606 --> 00:18:11.196 A:middle
平稳流畅的体验

00:18:11.736 --> 00:18:14.596 A:middle
因此请从发展你的框架开始

00:18:15.196 --> 00:18:17.186 A:middle
当我说要发展你的框架时

00:18:17.186 --> 00:18:18.456 A:middle
我是什么意思呢

00:18:19.496 --> 00:18:22.966 A:middle
好吧就像我说的

00:18:22.966 --> 00:18:24.366 A:middle
每次你发布新版本的框架时

00:18:24.366 --> 00:18:25.736 A:middle
它都会有新的功能

00:18:25.736 --> 00:18:27.746 A:middle
新的 API

00:18:27.746 --> 00:18:29.936 A:middle
可能还有一些漏洞修复

00:18:29.936 --> 00:18:31.866 A:middle
我们希望能够

00:18:31.866 --> 00:18:33.736 A:middle
在不破坏源代码

00:18:33.736 --> 00:18:34.726 A:middle
或二进制兼容性的情况下做到这一点

00:18:35.586 --> 00:18:37.776 A:middle
那么为什么二进制兼容性

00:18:37.776 --> 00:18:38.686 A:middle
在这里很重要呢

00:18:39.876 --> 00:18:41.156 A:middle
这是因为你

00:18:41.156 --> 00:18:42.766 A:middle
不一定知道

00:18:42.766 --> 00:18:44.256 A:middle
你的客户是谁

00:18:44.746 --> 00:18:47.266 A:middle
很多时候它只是一个 App Target

00:18:47.576 --> 00:18:48.526 A:middle
它们会使用你的框架

00:18:48.766 --> 00:18:50.956 A:middle
打包然后送到商店

00:18:52.246 --> 00:18:53.806 A:middle
但有时你的客户

00:18:53.836 --> 00:18:55.396 A:middle
本身就是二进制框架

00:18:55.476 --> 00:18:57.246 A:middle
要么来自你的公司

00:18:57.246 --> 00:18:59.846 A:middle
要么完全来自另一家公司

00:18:59.896 --> 00:19:02.756 A:middle
在这种情况下

00:19:02.836 --> 00:19:04.396 A:middle
你们两个可能

00:19:04.396 --> 00:19:04.926 A:middle
有不同的发布时间表

00:19:05.576 --> 00:19:06.596 A:middle
他们可能会

00:19:06.596 --> 00:19:08.896 A:middle
一直升级到 2.1 版

00:19:08.896 --> 00:19:10.816 A:middle
而你还在开发最新的版本

00:19:10.816 --> 00:19:16.246 A:middle
当你最终发布 1.1 版本时

00:19:16.246 --> 00:19:17.566 A:middle
他们不应该再为采用它

00:19:17.566 --> 00:19:18.636 A:middle
而付出任何额外的努力

00:19:19.116 --> 00:19:19.906 A:middle
你不希望陷入

00:19:19.906 --> 00:19:21.946 A:middle
两个二进制框架

00:19:21.946 --> 00:19:23.436 A:middle
彼此版本锁定的情况

00:19:23.436 --> 00:19:26.506 A:middle
因为使用它们的 App 可能

00:19:26.506 --> 00:19:30.766 A:middle
决定不更新

00:19:30.976 --> 00:19:32.266 A:middle
所以我在这里说

00:19:32.266 --> 00:19:33.426 A:middle
你的框架版本很重要

00:19:33.426 --> 00:19:35.366 A:middle
你不仅想

00:19:35.366 --> 00:19:38.556 A:middle
把它放在你的网站和你的文档上

00:19:38.806 --> 00:19:40.066 A:middle
而且你还应该

00:19:40.066 --> 00:19:41.686 A:middle
把它放在框架本身里

00:19:41.686 --> 00:19:43.736 A:middle
并且能这样做的地方是

00:19:43.736 --> 00:19:45.426 A:middle
框架的 Info.plist 中的

00:19:45.426 --> 00:19:46.636 A:middle
Bundle 版本字符串设置

00:19:47.486 --> 00:19:49.326 A:middle
这是人类可读版本号

00:19:49.326 --> 00:19:52.886 A:middle
你可以在这里与客户交流

00:19:52.886 --> 00:19:55.396 A:middle
自上次发布以来所做的更改

00:19:55.986 --> 00:19:58.576 A:middle
我们推荐的方法

00:19:58.576 --> 00:20:00.966 A:middle
是使用语义版本控制

00:20:01.616 --> 00:20:02.416 A:middle
如果你之前

00:20:02.416 --> 00:20:04.156 A:middle
没参加包讨论的话

00:20:04.246 --> 00:20:05.446 A:middle
我现在将快速回顾一下

00:20:05.446 --> 00:20:06.866 A:middle
什么是语义版本控制

00:20:07.676 --> 00:20:09.326 A:middle
最小的组成部分是

00:20:09.326 --> 00:20:11.306 A:middle
补丁版本

00:20:11.456 --> 00:20:12.856 A:middle
它表示何时对框架进行漏洞修复

00:20:12.856 --> 00:20:14.156 A:middle
或实现更改

00:20:14.156 --> 00:20:15.886 A:middle
而这些更改

00:20:15.886 --> 00:20:17.266 A:middle
不应该影响客户

00:20:18.076 --> 00:20:20.216 A:middle
中间组成部分用于

00:20:20.416 --> 00:20:22.106 A:middle
向后兼容的版本

00:20:22.466 --> 00:20:24.746 A:middle
新 API 或新功能

00:20:25.386 --> 00:20:28.796 A:middle
而主要的组成部分

00:20:28.796 --> 00:20:30.416 A:middle
是你必须做的

00:20:30.416 --> 00:20:32.356 A:middle
任何中断更改

00:20:32.436 --> 00:20:34.486 A:middle
不管是源代码中断

00:20:34.486 --> 00:20:37.016 A:middle
二进制中断

00:20:37.506 --> 00:20:38.986 A:middle
还是语义中断

00:20:39.046 --> 00:20:41.916 A:middle
在某种程度上

00:20:41.916 --> 00:20:43.606 A:middle
客户将不得不重新构建

00:20:43.606 --> 00:20:45.216 A:middle
甚至可能重做一些客户端代码

00:20:45.216 --> 00:20:46.156 A:middle
以采用新版本的框架

00:20:46.586 --> 00:20:49.036 A:middle
让我们看一下 

00:20:49.036 --> 00:20:50.746 A:middle
FlightKit 模型对象

00:20:50.746 --> 00:20:51.676 A:middle
在实践中的效果

00:20:52.586 --> 00:20:53.826 A:middle
所以左边的情况

00:20:53.826 --> 00:20:56.096 A:middle
与我们之前的情况相同

00:20:57.366 --> 00:20:59.136 A:middle
现在在右边

00:20:59.136 --> 00:21:00.946 A:middle
我对这个框架进行了一系列更改

00:21:02.096 --> 00:21:03.406 A:middle
让我们逐个讨论它们

00:21:03.476 --> 00:21:06.526 A:middle
看看每个更改如何影响

00:21:06.526 --> 00:21:07.246 A:middle
框架的版本号

00:21:08.506 --> 00:21:09.446 A:middle
我们将从顶部开始

00:21:10.466 --> 00:21:12.286 A:middle
我已经为 Spaceship 船类

00:21:12.286 --> 00:21:13.896 A:middle
添加了一个新的私有属性

00:21:14.396 --> 00:21:15.966 A:middle
而我正在 Spaceship 的

00:21:15.966 --> 00:21:17.226 A:middle
初始化器中使用它

00:21:18.556 --> 00:21:20.996 A:middle
目前这些东西

00:21:20.996 --> 00:21:22.506 A:middle
都不会出现

00:21:22.506 --> 00:21:23.156 A:middle
在模块界面中

00:21:23.466 --> 00:21:24.446 A:middle
它们并不是你框架

00:21:24.446 --> 00:21:25.696 A:middle
的公共 API 的一部分

00:21:26.976 --> 00:21:28.796 A:middle
因此这种更改

00:21:28.796 --> 00:21:30.556 A:middle
只需要更新次要部分

00:21:30.556 --> 00:21:32.116 A:middle
或补丁版本部分

00:21:33.916 --> 00:21:36.086 A:middle
请记住

00:21:36.146 --> 00:21:37.786 A:middle
虽然我确实改变了

00:21:37.786 --> 00:21:39.776 A:middle
初始化程序的行为

00:21:39.776 --> 00:21:42.536 A:middle
如果之前记录了这种行为

00:21:42.536 --> 00:21:43.806 A:middle
那么这将是

00:21:43.856 --> 00:21:45.826 A:middle
一个语义突破的变化

00:21:45.826 --> 00:21:48.866 A:middle
客户必须考虑是否更新

00:21:48.866 --> 00:21:50.386 A:middle
因此我应该

00:21:50.386 --> 00:21:51.356 A:middle
更改主版本号

00:21:51.986 --> 00:21:55.206 A:middle
现在我在这里

00:21:55.206 --> 00:21:57.376 A:middle
做的下一个更改

00:21:57.376 --> 00:21:58.496 A:middle
是向 Spaceship 类添加一个新方法

00:21:58.796 --> 00:22:00.616 A:middle
这是一个新的公共方法

00:22:00.616 --> 00:22:01.926 A:middle
这意味着客户

00:22:01.926 --> 00:22:02.886 A:middle
将开始使用它并依赖它

00:22:03.846 --> 00:22:05.566 A:middle
因此正确的做法

00:22:05.566 --> 00:22:07.636 A:middle
是增加次要版本号

00:22:08.146 --> 00:22:09.676 A:middle
你会注意到

00:22:09.676 --> 00:22:13.846 A:middle
我还将补丁版本重置为零

00:22:13.966 --> 00:22:16.516 A:middle
最后我还在 fly 方法

00:22:16.516 --> 00:22:18.406 A:middle
中添加了一个新参数

00:22:19.356 --> 00:22:21.486 A:middle
我已经给了它一个默认值

00:22:21.486 --> 00:22:23.536 A:middle
这样大多数的使用站点

00:22:23.586 --> 00:22:24.206 A:middle
就不必更改了

00:22:24.986 --> 00:22:27.126 A:middle
但在 Swift 中

00:22:27.126 --> 00:22:29.686 A:middle
函数的名称和参数

00:22:30.216 --> 00:22:31.466 A:middle
是唯一标识的

00:22:31.466 --> 00:22:33.616 A:middle
参数标签和类型

00:22:34.286 --> 00:22:36.626 A:middle
所以这里我已经破坏了

00:22:36.966 --> 00:22:39.726 A:middle
源代码和二进制兼容性

00:22:39.726 --> 00:22:41.706 A:middle
所以这需要

00:22:41.706 --> 00:22:43.636 A:middle
更新主版本号

00:22:43.636 --> 00:22:44.926 A:middle
并要求任何客户端重新编译

00:22:45.616 --> 00:22:46.696 A:middle
也许我应该

00:22:46.696 --> 00:22:47.686 A:middle
做一个新的过载

00:22:48.286 --> 00:22:51.426 A:middle
现在这些都是

00:22:51.426 --> 00:22:52.856 A:middle
对 Spaceship 类的更改

00:22:52.856 --> 00:22:54.266 A:middle
但我也更改了

00:22:54.266 --> 00:22:55.796 A:middle
FlightKit 中的一些值类型

00:22:55.796 --> 00:22:58.786 A:middle
我在 Speed 枚举中添加了一个新案例

00:23:02.516 --> 00:23:03.836 A:middle
这样客户端就可以拥有它们的集合

00:23:03.836 --> 00:23:06.436 A:middle
这是我最喜欢的更改

00:23:06.436 --> 00:23:08.726 A:middle
我在不破坏源代码

00:23:08.726 --> 00:23:10.626 A:middle
或二进制兼容性的情况下

00:23:10.896 --> 00:23:12.516 A:middle
向 Location 结构添加了

00:23:12.516 --> 00:23:13.816 A:middle
一个新的存储属性

00:23:14.516 --> 00:23:19.546 A:middle
[掌声]

00:23:20.046 --> 00:23:21.706 A:middle
现在在 Swift 中

00:23:21.706 --> 00:23:23.126 A:middle
所有这些更改

00:23:23.166 --> 00:23:24.866 A:middle
都是向后兼容的

00:23:24.866 --> 00:23:26.606 A:middle
所以我只需要修改次要版本号

00:23:27.186 --> 00:23:30.266 A:middle
现在这种灵活性

00:23:30.266 --> 00:23:31.866 A:middle
对如何设计框架的

00:23:31.866 --> 00:23:33.906 A:middle
API 有一些影响

00:23:34.616 --> 00:23:36.426 A:middle
最重要的是

00:23:36.426 --> 00:23:37.536 A:middle
从小处着手

00:23:38.086 --> 00:23:39.436 A:middle
如果你发现

00:23:39.436 --> 00:23:41.026 A:middle
你需要新功能

00:23:41.026 --> 00:23:42.736 A:middle
或者你的客户文件

00:23:42.736 --> 00:23:44.896 A:middle
反馈说需要更多的功能

00:23:44.896 --> 00:23:46.526 A:middle
那么添加新功能是很容易的

00:23:47.086 --> 00:23:48.576 A:middle
但是很难

00:23:48.626 --> 00:23:50.296 A:middle
删除某些东西

00:23:50.296 --> 00:23:51.946 A:middle
因为它很可能会破坏

00:23:51.946 --> 00:23:53.816 A:middle
至少一个客户的源代码

00:23:53.816 --> 00:23:55.326 A:middle
或二进制兼容性

00:23:56.316 --> 00:23:57.866 A:middle
对于那些你在事后

00:23:57.866 --> 00:23:59.016 A:middle
无法更改的东西

00:23:59.526 --> 00:24:00.906 A:middle
比如你的类型的名称

00:24:01.276 --> 00:24:02.366 A:middle
请确保你

00:24:02.366 --> 00:24:04.136 A:middle
预先仔细考虑过它们

00:24:04.136 --> 00:24:05.286 A:middle
这些名称不仅在

00:24:05.286 --> 00:24:07.666 A:middle
这个版本中有意义

00:24:07.666 --> 00:24:09.076 A:middle
而且在所有将来的版本中都有意义

00:24:09.616 --> 00:24:13.386 A:middle
最后不要过早地

00:24:13.386 --> 00:24:15.026 A:middle
添加可扩展性

00:24:15.606 --> 00:24:16.556 A:middle
你不需要在框架的

00:24:16.556 --> 00:24:18.406 A:middle
第一个版本中

00:24:18.406 --> 00:24:20.476 A:middle
将类设为开放

00:24:20.476 --> 00:24:21.756 A:middle
提供任意的回调

00:24:22.666 --> 00:24:23.706 A:middle
为什么这很重要

00:24:24.386 --> 00:24:25.806 A:middle
因为当你必须

00:24:25.876 --> 00:24:27.926 A:middle
考虑客户可能

00:24:27.996 --> 00:24:29.986 A:middle
同时在做什么时

00:24:29.986 --> 00:24:31.526 A:middle
对框架行为的推理

00:24:31.526 --> 00:24:32.516 A:middle
会变得更加困难

00:24:33.666 --> 00:24:35.776 A:middle
你总是可以在

00:24:35.776 --> 00:24:37.226 A:middle
将来开放类

00:24:37.826 --> 00:24:39.196 A:middle
你总是可以添加

00:24:39.196 --> 00:24:40.146 A:middle
表示额外回调的属性

00:24:40.146 --> 00:24:42.696 A:middle
但在默认情况下

00:24:42.696 --> 00:24:44.396 A:middle
不能删除

00:24:44.396 --> 00:24:45.036 A:middle
所添加的灵活性

00:24:45.706 --> 00:24:49.336 A:middle
那么这一切是如何运作的呢

00:24:50.546 --> 00:24:53.906 A:middle
间接 这仅仅只是一个单词而已

00:24:53.906 --> 00:24:55.226 A:middle
让我们现在来看一个例子

00:24:55.356 --> 00:24:58.166 A:middle
在左边这里

00:24:58.446 --> 00:24:59.796 A:middle
我有 Spaceship 类

00:24:59.796 --> 00:25:03.206 A:middle
这次剥离到它的模块接口

00:25:03.206 --> 00:25:04.806 A:middle
在右边我使用了 fly 方法

00:25:06.106 --> 00:25:07.396 A:middle
这是来自 FlightKit 

00:25:07.516 --> 00:25:09.456 A:middle
框架外部的客户代码

00:25:10.536 --> 00:25:11.936 A:middle
运行时

00:25:11.936 --> 00:25:13.616 A:middle
客户端会问

00:25:13.616 --> 00:25:15.526 A:middle
哪个方法

00:25:15.526 --> 00:25:17.266 A:middle
是 fly 方法

00:25:17.786 --> 00:25:20.176 A:middle
框架会回应

00:25:20.756 --> 00:25:22.326 A:middle
是第二个

00:25:23.076 --> 00:25:25.556 A:middle
这就是 Swift 

00:25:25.556 --> 00:25:27.766 A:middle
确保二进制兼容性的方式

00:25:27.766 --> 00:25:28.866 A:middle
即使在向类添加新方法时也是如此

00:25:30.156 --> 00:25:31.826 A:middle
它基本上

00:25:32.026 --> 00:25:33.526 A:middle
与 Objective-C

00:25:33.566 --> 00:25:35.776 A:middle
进行消息调度的方式相同

00:25:36.046 --> 00:25:40.156 A:middle
在从一个库到另一个库的调用中执行它

00:25:40.196 --> 00:25:43.766 A:middle
但 Swift 仅在你跨越此客户框架边界时执行此操作

00:25:45.716 --> 00:25:46.876 A:middle
还有另一种

00:25:46.876 --> 00:25:48.396 A:middle
间接的形式

00:25:48.796 --> 00:25:51.786 A:middle
当客户使用框架中

00:25:52.086 --> 00:25:53.466 A:middle
定义的结构体或枚举时

00:25:54.536 --> 00:25:55.826 A:middle
在本例中

00:25:55.826 --> 00:25:57.906 A:middle
fly 方法的一个参数

00:25:57.906 --> 00:26:00.546 A:middle
是来自 speed 枚举的 fast case

00:26:01.176 --> 00:26:03.506 A:middle
我之前说过

00:26:03.506 --> 00:26:05.046 A:middle
枚举可以在

00:26:05.326 --> 00:26:06.316 A:middle
不破坏二进制兼容性的情况下

00:26:06.316 --> 00:26:07.106 A:middle
添加新 case

00:26:08.576 --> 00:26:10.296 A:middle
这意味着

00:26:10.296 --> 00:26:12.906 A:middle
客户端不能假设

00:26:12.906 --> 00:26:14.936 A:middle
它知道枚举在内存中的大小

00:26:16.026 --> 00:26:18.286 A:middle
因此枚举的这种使用

00:26:18.286 --> 00:26:19.836 A:middle
要求客户端

00:26:20.586 --> 00:26:21.396 A:middle
询问框架有多大

00:26:22.236 --> 00:26:25.546 A:middle
框架回应它只有一个字节

00:26:26.976 --> 00:26:29.386 A:middle
这里的另一种可能性是

00:26:29.386 --> 00:26:30.876 A:middle
将来添加的新 case 之一

00:26:30.876 --> 00:26:33.316 A:middle
可能具有相关的值

00:26:34.156 --> 00:26:35.636 A:middle
那些相关的值

00:26:35.636 --> 00:26:37.396 A:middle
可能需要一些清理

00:26:38.606 --> 00:26:40.376 A:middle
因此客户端也会

00:26:40.376 --> 00:26:41.906 A:middle
要求框架在完成时

00:26:41.906 --> 00:26:43.606 A:middle
清除枚举值

00:26:43.606 --> 00:26:45.526 A:middle
并且框架也将这样做

00:26:46.106 --> 00:26:48.986 A:middle
此时观众中

00:26:48.986 --> 00:26:50.596 A:middle
的一些人

00:26:50.596 --> 00:26:52.206 A:middle
可能会变得有些烦躁

00:26:52.766 --> 00:26:54.446 A:middle
因为我们谈论的

00:26:54.446 --> 00:26:56.436 A:middle
是客户端和框架之间的

00:26:56.436 --> 00:26:57.716 A:middle
所有这些额外的通信

00:26:58.766 --> 00:26:59.796 A:middle
那是因为你有

00:26:59.986 --> 00:27:01.076 A:middle
对性能敏感的框架

00:27:01.076 --> 00:27:02.636 A:middle
这就是为什么下一节 

00:27:02.636 --> 00:27:04.086 A:middle
是关于牺牲

00:27:04.086 --> 00:27:05.506 A:middle
Swift 提供的灵活性

00:27:05.506 --> 00:27:07.206 A:middle
来换取

00:27:07.206 --> 00:27:12.966 A:middle
给客户的优化

00:27:14.416 --> 00:27:16.696 A:middle
这是一个权衡

00:27:17.386 --> 00:27:19.156 A:middle
作为框架的作者

00:27:19.156 --> 00:27:20.586 A:middle
我们希望

00:27:20.586 --> 00:27:22.046 A:middle
能够在不破坏源代码

00:27:22.046 --> 00:27:24.626 A:middle
或二进制兼容性的情况下

00:27:24.626 --> 00:27:26.556 A:middle
灵活地更改 添加和改进

00:27:27.976 --> 00:27:29.616 A:middle
但是为了让编译器

00:27:29.616 --> 00:27:31.356 A:middle
尽可能快地

00:27:31.356 --> 00:27:33.356 A:middle
生成客户代码

00:27:33.356 --> 00:27:35.556 A:middle
它需要对框架中的内容做出假设

00:27:35.996 --> 00:27:40.146 A:middle
所以 Swift 需要同时

00:27:40.146 --> 00:27:42.656 A:middle
处理这两方面的问题

00:27:43.066 --> 00:27:45.646 A:middle
它的工作方式是

00:27:45.676 --> 00:27:46.866 A:middle
通过 Build Libraries for Distribution

00:27:46.866 --> 00:27:48.186 A:middle
的构建设置

00:27:48.826 --> 00:27:50.046 A:middle
Harlan 之前说过

00:27:50.046 --> 00:27:53.426 A:middle
除了生成模块接口文件之外

00:27:53.426 --> 00:27:55.576 A:middle
它还有多种效果

00:27:55.886 --> 00:27:57.446 A:middle
其中一种效果是

00:27:57.446 --> 00:27:59.426 A:middle
将默认值设置为偏向灵活性

00:28:02.736 --> 00:28:04.576 A:middle
能够处理所有这些用例

00:28:04.576 --> 00:28:06.646 A:middle
因此在本节中

00:28:06.816 --> 00:28:07.966 A:middle
我将讨论一下

00:28:07.966 --> 00:28:10.306 A:middle
一旦你从外部

00:28:10.506 --> 00:28:11.906 A:middle
分析了框架的行为

00:28:11.906 --> 00:28:13.466 A:middle
并且看到你需要额外的性能

00:28:13.466 --> 00:28:14.956 A:middle
你可以做些什么

00:28:15.046 --> 00:28:16.346 A:middle
有三种方法

00:28:16.346 --> 00:28:18.206 A:middle
可以做到这一点

00:28:18.876 --> 00:28:20.756 A:middle
内联函数

00:28:20.756 --> 00:28:21.326 A:middle
冻结枚举和冻结结构

00:28:21.926 --> 00:28:24.836 A:middle
因此我们将从

00:28:24.836 --> 00:28:26.576 A:middle
内联函数开始

00:28:26.576 --> 00:28:28.536 A:middle
这是去年在 Swift 4.2 中引入的一个特性

00:28:29.426 --> 00:28:31.526 A:middle
在这个例子中

00:28:31.526 --> 00:28:33.326 A:middle
我有一个 cargoship 子类

00:28:33.326 --> 00:28:35.286 A:middle
这是我们之前看到

00:28:35.286 --> 00:28:37.376 A:middle
的 Spaceship 类的一个子类

00:28:37.376 --> 00:28:39.466 A:middle
它有一个方法 canCarry

00:28:39.826 --> 00:28:41.606 A:middle
它只决定货船

00:28:41.606 --> 00:28:42.076 A:middle
是否能够装载一些货物

00:28:43.376 --> 00:28:45.046 A:middle
我把它变成了内联的

00:28:45.416 --> 00:28:46.426 A:middle
因为我认为

00:28:46.426 --> 00:28:47.726 A:middle
这对我的客户

00:28:47.726 --> 00:28:48.576 A:middle
表现很重要

00:28:49.736 --> 00:28:51.986 A:middle
这将使这个方法

00:28:51.986 --> 00:28:54.056 A:middle
成为我的公共接口的一部分

00:28:54.056 --> 00:28:55.906 A:middle
不仅是它的声明

00:28:55.906 --> 00:28:57.806 A:middle
而且是它的主体

00:28:58.916 --> 00:29:00.486 A:middle
这样做的效果是

00:29:00.486 --> 00:29:02.636 A:middle
将主体复制到

00:29:02.636 --> 00:29:03.646 A:middle
模块接口文件中

00:29:04.236 --> 00:29:07.076 A:middle
如果你看得比较快

00:29:07.366 --> 00:29:08.876 A:middle
你还会看到这个方法

00:29:08.946 --> 00:29:10.836 A:middle
引用 CargoShip 类

00:29:11.026 --> 00:29:12.356 A:middle
的一个内部属性

00:29:13.766 --> 00:29:15.326 A:middle
这是可能的

00:29:15.326 --> 00:29:16.936 A:middle
因为我已将

00:29:16.936 --> 00:29:18.296 A:middle
该属性标记为可从内联使用

00:29:19.386 --> 00:29:20.786 A:middle
这可以让你

00:29:20.786 --> 00:29:21.516 A:middle
充分利用这两个世界

00:29:22.246 --> 00:29:24.046 A:middle
作为框架的公共接口的一部分

00:29:24.096 --> 00:29:25.446 A:middle
该属性是可用的

00:29:25.446 --> 00:29:27.526 A:middle
但仅对

00:29:27.526 --> 00:29:29.656 A:middle
可内联代码可用

00:29:29.956 --> 00:29:31.476 A:middle
它仍然受到保护

00:29:31.476 --> 00:29:33.736 A:middle
不受外部客户端

00:29:33.736 --> 00:29:34.866 A:middle
任意读取或写入

00:29:35.426 --> 00:29:37.556 A:middle
所以它仍然是内部的

00:29:37.556 --> 00:29:38.556 A:middle
但可以从内联中使用

00:29:39.876 --> 00:29:41.866 A:middle
值得注意的是

00:29:41.866 --> 00:29:43.906 A:middle
这是一个声明决定

00:29:44.486 --> 00:29:46.016 A:middle
此处的 currentCargo 属性

00:29:46.016 --> 00:29:47.986 A:middle
也是内部的

00:29:47.986 --> 00:29:49.476 A:middle
不包含在模块界面中

00:29:51.936 --> 00:29:54.336 A:middle
我们在模块接口中

00:29:54.336 --> 00:29:56.676 A:middle
有 canCarry 方法的主体

00:29:57.366 --> 00:29:59.046 A:middle
当客户端根据

00:29:59.046 --> 00:30:00.746 A:middle
该接口进行编译时

00:30:00.746 --> 00:30:02.146 A:middle
他们将能够将

00:30:02.296 --> 00:30:03.916 A:middle
该主体直接复制到自己的代码中

00:30:04.326 --> 00:30:05.896 A:middle
如果他们了解

00:30:05.966 --> 00:30:07.486 A:middle
正在检查的

00:30:07.486 --> 00:30:08.676 A:middle
货物的一些信息

00:30:09.706 --> 00:30:09.826 A:middle
还可能进一步优化它

00:30:10.376 --> 00:30:12.046 A:middle
但是如果框架所有者

00:30:12.046 --> 00:30:14.126 A:middle
更改了方法的主体

00:30:14.126 --> 00:30:15.926 A:middle
而客户没有重新编译

00:30:15.986 --> 00:30:17.136 A:middle
会发生什么呢

00:30:17.826 --> 00:30:21.466 A:middle
例如

00:30:21.466 --> 00:30:22.756 A:middle
如果有一条新规定说

00:30:22.756 --> 00:30:24.116 A:middle
货船不允许

00:30:24.116 --> 00:30:25.686 A:middle
装载放射性物质怎么办

00:30:26.936 --> 00:30:28.556 A:middle
在这种情况下

00:30:28.556 --> 00:30:29.476 A:middle
我们会遇到麻烦

00:30:29.906 --> 00:30:31.266 A:middle
因为现在程序的

00:30:31.266 --> 00:30:32.516 A:middle
两个不同部分

00:30:32.516 --> 00:30:34.216 A:middle
对这个方法应该做什么

00:30:34.216 --> 00:30:34.976 A:middle
有不同的想法

00:30:35.946 --> 00:30:37.296 A:middle
对于一些输入

00:30:37.296 --> 00:30:39.766 A:middle
它们仍然会同意

00:30:39.766 --> 00:30:42.196 A:middle
对于一些常规的货物

00:30:42.976 --> 00:30:46.166 A:middle
客户端和框架

00:30:46.706 --> 00:30:47.076 A:middle
都会说没问题

00:30:47.076 --> 00:30:48.196 A:middle
但是如果

00:30:48.196 --> 00:30:50.616 A:middle
我们试图测试放射性货物

00:30:50.616 --> 00:30:52.426 A:middle
那么客户端代码会说没问题

00:30:52.426 --> 00:30:54.336 A:middle
因为这是

00:30:54.336 --> 00:30:55.566 A:middle
它在编译模块

00:30:55.566 --> 00:30:56.326 A:middle
接口时看到的

00:30:57.376 --> 00:30:58.846 A:middle
虽然框架

00:30:58.846 --> 00:31:00.706 A:middle
具有该方法的新版本

00:31:00.706 --> 00:31:01.556 A:middle
但仍然将不允许它

00:31:02.216 --> 00:31:03.946 A:middle
这可能表明

00:31:03.946 --> 00:31:05.456 A:middle
程序中存在严重的逻辑错误

00:31:06.526 --> 00:31:08.566 A:middle
因此作为一个经验法则

00:31:08.566 --> 00:31:09.646 A:middle
如果你是一个框架作者

00:31:09.646 --> 00:31:11.116 A:middle
并且使一个函数可以内联

00:31:11.666 --> 00:31:13.236 A:middle
那么请确保

00:31:13.236 --> 00:31:14.976 A:middle
不要更改输出或可观察的行为

00:31:16.176 --> 00:31:17.606 A:middle
你可以添加

00:31:17.606 --> 00:31:19.966 A:middle
一个更好的算法

00:31:20.036 --> 00:31:21.866 A:middle
或者一些额外的快速填充

00:31:21.866 --> 00:31:23.166 A:middle
但是如果你

00:31:23.166 --> 00:31:25.286 A:middle
改变了函数的可观察行为

00:31:25.286 --> 00:31:26.256 A:middle
那么你最终

00:31:26.256 --> 00:31:27.836 A:middle
可能会遇到这些非常微妙的问题

00:31:27.836 --> 00:31:29.776 A:middle
这些问题只在运行时可见

00:31:29.776 --> 00:31:30.796 A:middle
而且可能只在某些输入下可见

00:31:31.096 --> 00:31:32.556 A:middle
如果你需要这样做

00:31:32.556 --> 00:31:34.096 A:middle
则需要重新编译所有客户端

00:31:34.686 --> 00:31:39.836 A:middle
接下来我想谈谈枚举

00:31:40.946 --> 00:31:43.756 A:middle
Swift 枚举很棒 我爱它们

00:31:44.556 --> 00:31:45.496 A:middle
我们在这里谈到的一件事是

00:31:45.496 --> 00:31:47.036 A:middle
你可以在

00:31:47.036 --> 00:31:48.946 A:middle
不破坏源代码或

00:31:48.976 --> 00:31:50.236 A:middle
二进制兼容性的情况下

00:31:50.236 --> 00:31:51.096 A:middle
将新 case 添加到枚举中

00:31:51.946 --> 00:31:53.796 A:middle
这对客户端意味着

00:31:53.796 --> 00:31:54.996 A:middle
当切换枚举时

00:31:54.996 --> 00:31:57.566 A:middle
它们总是必须有一个默认情况

00:31:58.346 --> 00:31:59.976 A:middle
在这个客户端中

00:31:59.976 --> 00:32:03.276 A:middle
他们决定使用 Swift 4.2 中引入的

00:32:03.276 --> 00:32:06.276 A:middle
未知默认语法

00:32:06.516 --> 00:32:08.466 A:middle
这意味着它们已经处理了

00:32:08.466 --> 00:32:10.766 A:middle
枚举中所有已知的情况

00:32:10.766 --> 00:32:13.506 A:middle
但是仍然会

00:32:13.506 --> 00:32:15.146 A:middle
处理将来添加的任何情况

00:32:15.616 --> 00:32:16.906 A:middle
这在切换 C 枚举

00:32:16.906 --> 00:32:22.906 A:middle
和构建在二进制框架中的枚举时是必要的

00:32:23.456 --> 00:32:26.346 A:middle
这就是我之前

00:32:26.576 --> 00:32:28.026 A:middle
谈到的另一个影响

00:32:28.376 --> 00:32:30.026 A:middle
客户端和框架

00:32:30.026 --> 00:32:31.286 A:middle
之间的这种交流

00:32:31.586 --> 00:32:33.446 A:middle
关于枚举的大小

00:32:33.446 --> 00:32:34.866 A:middle
以及是否需要进行任何清理

00:32:35.306 --> 00:32:37.826 A:middle
但我在这里选择

00:32:37.826 --> 00:32:38.946 A:middle
的例子是飞行计划

00:32:39.746 --> 00:32:41.666 A:middle
你只能乘坐单程

00:32:41.666 --> 00:32:43.446 A:middle
或往返航班

00:32:44.826 --> 00:32:46.666 A:middle
因此通过使用

00:32:46.666 --> 00:32:49.336 A:middle
冻结属性标记此枚举

00:32:49.336 --> 00:32:50.786 A:middle
我作为框架作者

00:32:51.906 --> 00:32:53.286 A:middle
可以保证

00:32:53.286 --> 00:32:55.526 A:middle
在框架的未来版本中不会添加新 case

00:32:56.956 --> 00:32:58.796 A:middle
这样做的第一个影响是

00:32:58.796 --> 00:33:00.436 A:middle
客户端不再需要

00:33:00.436 --> 00:33:01.406 A:middle
编写该默认情况

00:33:01.596 --> 00:33:02.686 A:middle
它可以自行消失

00:33:04.276 --> 00:33:07.316 A:middle
接下来编译器

00:33:07.316 --> 00:33:09.226 A:middle
可以更有效地编译它

00:33:09.946 --> 00:33:12.476 A:middle
客户端可以假设

00:33:12.976 --> 00:33:14.266 A:middle
这个枚举不会

00:33:14.266 --> 00:33:16.236 A:middle
有任何额外的情况

00:33:16.236 --> 00:33:17.436 A:middle
也不需要进行任何清理

00:33:18.756 --> 00:33:22.346 A:middle
这太好了 只是我忘了一件事

00:33:22.996 --> 00:33:24.786 A:middle
还有另一种飞行计划

00:33:24.786 --> 00:33:26.026 A:middle
多程航班

00:33:27.186 --> 00:33:28.246 A:middle
现在我们遇到了麻烦

00:33:28.746 --> 00:33:30.546 A:middle
因为客户端代码

00:33:30.546 --> 00:33:32.956 A:middle
不再具有默认情况

00:33:32.956 --> 00:33:35.206 A:middle
因此在冻结枚举

00:33:35.206 --> 00:33:37.946 A:middle
中添加新 case

00:33:37.946 --> 00:33:39.476 A:middle
既包括源代码

00:33:39.476 --> 00:33:41.006 A:middle
和二进制代码中断

00:33:41.326 --> 00:33:42.706 A:middle
并且需要迭代主要版本

00:33:42.706 --> 00:33:48.296 A:middle
并要求所有客户端重新编译 现在在冷冻枚举后

00:33:48.296 --> 00:33:49.946 A:middle
冷冻结构大致相同

00:33:50.516 --> 00:33:52.886 A:middle
默认情况下

00:33:52.886 --> 00:33:54.646 A:middle
二进制框架中的结构

00:33:54.646 --> 00:33:55.756 A:middle
可以添加新的存储属性

00:33:55.756 --> 00:33:57.686 A:middle
或者对现有的属性

00:33:57.686 --> 00:33:59.856 A:middle
进行重新排序

00:33:59.916 --> 00:34:01.716 A:middle
而不会有任何问题

00:34:02.096 --> 00:34:03.066 A:middle
但这确实会导致

00:34:03.066 --> 00:34:04.856 A:middle
相同类型的交流

00:34:05.136 --> 00:34:06.036 A:middle
以及客户端和框架之间的额外通信

00:34:06.746 --> 00:34:10.485 A:middle
因此为了避免这种情况

00:34:10.485 --> 00:34:12.386 A:middle
对于已知

00:34:12.386 --> 00:34:14.956 A:middle
具有冻结布局的结构

00:34:14.956 --> 00:34:16.926 A:middle
可以使用冻结属性

00:34:17.216 --> 00:34:19.306 A:middle
来保证存储的属性不会更改

00:34:19.616 --> 00:34:20.936 A:middle
它们不会被添加

00:34:20.936 --> 00:34:22.166 A:middle
重新排序或删除

00:34:22.835 --> 00:34:25.596 A:middle
这样做的另一件事是

00:34:25.656 --> 00:34:27.726 A:middle
要求存储的属性

00:34:27.726 --> 00:34:30.126 A:middle
都具有公共的类型

00:34:30.126 --> 00:34:32.315 A:middle
或者内联的可用类型

00:34:32.876 --> 00:34:34.775 A:middle
因为记住这里的目标是什么

00:34:35.156 --> 00:34:37.146 A:middle
我们希望编译器

00:34:37.146 --> 00:34:39.505 A:middle
在处理客户端代码时

00:34:39.505 --> 00:34:40.846 A:middle
能够直接操作

00:34:40.846 --> 00:34:42.045 A:middle
这个结构的存储属性

00:34:42.045 --> 00:34:43.616 A:middle
以便在客户端

00:34:43.616 --> 00:34:46.926 A:middle
生成更有效的代码

00:34:47.815 --> 00:34:49.966 A:middle
这还具有语义效应

00:34:50.386 --> 00:34:51.416 A:middle
即框架作者

00:34:51.416 --> 00:34:53.936 A:middle
现在可以编写可内联的初始化器

00:34:54.525 --> 00:34:55.996 A:middle
设置结构中的

00:34:55.996 --> 00:34:57.836 A:middle
所有存储属性

00:34:57.836 --> 00:34:59.256 A:middle
已经需要一个初始化器

00:34:59.826 --> 00:35:01.866 A:middle
但是现在编译器

00:35:02.066 --> 00:35:03.726 A:middle
可以确保

00:35:03.726 --> 00:35:04.816 A:middle
在框架的未来版本

00:35:04.816 --> 00:35:05.236 A:middle
中也会这样做

00:35:05.326 --> 00:35:11.156 A:middle
现在我想提醒你

00:35:11.156 --> 00:35:13.036 A:middle
出于某些原因灵活性是默认的

00:35:13.036 --> 00:35:13.736 A:middle
来结束这部分话题

00:35:14.536 --> 00:35:15.896 A:middle
其中最主要的一点是

00:35:15.896 --> 00:35:17.656 A:middle
中断更改对客户

00:35:17.656 --> 00:35:19.226 A:middle
来说非常不方便

00:35:20.136 --> 00:35:21.926 A:middle
客户可能会

00:35:21.926 --> 00:35:23.516 A:middle
重新考虑是否

00:35:23.516 --> 00:35:25.026 A:middle
采用新版本的框架

00:35:25.026 --> 00:35:26.606 A:middle
因为框架可能会以

00:35:26.606 --> 00:35:27.686 A:middle
某种方式破坏它们自身

00:35:28.366 --> 00:35:29.446 A:middle
当一个二进制框架

00:35:29.446 --> 00:35:31.316 A:middle
依赖于另一个二进制框架时

00:35:31.316 --> 00:35:32.706 A:middle
你也可能会遇到麻烦

00:35:34.136 --> 00:35:35.666 A:middle
同样值得提醒的是

00:35:36.836 --> 00:35:39.286 A:middle
这些属性只影响客户端代码

00:35:39.696 --> 00:35:41.196 A:middle
在你的框架中

00:35:41.196 --> 00:35:44.186 A:middle
你仍然可以获得编译器优化的全部功能

00:35:45.586 --> 00:35:47.856 A:middle
因此在使用冻结

00:35:47.856 --> 00:35:49.716 A:middle
或内联之前

00:35:49.716 --> 00:35:51.156 A:middle
请确保你已经

00:35:51.156 --> 00:35:52.826 A:middle
从外部描述了框架的行为

00:35:53.256 --> 00:35:54.636 A:middle
并证明你需要

00:35:54.636 --> 00:35:56.216 A:middle
额外的性能

00:35:56.796 --> 00:35:58.936 A:middle
否则保持灵活性

00:35:58.936 --> 00:36:00.546 A:middle
因为你可能需要它

00:36:02.696 --> 00:36:04.106 A:middle
现在我想谈的最后一部分

00:36:04.106 --> 00:36:05.836 A:middle
是确保客户的

00:36:05.836 --> 00:36:08.516 A:middle
体验是最好的

00:36:09.266 --> 00:36:11.086 A:middle
这与 Harlan 

00:36:11.086 --> 00:36:12.826 A:middle
前半部分的

00:36:12.826 --> 00:36:13.916 A:middle
内容非常相似

00:36:14.496 --> 00:36:16.726 A:middle
我们将从授权开始

00:36:17.636 --> 00:36:19.036 A:middle
如果你的框架

00:36:19.036 --> 00:36:20.276 A:middle
具有完成其工作

00:36:20.276 --> 00:36:22.316 A:middle
所需的某些权利

00:36:22.316 --> 00:36:23.216 A:middle
那么让我们从基础开始

00:36:23.456 --> 00:36:24.636 A:middle
请你确保记录它们

00:36:24.636 --> 00:36:26.226 A:middle
以便任何潜在客户知道

00:36:26.226 --> 00:36:28.146 A:middle
成功采用你的框架

00:36:28.456 --> 00:36:30.096 A:middle
需要做什么

00:36:30.606 --> 00:36:34.536 A:middle
此外尽量减少

00:36:34.536 --> 00:36:38.486 A:middle
特定框架的授权请求

00:36:38.486 --> 00:36:39.676 A:middle
因为这意味着

00:36:39.676 --> 00:36:41.676 A:middle
它将适用于更多的上下文

00:36:42.126 --> 00:36:43.816 A:middle
你可以使用你的框架

00:36:44.086 --> 00:36:45.056 A:middle
获得更多客户

00:36:45.516 --> 00:36:49.636 A:middle
最后请记住

00:36:49.636 --> 00:36:51.486 A:middle
虽然框架和 App 

00:36:51.486 --> 00:36:53.036 A:middle
都可以向用户

00:36:53.096 --> 00:36:54.656 A:middle
请求权限

00:36:54.726 --> 00:36:56.686 A:middle
但最终是否

00:36:57.286 --> 00:36:58.446 A:middle
授予权限是用户的选择

00:36:59.606 --> 00:37:00.976 A:middle
因此如果你被

00:37:00.976 --> 00:37:02.746 A:middle
拒绝了某个特定的权限

00:37:02.746 --> 00:37:04.016 A:middle
请确保你的框架

00:37:04.016 --> 00:37:05.026 A:middle
能够优雅地处理该拒绝

00:37:05.316 --> 00:37:07.026 A:middle
它不应该使 App 崩溃

00:37:07.026 --> 00:37:08.156 A:middle
也不应该停止工作

00:37:08.646 --> 00:37:09.716 A:middle
确保它仍然做

00:37:09.756 --> 00:37:11.456 A:middle
一些有用的事情

00:37:11.456 --> 00:37:12.916 A:middle
以便你的客户

00:37:13.236 --> 00:37:15.166 A:middle
可以使用框架而不必放弃

00:37:16.996 --> 00:37:19.186 A:middle
现在依赖关系

00:37:19.186 --> 00:37:20.416 A:middle
与权限有很多

00:37:20.416 --> 00:37:21.176 A:middle
相同的问题

00:37:21.926 --> 00:37:23.506 A:middle
因为就像权限一样

00:37:23.506 --> 00:37:25.416 A:middle
框架的依赖关系

00:37:25.416 --> 00:37:26.986 A:middle
变成了 App 的依赖关系

00:37:27.986 --> 00:37:30.136 A:middle
因此你应该

00:37:30.136 --> 00:37:31.906 A:middle
首先记录它们

00:37:31.906 --> 00:37:33.816 A:middle
以便潜在客户

00:37:33.816 --> 00:37:34.826 A:middle
知道他们注册了什么

00:37:35.486 --> 00:37:36.776 A:middle
而且你应该尽量

00:37:36.776 --> 00:37:38.156 A:middle
减少你的依赖关系

00:37:38.156 --> 00:37:39.796 A:middle
这样你对客户的要求就会更少

00:37:40.106 --> 00:37:42.036 A:middle
在扩展信任方面

00:37:42.036 --> 00:37:43.986 A:middle
你对客户的要求也要更少

00:37:43.986 --> 00:37:45.696 A:middle
甚至在实际问题上

00:37:45.696 --> 00:37:46.346 A:middle
比如依赖项占用的代码大小方面

00:37:48.006 --> 00:37:51.876 A:middle
最后 所有的依赖项都必须使用

00:37:52.106 --> 00:37:53.216 A:middle
Build Libraries for Distribution

00:37:53.216 --> 00:37:55.096 A:middle
构建设置来构建

00:37:55.096 --> 00:37:56.416 A:middle
以便获得我们

00:37:56.416 --> 00:37:59.926 A:middle
所讨论的二进制兼容性保证

00:38:02.096 --> 00:38:04.156 A:middle
即二进制

00:38:04.156 --> 00:38:06.436 A:middle
框架不能依赖于包

00:38:07.446 --> 00:38:08.936 A:middle
让我们看一个依赖关系图

00:38:10.366 --> 00:38:11.946 A:middle
几分钟前我说过

00:38:12.276 --> 00:38:14.706 A:middle
框架的依赖关系

00:38:14.706 --> 00:38:15.746 A:middle
成为 App 的依赖关系

00:38:15.976 --> 00:38:18.326 A:middle
但是当一个 

00:38:18.326 --> 00:38:19.926 A:middle
App 构建一个包时

00:38:19.926 --> 00:38:21.586 A:middle
它必须选择一个特定的标签来执行此操作

00:38:22.416 --> 00:38:23.496 A:middle
这可能与你

00:38:23.496 --> 00:38:25.746 A:middle
构建框架的版本不匹配

00:38:26.076 --> 00:38:27.686 A:middle
它可能根本不兼容

00:38:28.596 --> 00:38:30.806 A:middle
除此之外

00:38:30.806 --> 00:38:32.666 A:middle
并非所有框架都必须

00:38:32.666 --> 00:38:34.036 A:middle
以与 Build Libraries for Distribution

00:38:34.036 --> 00:38:36.406 A:middle
兼容的模式构建

00:38:37.246 --> 00:38:39.626 A:middle
所以我们不支持这种配置

00:38:39.626 --> 00:38:42.776 A:middle
现在我想谈的最后一件事

00:38:42.776 --> 00:38:45.216 A:middle
是你们的 Objective-C 接口

00:38:45.986 --> 00:38:47.546 A:middle
是的你

00:38:47.546 --> 00:38:49.416 A:middle
Swift 框架的作者

00:38:49.416 --> 00:38:51.546 A:middle
你有一个 Objective-C 接口

00:38:51.546 --> 00:38:53.216 A:middle
很有可能因为 Xcode 的默认模板

00:38:53.216 --> 00:38:54.906 A:middle
是为一个混合源框架设置的

00:38:55.096 --> 00:38:56.346 A:middle
它有一个 

00:38:56.346 --> 00:38:58.616 A:middle
Objective-C Umbrella Header

00:38:58.616 --> 00:38:59.486 A:middle
和一个生成的 Header

00:38:59.486 --> 00:39:01.206 A:middle
位于你的框架中 Swift 包含

00:39:01.206 --> 00:39:01.926 A:middle
的 Objective-C 部分

00:39:02.566 --> 00:39:05.456 A:middle
但是如果你的 

00:39:05.456 --> 00:39:07.326 A:middle
Swift 代码没有任何它

00:39:07.566 --> 00:39:09.716 A:middle
试图发布的 Objective-C API

00:39:09.916 --> 00:39:12.116 A:middle
那么你根本不需要安装第二个 Header

00:39:12.476 --> 00:39:14.066 A:middle
这里有一个你可以直接关闭的

00:39:14.066 --> 00:39:17.156 A:middle
Install Objective-C Compatibility Header

00:39:17.156 --> 00:39:20.686 A:middle
构建设置 如果你的框架

00:39:20.686 --> 00:39:23.386 A:middle
没有提供任何 Objective-C API

00:39:23.386 --> 00:39:24.216 A:middle
那就没有理由

00:39:24.216 --> 00:39:25.866 A:middle
支持 Objective-C 导入语法

00:39:25.866 --> 00:39:27.596 A:middle
你也可以通过

00:39:27.596 --> 00:39:29.186 A:middle
Defines Module Build

00:39:29.186 --> 00:39:30.186 A:middle
设置关闭它

00:39:30.846 --> 00:39:32.666 A:middle
将其设置为 No

00:39:32.666 --> 00:39:33.976 A:middle
这将不再支持有效

00:39:33.976 --> 00:39:34.306 A:middle
的 Objective-C 代码

00:39:35.386 --> 00:39:36.856 A:middle
在你完成此操作后

00:39:36.856 --> 00:39:38.886 A:middle
你可以删除 Xcode 

00:39:38.886 --> 00:39:40.716 A:middle
为你生成的 Umbrella Header

00:39:42.376 --> 00:39:43.966 A:middle
所以让我们总结一下

00:39:44.576 --> 00:39:45.756 A:middle
我们今天谈了很多

00:39:45.756 --> 00:39:49.046 A:middle
但最重要的是 XC 框架

00:39:49.376 --> 00:39:50.516 A:middle
它们是一种新的捆绑包格式

00:39:50.516 --> 00:39:51.606 A:middle
用于以一种用户

00:39:51.606 --> 00:39:53.496 A:middle
非常容易使用的方式

00:39:53.496 --> 00:39:55.376 A:middle
分发多个框架变体

00:39:56.606 --> 00:39:57.506 A:middle
为了构建 XC 框架

00:39:57.506 --> 00:39:58.996 A:middle
你需要打开

00:39:58.996 --> 00:40:00.076 A:middle
Build Libraries for Distribution

00:40:00.076 --> 00:40:01.176 A:middle
构建设置

00:40:01.476 --> 00:40:02.656 A:middle
这将激活你获得

00:40:02.656 --> 00:40:04.896 A:middle
正确的二进制兼容

00:40:04.896 --> 00:40:05.886 A:middle
框架所需的一切

00:40:06.426 --> 00:40:08.876 A:middle
作为框架所有者

00:40:08.876 --> 00:40:11.186 A:middle
请确保你了解你对客户的责任

00:40:11.186 --> 00:40:12.676 A:middle
以便你可以

00:40:12.676 --> 00:40:14.826 A:middle
为他们提供最好的服务

00:40:14.996 --> 00:40:16.096 A:middle
Harlan 和我将在

00:40:16.096 --> 00:40:17.536 A:middle
本节会议结束后

00:40:17.536 --> 00:40:19.376 A:middle
立即进入实验室

00:40:19.376 --> 00:40:20.656 A:middle
对于所有来到这里参会的人

00:40:20.716 --> 00:40:21.506 A:middle
非常感谢你们

00:40:21.506 --> 00:40:21.966 A:middle
让我们看看这些很棒的框架

00:40:22.516 --> 00:40:25.500 A:middle
[掌声和欢呼]

