WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:07.808 --> 00:00:10.844 align:middle line:-2
（在SwiftUI中创建自定义视
图 图形效果和布局）

00:00:15.849 --> 00:00:19.920 align:middle line:-2
大家好 很高兴再次在WWDC
与你们见面

00:00:20.687 --> 00:00:25.526 align:middle line:-2
我是Dave 如果你曾看过
关于SwiftUI的其它演讲

00:00:25.592 --> 00:00:29.763 align:middle line:-2
你就知道把app的
各个部分装配起来

00:00:29.830 --> 00:00:30.931 align:middle line:-1
并让app开始运行是多么简单

00:00:31.765 --> 00:00:36.570 align:middle line:-1
今天我和John要介绍如何实现

00:00:36.637 --> 00:00:41.742 align:middle line:-2
从创建功能性app
到拥有精美布局的app

00:00:42.075 --> 00:00:45.579 align:middle line:-1
漂亮的图形和一些很酷的动画

00:00:47.915 --> 00:00:50.784 align:middle line:-2
我们会介绍SwiftUI的
两个子系统

00:00:51.752 --> 00:00:55.022 align:middle line:-2
然后John会上台来
用这两个子系统创建自定义控制

00:00:56.256 --> 00:00:57.224 align:middle line:-1
让我们开始吧

00:00:57.658 --> 00:01:03.764 align:middle line:-2
从你着手使用SwiftUI开始
你就已经在体验

00:01:03.830 --> 00:01:04.831 align:middle line:-1
布局系统了

00:01:05.265 --> 00:01:08.535 align:middle line:-2
你在预览编辑器中的文本四周
看到的那个蓝框

00:01:09.136 --> 00:01:10.571 align:middle line:-1
是它的边界

00:01:11.004 --> 00:01:13.807 align:middle line:-2
布局就是在屏幕上
规定某个东西的边界

00:01:14.975 --> 00:01:18.178 align:middle line:-1
让我们用这个例子

00:01:18.245 --> 00:01:19.279 align:middle line:-1
看一下底层发生了什么

00:01:21.582 --> 00:01:24.451 align:middle line:-1
从技术上说 这里有三个视图

00:01:25.018 --> 00:01:27.921 align:middle line:-1
分别是视图等级底部的文本

00:01:29.923 --> 00:01:34.995 align:middle line:-2
你的内容视图 它总是拥有
与它的主体文本一样的边界

00:01:35.996 --> 00:01:40.868 align:middle line:-2
最后是根视图
在这个例子中是设备的尺寸

00:01:40.934 --> 00:01:43.971 align:middle line:-1
减去安全区域尺寸

00:01:44.638 --> 00:01:47.441 align:middle line:-2
那么如果你在手机顶部
看到了这样的东西

00:01:47.841 --> 00:01:49.176 align:middle line:-1
比如它不含在内

00:01:51.144 --> 00:01:57.618 align:middle line:-2
小技巧 你仍可在那个区中安排东西
通过使用这个修饰器 好的

00:01:57.951 --> 00:02:00.120 align:middle line:-1
但默认情况下 你处于安全区

00:02:01.388 --> 00:02:07.794 align:middle line:-2
我们总是把任意带有主体的
视图的顶层叫做中性布局

00:02:08.228 --> 00:02:11.899 align:middle line:-2
因此它的边界
是由它的主体的边界定义的

00:02:11.965 --> 00:02:13.333 align:middle line:-1
对它们的操作一样

00:02:13.767 --> 00:02:16.103 align:middle line:-1
因此你真的可以为了布局目的

00:02:16.170 --> 00:02:17.871 align:middle line:-1
把它们当作同一个视图

00:02:18.572 --> 00:02:21.675 align:middle line:-1
因此这里其实只有两个视图

00:02:22.042 --> 00:02:24.478 align:middle line:-1
布局过程有三个步骤

00:02:26.346 --> 00:02:30.684 align:middle line:-1
第一步 根视图提供文本、推荐尺寸

00:02:31.185 --> 00:02:33.620 align:middle line:-1
由那两个又大又宽的箭头表示

00:02:34.288 --> 00:02:38.458 align:middle line:-2
因为它是根视图
它提供的是整个安全区的尺寸

00:02:40.427 --> 00:02:43.697 align:middle line:-2
下一步 文本回应
嗯 它对你慷慨得多

00:02:43.764 --> 00:02:46.533 align:middle line:-1
但我真的 我只能做这么大

00:02:47.134 --> 00:02:52.206 align:middle line:-2
在SwiftUI中 不能给子视图
强制规定一个尺寸

00:02:52.272 --> 00:02:54.141 align:middle line:-1
而是由父视图来决定

00:02:56.210 --> 00:03:00.447 align:middle line:-2
现在根视图说了
好了 我需要把你放在哪

00:03:00.714 --> 00:03:02.182 align:middle line:-1
那么我要把你放在中间

00:03:03.951 --> 00:03:04.952 align:middle line:-1
那么就是这样

00:03:05.485 --> 00:03:09.556 align:middle line:-2
这是个简单的例子
但每个布局交互表现方式都一样

00:03:09.623 --> 00:03:13.026 align:middle line:-1
在父视图和子视图之间

00:03:13.327 --> 00:03:15.696 align:middle line:-1
并且整个布局的行为

00:03:15.896 --> 00:03:18.599 align:middle line:-1
从这些父-子视图交互中浮现出来

00:03:20.868 --> 00:03:23.437 align:middle line:-1
但我想强调一下第二步

00:03:23.670 --> 00:03:26.473 align:middle line:-1
因为它与你所熟悉的不一样

00:03:27.007 --> 00:03:29.443 align:middle line:-1
它对你非常重要

00:03:30.611 --> 00:03:33.680 align:middle line:-1
它意味着你的视图有尺寸调整行为

00:03:35.649 --> 00:03:40.420 align:middle line:-2
因为每个视图都控制自己的尺寸
它意味着当你创建视图时

00:03:40.721 --> 00:03:43.657 align:middle line:-2
你就要决定
如何以及何时重调它的尺寸

00:03:44.391 --> 00:03:49.730 align:middle line:-2
比如 这个视图是不可修正的
50乘10点

00:03:50.063 --> 00:03:53.033 align:middle line:-1
由于它的根视图中框架尺寸是固定的

00:03:54.501 --> 00:03:59.806 align:middle line:-2
而这个是可灵活调整的视图
但高度和宽度总会一样

00:04:03.510 --> 00:04:06.880 align:middle line:-1
因此尺寸被封装到了视图定义中

00:04:08.415 --> 00:04:10.384 align:middle line:-1
我们还看到它也适用于文本

00:04:11.485 --> 00:04:16.356 align:middle line:-2
那么在SwiftUI中
文本的边界从不会超出

00:04:16.423 --> 00:04:18.257 align:middle line:-1
它所显示的行的高度和宽度

00:04:18.759 --> 00:04:21.894 align:middle line:-2
我们稍后讲堆栈时再了解
它为什么这么重要

00:04:23.530 --> 00:04:29.870 align:middle line:-2
在布局中还有最后一步
对于获得漂亮的UI来说至关重要

00:04:29.937 --> 00:04:35.175 align:middle line:-2
在SwiftUI中
你真的不用担心这个问题

00:04:35.242 --> 00:04:39.947 align:middle line:-2
因为我们会替你处理
但值得了解一下SwiftUI

00:04:40.013 --> 00:04:42.816 align:middle line:-2
把你的视图圆角化为一个
最接近的像素

00:04:43.483 --> 00:04:49.923 align:middle line:-2
你不会得到像这样锯齿形的边
而是利落的、清晰的边

00:04:50.791 --> 00:04:55.529 align:middle line:-2
这只是每个好app
需要了解的许多细节之一

00:04:56.196 --> 00:05:00.167 align:middle line:-2
但SwiftUI会替你分担
以你的方式 是的！

00:05:03.704 --> 00:05:06.773 align:middle line:-2
从而你可以重点关注
让你的app变得更特别的东西

00:05:08.041 --> 00:05:13.647 align:middle line:-2
好的 现在我们了解了基础知识
让我们看看

00:05:13.714 --> 00:05:15.415 align:middle line:-1
是否可以把它变得更好

00:05:17.150 --> 00:05:21.755 align:middle line:-2
我要把示例中的文本
修改成一些随机文本 比如

00:05:22.322 --> 00:05:25.325 align:middle line:-2
我不知道
Avocado Toast？

00:05:26.727 --> 00:05:27.728 align:middle line:-1
你们饿了吗？

00:05:28.929 --> 00:05:32.599 align:middle line:-2
不饿？好的
让我试试让它变得更诱人

00:05:33.000 --> 00:05:35.068 align:middle line:-1
我要在这里添加漂亮的绿色背景

00:05:35.936 --> 00:05:42.242 align:middle line:-2
现在这个背景修饰器在背景视图中
包裹了文本视图

00:05:42.609 --> 00:05:44.811 align:middle line:-1
颜色视图作为第二子视图

00:05:47.481 --> 00:05:51.818 align:middle line:-1
现在绿色背景精准匹配文本的边界

00:05:52.886 --> 00:05:58.425 align:middle line:-2
第二个小技巧
把背景或边界颜色扔到视图上

00:05:58.592 --> 00:06:02.329 align:middle line:-2
是个非常有用的技巧
如果你想观察视图的边界

00:06:02.563 --> 00:06:04.965 align:middle line:-1
并且没有便利的预览画布的话

00:06:06.300 --> 00:06:11.205 align:middle line:-2
好的 现在我想在绿框内的文本四周
留出更多的空间

00:06:11.271 --> 00:06:15.409 align:middle line:-1
因此我要在那插入一些内边距

00:06:17.444 --> 00:06:23.116 align:middle line:-2
现在SwiftUI选择了许多
适合我们的平台、

00:06:23.183 --> 00:06:25.319 align:middle line:-1
动态类型尺寸和环境的内边距

00:06:26.420 --> 00:06:30.290 align:middle line:-2
当你不传递任何参数时
你会得到适应性内边距

00:06:30.557 --> 00:06:36.330 align:middle line:-2
与SwiftUI适应性地调整
选择器或按钮的方式一样

00:06:36.396 --> 00:06:37.931 align:middle line:-1
取决于它所处的情境

00:06:39.233 --> 00:06:42.836 align:middle line:-2
并且如果我们只想适应性地填充
左右内边距

00:06:43.337 --> 00:06:44.705 align:middle line:-1
嗯 我们也可以实现

00:06:46.607 --> 00:06:50.444 align:middle line:-1
适应性修饰器是调整布局的最佳方式

00:06:50.711 --> 00:06:54.715 align:middle line:-2
因为你避免了把代码复杂化
避免在开发早期

00:06:54.781 --> 00:06:56.049 align:middle line:-1
在一些细节上浪费时间

00:06:56.350 --> 00:06:59.119 align:middle line:-2
并避免硬编码常量
这可能会在其它地方不合时宜

00:07:06.260 --> 00:07:10.497 align:middle line:-1
要求所有内边距都是十个点

00:07:11.732 --> 00:07:13.166 align:middle line:-1
好的 你可以明确地写出来

00:07:14.635 --> 00:07:18.739 align:middle line:-2
这个例子比Hello World
更有意思一点

00:07:19.373 --> 00:07:22.476 align:middle line:-2
让我们在这个例子中看看
布局过程是如何运作的

00:07:23.911 --> 00:07:28.882 align:middle line:-2
首先 根视图为背景视图提供了
它的整个尺寸

00:07:29.716 --> 00:07:35.189 align:middle line:-2
与吐司视图类似
背景视图是中性布局

00:07:35.722 --> 00:07:38.225 align:middle line:-1
因此它会把那个建议尺寸

00:07:38.292 --> 00:07:40.394 align:middle line:-1
传递给内边距视图

00:07:42.696 --> 00:07:48.235 align:middle line:-2
内边距视图知道它要给它子视图的
每个边都添加十个点的内边距

00:07:48.435 --> 00:07:53.240 align:middle line:-2
因此它给它的子视图文本视图
提供的要少得多

00:07:55.309 --> 00:07:59.513 align:middle line:-2
文本占据了它所需要的宽度
并把那个值返回给内边距视图

00:08:04.918 --> 00:08:08.589 align:middle line:-2
并且它把文本恰当地放到了
它的坐标空间中

00:08:11.158 --> 00:08:14.061 align:middle line:-1
现在我们说过背景视图是中性布局

00:08:14.127 --> 00:08:16.230 align:middle line:-1
因此它只需要向上报告那个尺寸即可

00:08:16.563 --> 00:08:22.936 align:middle line:-2
但在此之前 它把那个尺寸提供给
它的第二个子视图 颜色视图

00:08:24.605 --> 00:08:28.775 align:middle line:-1
颜色在布局时非常顺从

00:08:29.142 --> 00:08:31.378 align:middle line:-1
它们接受提供给它们的尺寸

00:08:31.545 --> 00:08:35.649 align:middle line:-1
因此尺寸的颜色与内边距视图的一样

00:08:36.984 --> 00:08:40.153 align:middle line:-2
最后背景视图把它的尺寸
报告给根视图

00:08:40.587 --> 00:08:44.825 align:middle line:-2
并且根视图会跟以前一样
让它居中显示

00:08:45.158 --> 00:08:46.493 align:middle line:-1
这就是整个过程

00:08:47.728 --> 00:08:49.029 align:middle line:-1
准备好看另一个例子了吗？

00:08:49.263 --> 00:08:52.299 align:middle line:-1
这个例子更简单 但它很重要

00:08:53.734 --> 00:09:00.040 align:middle line:-2
那么在这个例子中 视图的主题
只是一张固定的20乘20的图片

00:09:01.275 --> 00:09:07.281 align:middle line:-2
SwiftUI中 除非在资产目录
或代码中你把图片标记为尺寸可调

00:09:07.514 --> 00:09:09.750 align:middle line:-1
否则就是固定尺寸

00:09:10.951 --> 00:09:15.489 align:middle line:-2
现在我希望视图
整个视图变大为原来的1.5倍

00:09:15.656 --> 00:09:19.660 align:middle line:-2
让我们添加一个30乘30的
框架修饰器 就像这个一样

00:09:21.495 --> 00:09:26.700 align:middle line:-1
现在你可能注意到了

00:09:26.767 --> 00:09:30.470 align:middle line:-2
图片虽然确实很可口
它的尺寸没有发生改变

00:09:32.306 --> 00:09:34.208 align:middle line:-1
但不应该太惊讶 是吗？

00:09:34.508 --> 00:09:35.843 align:middle line:-1
我们说过它是固定尺寸

00:09:37.277 --> 00:09:40.814 align:middle line:-2
在它周围你会发现一个
30乘30的框架

00:09:41.348 --> 00:09:45.185 align:middle line:-2
那是视图主体的尺寸
因此我们定义的视图

00:09:45.252 --> 00:09:49.590 align:middle line:-2
实际上比我们之前添加的修饰器
要大50%

00:09:51.725 --> 00:09:56.330 align:middle line:-1
因此框架尺寸与图片尺寸不匹配

00:09:56.396 --> 00:09:57.497 align:middle line:-1
这是个矛盾吗？

00:09:59.132 --> 00:10:00.234 align:middle line:-1
实际上不是

00:10:00.968 --> 00:10:03.570 align:middle line:-1
这是布局系统正在做它应该做的事

00:10:04.805 --> 00:10:10.644 align:middle line:-2
认出框架不是SwiftUI中的
一个约束非常重要

00:10:11.311 --> 00:10:12.412 align:middle line:-1
它只是个视图

00:10:12.479 --> 00:10:14.982 align:middle line:-1
你可以把它看作是一个图片框架

00:10:16.450 --> 00:10:21.889 align:middle line:-2
它给它的子视图推荐固定尺寸
但和其它视图不同

00:10:21.955 --> 00:10:24.925 align:middle line:-1
子视图最终会选择自己的尺寸

00:10:26.126 --> 00:10:32.299 align:middle line:-2
从这层意义上来说 SwiftUI
布局比你熟悉的更灵活

00:10:33.567 --> 00:10:37.304 align:middle line:-2
好处是
在SwiftUI中没有欠约束的

00:10:37.371 --> 00:10:42.276 align:middle line:-2
或超出约束的系统
意味着你能表达的一切

00:10:42.342 --> 00:10:43.744 align:middle line:-1
都拥有一个定义良好的效果

00:10:45.078 --> 00:10:48.081 align:middle line:-1
那么完全没有什么不正确的布局

00:10:48.715 --> 00:10:50.317 align:middle line:-1
除非你不喜欢你所得到的结果

00:10:52.486 --> 00:10:55.455 align:middle line:-1
好的 现在我们了解了一些基础信息

00:10:56.089 --> 00:10:58.926 align:middle line:-1
让我们讨论一下强大的工具 堆栈

00:11:06.466 --> 00:11:07.668 align:middle line:-1
分别以行或列安排它们的子视图

00:11:08.635 --> 00:11:11.538 align:middle line:-2
我把这个列表网格和四个堆栈
放到一起

00:11:11.605 --> 00:11:13.106 align:middle line:-1
只需要几行代码就能实现

00:11:14.641 --> 00:11:15.943 align:middle line:-1
这是那个布局的代码

00:11:17.110 --> 00:11:22.015 align:middle line:-1
顶层是HStack有两个子视图

00:11:22.282 --> 00:11:26.253 align:middle line:-1
第一个是VStack约束星形评级

00:11:28.856 --> 00:11:34.795 align:middle line:-2
另一个子视图还是一个VStack
它的两个子视图左对齐

00:11:36.330 --> 00:11:39.299 align:middle line:-2
其中第一个子视图
又是另一个HStack

00:11:40.067 --> 00:11:46.240 align:middle line:-2
约束标题、有弹性的间隔器
和牛油果图片

00:11:48.809 --> 00:11:51.211 align:middle line:-1
好了 四个堆栈

00:11:51.879 --> 00:11:52.980 align:middle line:-1
让我们把它们重新放到一起

00:12:05.993 --> 00:12:06.994 align:middle line:-1
把堆栈的子视图都堆砌在一起

00:12:07.361 --> 00:12:12.499 align:middle line:-2
它在两个子视图之间留出了一些空间
因为适应性间隔生效了

00:12:13.800 --> 00:12:17.304 align:middle line:-2
你还会发现的邻近文本的
基线到基线的空间

00:12:17.938 --> 00:12:23.010 align:middle line:-2
与Apple的人性化界面指南
完全相匹配

00:12:24.111 --> 00:12:26.413 align:middle line:-1
而基线到边界的空间也一样

00:12:26.947 --> 00:12:30.951 align:middle line:-2
因为我们把这些规则加密到了
SwiftUI的布局系统中

00:12:32.519 --> 00:12:37.357 align:middle line:-2
这里的一般规则是最简单、
最简洁的代码

00:12:37.558 --> 00:12:41.028 align:middle line:-1
也可以产生漂亮的结果

00:12:42.462 --> 00:12:48.702 align:middle line:-2
但如果你需要控制
一如既往 SwiftUI会支持你

00:12:49.136 --> 00:12:52.272 align:middle line:-2
它有旋钮 你可以打开或关闭
以获得你想要的结果

00:12:54.708 --> 00:12:59.313 align:middle line:-2
哦 我几乎忘了
SwiftUI还替你处理另一件事

00:12:59.780 --> 00:13:04.985 align:middle line:-2
若你的app定位在一个从右到左的
书写系统中 比如阿拉伯语

00:13:05.385 --> 00:13:06.854 align:middle line:-1
并且你修改了系统语言

00:13:08.021 --> 00:13:11.091 align:middle line:-1
SwiftUI会替你调整水平坐标

00:13:11.558 --> 00:13:13.293 align:middle line:-1
因此你不需要重新编写布局

00:13:19.499 --> 00:13:24.104 align:middle line:-2
如果你一直在思考 我们为什么说
leading和trailing

00:13:24.338 --> 00:13:26.740 align:middle line:-2
而不是left和right
现在你了解了吧

00:13:27.307 --> 00:13:29.676 align:middle line:-1
这样你的布局

00:13:29.743 --> 00:13:31.044 align:middle line:-1
会自动国际化

00:13:32.713 --> 00:13:36.550 align:middle line:-1
好的 让我们具体看看堆栈布局

00:13:37.584 --> 00:13:43.323 align:middle line:-2
现在 我们目前所看到的
绝大多数视图

00:13:43.390 --> 00:13:44.391 align:middle line:-1
实际上都是子视图的直链

00:13:44.658 --> 00:13:46.326 align:middle line:-1
但堆栈很有意思

00:13:46.660 --> 00:13:50.931 align:middle line:-1
因为子视图必须平等竞争一个空间

00:13:52.165 --> 00:13:58.839 align:middle line:-2
在这个堆栈中 我们已经说过
文本不应该超过一行

00:14:07.581 --> 00:14:09.950 align:middle line:-1
嗯 文本将被缩短以适应它

00:14:11.151 --> 00:14:14.621 align:middle line:-1
但让我们从父视图

00:14:14.688 --> 00:14:16.957 align:middle line:-1
提供了足够空间的情况开始看好吗？

00:14:18.158 --> 00:14:22.529 align:middle line:-1
首先堆栈要计算出内部空间需求

00:14:23.397 --> 00:14:30.070 align:middle line:-2
并从建议宽度中提取那个信息
以便为我们提供未分配的空间的尺寸

00:14:30.404 --> 00:14:34.241 align:middle line:-2
现在我们有三个子视图
我们不知道它们的尺寸

00:14:36.210 --> 00:14:41.315 align:middle line:-1
因此我们决定把空间平均分成三等份

00:14:41.548 --> 00:14:45.986 align:middle line:-2
然后我们提议把其中一份作为
最不灵活的子视图的尺寸

00:14:47.187 --> 00:14:50.224 align:middle line:-2
现在 我们说过图片是固定尺寸
对吗？

00:14:50.591 --> 00:14:53.060 align:middle line:-1
那它就是最不灵活的那个

00:14:54.595 --> 00:15:01.401 align:middle line:-2
那么图片占据了这么多空间
是它所要求的尺寸

00:15:01.735 --> 00:15:05.205 align:middle line:-1
我们把那个尺寸从未分配空间中扣除

00:15:07.107 --> 00:15:08.108 align:middle line:-1
并重复这个过程

00:15:08.709 --> 00:15:14.147 align:middle line:-2
好的 我们现在有两个
未规定尺寸的子视图

00:15:14.214 --> 00:15:19.152 align:middle line:-2
因此我们把余下的空间分成两份
并把其中一半提供给

00:15:19.219 --> 00:15:20.921 align:middle line:-2
没有尺寸的较不灵活的子视图
即Delicious

00:15:22.489 --> 00:15:27.261 align:middle line:-2
Delicious占了这么多空间
你看到它占的空间比提供给它的少

00:15:27.694 --> 00:15:28.695 align:middle line:-1
记住这一点

00:15:30.364 --> 00:15:34.134 align:middle line:-1
把它从未分配空间中扣除

00:15:34.668 --> 00:15:39.206 align:middle line:-2
给Avocado Toast
留下了这么多空间

00:15:39.640 --> 00:15:41.008 align:middle line:-1
你可以看到 空间充足

00:15:42.576 --> 00:15:44.378 align:middle line:-1
好的 最后一步

00:15:46.380 --> 00:15:49.249 align:middle line:-1
现在所有子视图都有尺寸了

00:15:50.184 --> 00:15:53.754 align:middle line:-2
堆栈通过之前的间隔
把它们排列起来

00:15:54.922 --> 00:15:57.658 align:middle line:-1
因为代码没有指定对齐方式

00:15:58.125 --> 00:16:00.060 align:middle line:-1
默认生效的是居中对齐

00:16:00.861 --> 00:16:04.665 align:middle line:-1
因此堆栈使用居中对齐

00:16:04.731 --> 00:16:05.999 align:middle line:-1
把所有子视图垂直地居中显示

00:16:07.768 --> 00:16:13.240 align:middle line:-2
最后堆栈选择自己的尺寸
从而可以完全封装子视图

00:16:15.075 --> 00:16:18.846 align:middle line:-1
现在如果你思考一下 你可能会想

00:16:18.912 --> 00:16:22.349 align:middle line:-2
为什么文本的边界不会超出
它们所显示的宽度

00:16:23.584 --> 00:16:28.488 align:middle line:-2
请看 如果Delicious
接受了提供给它的全部空间

00:16:28.555 --> 00:16:31.859 align:middle line:-2
减少为Avocado Toast
提供的空间从而会迫使它截短图片

00:16:32.292 --> 00:16:37.097 align:middle line:-2
尽管事实是一切都要合适
有足够的空间

00:16:38.765 --> 00:16:41.201 align:middle line:-1
实际上 相对于这里的两段文本

00:16:41.602 --> 00:16:44.938 align:middle line:-2
Avocado Toast
明显更重要 对吧？

00:16:45.172 --> 00:16:46.173 align:middle line:-1
它是主题

00:16:46.907 --> 00:16:49.810 align:middle line:-2
Delicious只是个附属
它可以做出牺牲

00:16:51.979 --> 00:16:53.380 align:middle line:-1
因此这并不是个好结果

00:16:54.481 --> 00:16:59.219 align:middle line:-2
但现在我想了一下
那意味着空间的大小

00:16:59.286 --> 00:17:02.856 align:middle line:-1
所提供的空间比理想空间小

00:17:03.524 --> 00:17:08.095 align:middle line:-2
我们之前见过的截短行为很可能
也不完全是我们希望得到的

00:17:09.530 --> 00:17:11.365 align:middle line:-1
如果提供这么窄的空间

00:17:11.431 --> 00:17:13.733 align:middle line:-1
我们宁愿保留主题完整

00:17:14.101 --> 00:17:16.770 align:middle line:-1
并截短附属物

00:17:18.571 --> 00:17:20.907 align:middle line:-2
好的 为此我们有另一个
强大的工具

00:17:21.508 --> 00:17:27.146 align:middle line:-2
我们把Avocado Toast
的布局优先级从默认的零

00:17:27.580 --> 00:17:28.582 align:middle line:-1
提高到一

00:17:34.922 --> 00:17:38.225 align:middle line:-2
因此当堆栈中的子视图
有不同的布局优先级时

00:17:38.592 --> 00:17:41.228 align:middle line:-1
堆栈获取未分配的空间

00:17:41.995 --> 00:17:46.600 align:middle line:-2
它给所有优先级较低的子视图
留出最小宽度

00:17:47.067 --> 00:17:51.438 align:middle line:-2
然后把其余空间分配给
优先级最高的子视图

00:17:52.973 --> 00:17:55.676 align:middle line:-2
在这个例子中只有一个是最高优先级
就是Avocado Toast

00:17:57.878 --> 00:18:01.048 align:middle line:-1
并且会给它提供全部可用空间

00:18:01.381 --> 00:18:06.486 align:middle line:-1
扣除图片宽度

00:18:06.553 --> 00:18:09.456 align:middle line:-2
和把Delicious缩减到
最小后保留的三个点

00:18:11.091 --> 00:18:16.029 align:middle line:-2
好的 通过最高级布局优先级
调整所有子视图的尺寸后

00:18:16.096 --> 00:18:20.234 align:middle line:-1
堆栈继续给下一个

00:18:20.467 --> 00:18:23.203 align:middle line:-2
布局优先级最高的子视图
分配余下的空间 如此反复

00:18:24.671 --> 00:18:28.609 align:middle line:-2
好的 我还要给你们展示最后一个
强大的工具

00:18:30.010 --> 00:18:31.011 align:middle line:-1
对齐

00:18:31.845 --> 00:18:37.484 align:middle line:-2
现在我知道你对于我们能底边对齐
这个堆栈并不惊讶

00:18:39.987 --> 00:18:41.722 align:middle line:-1
那样看起来很不错 对吧？

00:18:42.990 --> 00:18:48.629 align:middle line:-2
但请考虑一下
当我们把Delicious的字号

00:18:48.695 --> 00:18:49.863 align:middle line:-1
改小时会怎么样

00:18:52.432 --> 00:18:55.169 align:middle line:-1
嗯 我觉得还不错 但我知道什么？

00:18:55.769 --> 00:18:57.070 align:middle line:-1
我只是个app开发人员

00:18:57.738 --> 00:19:02.242 align:middle line:-2
我很确定我的UI设计师
Crusty会觉得它是个问题

00:19:06.880 --> 00:19:08.749 align:middle line:-1
是的 他会一直放大

00:19:08.815 --> 00:19:11.185 align:middle line:-1
并开始像这样选择详细信息

00:19:12.252 --> 00:19:16.723 align:middle line:0
他会说 Bucky 首先你有
Delicious的基线 就在此

00:19:17.357 --> 00:19:20.127 align:middle line:0
然后图片的底边在下边

00:19:20.694 --> 00:19:24.831 align:middle line:0
然后Avocado Toast的
基线却在上边

00:19:25.265 --> 00:19:28.402 align:middle line:0
没有一个对齐的 我是怎么教你的？

00:19:33.607 --> 00:19:36.743 align:middle line:0
幸运的是我们可以
在SwiftUI中解决它了

00:19:37.878 --> 00:19:40.614 align:middle line:0
基于文本的排列工具始终是对齐

00:19:40.848 --> 00:19:43.617 align:middle line:0
比如上下对齐

00:19:45.552 --> 00:19:51.258 align:middle line:0
如果我们以文本的基线对齐文本
它就灵巧地解决了这个问题

00:19:57.764 --> 00:19:58.832 align:middle line:-1
那图片怎么办呢？

00:19:59.499 --> 00:20:04.671 align:middle line:-2
请看 图片中没有文本
但每个对齐都有默认值

00:20:04.938 --> 00:20:07.808 align:middle line:-1
并且最后一行文本基线的默认值

00:20:07.875 --> 00:20:12.613 align:middle line:-1
正是视图的底边 那我就得到了

00:20:12.679 --> 00:20:14.014 align:middle line:-1
Crusty要求我实现的效果

00:20:15.549 --> 00:20:22.356 align:middle line:-2
哦 哦 再看一下
我非常确定我感觉很不好

00:20:22.422 --> 00:20:26.627 align:middle line:-2
我非常确定他会告诉我说
上边有一个可见的基线

00:20:26.827 --> 00:20:29.530 align:middle line:-1
距离底部还有87.4%的距离

00:20:31.365 --> 00:20:37.971 align:middle line:-2
通过告诉SwiftUI 如何给
图片计算最后一行文本基线来实现

00:20:38.405 --> 00:20:41.775 align:middle line:-1
按照它的其它对齐方式

00:20:42.809 --> 00:20:43.810 align:middle line:-1
很酷 对吗？

00:20:48.815 --> 00:20:51.285 align:middle line:-2
但我们还没有完全利用
对齐工具的功能

00:20:52.085 --> 00:20:54.321 align:middle line:-1
让我们返回到内嵌堆栈例子中

00:20:55.756 --> 00:21:01.562 align:middle line:-2
假如我们想对齐这些星星
和标题的中心位置 就像这样

00:21:05.432 --> 00:21:11.104 align:middle line:-1
现在请记住 讨论中的文本

00:21:11.371 --> 00:21:12.573 align:middle line:-1
嵌在视图等级的两个不同的分支中

00:21:14.875 --> 00:21:19.346 align:middle line:-2
那么 嗯 居中对齐
那个顶层HStack的子视图

00:21:19.413 --> 00:21:23.951 align:middle line:-2
并不会切割它
因为它是默认的 是的

00:21:24.017 --> 00:21:25.586 align:middle line:-1
那么我们已经快搞定了

00:21:25.652 --> 00:21:27.521 align:middle line:-1
你可以看到那些子视图已经对齐了

00:21:28.222 --> 00:21:34.962 align:middle line:-2
不 我们要的对齐方式
和居中对齐不一样

00:21:35.028 --> 00:21:36.830 align:middle line:-2
标记星星的中间位置
和标题的中间位置

00:21:38.298 --> 00:21:42.903 align:middle line:-2
我们需要定义自己的对齐方式
实际上就是如此简单

00:21:43.504 --> 00:21:47.708 align:middle line:-2
只需要六行代码就能实现
我们在垂直对齐上实施一个扩展

00:21:49.610 --> 00:21:54.515 align:middle line:-1
首先我们定义遵循对齐ID的枚举

00:21:55.148 --> 00:21:56.917 align:middle line:-1
有一个要求

00:21:57.851 --> 00:22:00.921 align:middle line:-1
告诉SwiftUI如何计算默认值

00:22:03.757 --> 00:22:07.995 align:middle line:-2
现在在这个例子中
我们选了什么其实不重要

00:22:08.061 --> 00:22:11.565 align:middle line:-1
因为默认值不会超出那些内部的堆栈

00:22:12.099 --> 00:22:17.337 align:middle line:-2
但我把这个默认定义为底部
从而你可以看到

00:22:17.404 --> 00:22:23.310 align:middle line:-1
它就像定义对齐指南修饰器一样

00:22:24.011 --> 00:22:28.715 align:middle line:-1
最后我们定义垂直对齐的静态实体

00:22:29.283 --> 00:22:32.686 align:middle line:-1
把枚举类型作为它的参数

00:22:35.455 --> 00:22:38.425 align:middle line:-1
现在我们可以用它来对齐堆栈

00:22:40.093 --> 00:22:45.666 align:middle line:-2
明确地把它设定到
星星和标题的中间位置

00:22:48.769 --> 00:22:53.106 align:middle line:-1
现在我们所设置的明确的对齐值

00:22:53.173 --> 00:22:57.778 align:middle line:-2
穿过了所嵌入的堆栈的两个层
允许外部的HStack

00:22:57.845 --> 00:22:58.846 align:middle line:-1
对齐那些内部的部分

00:23:07.754 --> 00:23:12.593 align:middle line:-2
一个强大的工具
帮助你取悦最挑剔的UI设计师

00:23:13.460 --> 00:23:17.664 align:middle line:-2
现在我要邀请
John Harper上台

00:23:17.731 --> 00:23:20.467 align:middle line:-2
讲讲SwiftUI中的图形效果
John

00:23:25.806 --> 00:23:26.807 align:middle line:-1
谢谢Dave

00:23:27.274 --> 00:23:30.844 align:middle line:-2
是的 我要讲
SwiftUI的一些图形功能

00:23:30.911 --> 00:23:35.482 align:middle line:-1
以及如何使用它们在app中

00:23:35.549 --> 00:23:36.550 align:middle line:-1
创建交互性控制

00:23:38.085 --> 00:23:41.421 align:middle line:-1
这是我们想要创建的效果的示例

00:23:41.655 --> 00:23:45.826 align:middle line:-1
你之前见过 但只是几个普通的控制

00:23:45.893 --> 00:23:50.931 align:middle line:-2
然后在中间有这个大戒指的图形
四周有渐变

00:23:51.131 --> 00:23:52.366 align:middle line:-1
底部是一个条形图

00:23:52.432 --> 00:23:56.537 align:middle line:-1
如果你想在app中实现这种效果

00:23:56.603 --> 00:24:00.207 align:middle line:-2
你必须深入到图形系统内部
也许是核心动画或核心图形

00:24:02.209 --> 00:24:05.612 align:middle line:-2
我们认为在SwiftUI中
我们有一个好方法可以实现这种效果

00:24:05.679 --> 00:24:09.283 align:middle line:-1
我们先看个小例子

00:24:09.349 --> 00:24:12.286 align:middle line:-2
但在我们做任何复杂的操作之前
我们需要先了解基础知识

00:24:13.020 --> 00:24:15.756 align:middle line:-2
如果我们想绘制一个红色圆圈
我们该如何做？

00:24:16.123 --> 00:24:17.925 align:middle line:-2
嗯 我们首先要创建一个
自定义视图类型

00:24:17.991 --> 00:24:19.560 align:middle line:-1
因为我们知道所有一切都是视图

00:24:20.294 --> 00:24:23.497 align:middle line:-2
然后我们要把像这样的东西放进去
在这里我们说

00:24:23.564 --> 00:24:27.901 align:middle line:-2
如果给我一个图形和颜色
我能填充 把那两种东西填充到一起

00:24:27.968 --> 00:24:30.137 align:middle line:-1
屏幕上有一个红色的圆圈了

00:24:31.772 --> 00:24:34.441 align:middle line:-2
但这里有个非常有意思的事
就是我们没有给它提供位置尺寸

00:24:34.508 --> 00:24:38.378 align:middle line:-1
那是因为我们依赖于布局系统来实现

00:24:38.445 --> 00:24:41.682 align:middle line:-2
就是Dave讲的那些
让布局系统替我们布局我们的视图

00:24:41.748 --> 00:24:43.450 align:middle line:-1
即使我们就在这个绘图模型中

00:24:44.451 --> 00:24:51.158 align:middle line:-2
那么图形会反应给布局系统
并产生视图

00:24:51.225 --> 00:24:54.561 align:middle line:-2
事实上 现在我们的绘图核心
如果你那样认为它们的话

00:24:54.628 --> 00:24:58.198 align:middle line:-2
实际上只是视图 然后那其实意味着
SwiftUI中一切都适用于绘图

00:24:58.265 --> 00:25:01.001 align:middle line:-2
因为SwiftUI中的
一切都是视图

00:25:01.335 --> 00:25:05.506 align:middle line:-2
因此你所看到的全部修饰器
关于布局和动画、滤镜效果的修饰器

00:25:05.572 --> 00:25:09.610 align:middle line:-2
一切的一切所适用的绘图方式
都与适用于视图的绘图方式相同

00:25:10.110 --> 00:25:13.914 align:middle line:-2
但类似地 我们添加了大量的
新自定义修饰器

00:25:14.147 --> 00:25:16.750 align:middle line:-1
专用于图形绘制 比如模糊和阴影

00:25:17.551 --> 00:25:21.321 align:middle line:-2
但因为绘制的图形只是个视图
它们都适用于常规视图

00:25:21.388 --> 00:25:22.589 align:middle line:-1
以及图形视图

00:25:23.423 --> 00:25:27.394 align:middle line:-2
因此 我们认为这种统一的常规控制
比如视图和图形

00:25:27.461 --> 00:25:30.063 align:middle line:-1
会随着我们的进步变得非常强大

00:25:31.331 --> 00:25:33.700 align:middle line:-1
好的 但让我们具体看一下

00:25:34.301 --> 00:25:39.706 align:middle line:-2
基础模型是有一个形状和一个样式、
一种颜色或其它要素

00:25:39.907 --> 00:25:42.209 align:middle line:-1
其中两者的结合产生一个视图

00:25:42.943 --> 00:25:47.414 align:middle line:-2
我们在这里有一些形状
正如我们所看到的 我可以填充红色

00:25:47.481 --> 00:25:48.482 align:middle line:-1
并得到一个红色圆圈

00:25:49.416 --> 00:25:52.386 align:middle line:-2
但同时我们可以使用不同的操作
比如说不同的形状

00:25:52.452 --> 00:25:55.122 align:middle line:-1
和胶囊 比如用红色描绘

00:25:55.556 --> 00:25:57.357 align:middle line:-2
在那种情况下
我们不会得到一个填充的形状

00:25:57.424 --> 00:25:59.226 align:middle line:-1
我们填充的是形状的轮廓

00:26:04.331 --> 00:26:08.068 align:middle line:-2
稍微有些不同的描绘 因此我们还可
比如说描绘形状的边框

00:26:08.135 --> 00:26:10.237 align:middle line:-1
而不是描绘形状

00:26:10.637 --> 00:26:11.638 align:middle line:-1
这只是个变体

00:26:13.173 --> 00:26:16.009 align:middle line:-1
这也表示所有这些描绘操作

00:26:16.076 --> 00:26:19.947 align:middle line:-2
都可以要么像第一个例子一样
占据一行的宽度

00:26:20.013 --> 00:26:23.617 align:middle line:-2
要么都是标准的描绘参数 比如
你很可能在其它图形API中看到的

00:26:23.684 --> 00:26:26.887 align:middle line:-1
破折号和终止符以及线段连接符

00:26:28.522 --> 00:26:31.058 align:middle line:-2
好的 那么我们已经了解了图形
并且我们已经了解了如何填充它们

00:26:31.592 --> 00:26:33.393 align:middle line:-1
但在这一点上 我们只使用了颜色

00:26:34.127 --> 00:26:36.763 align:middle line:-2
但其实还有其它
可以用来填充图形的功能

00:26:37.264 --> 00:26:41.068 align:middle line:-2
我们可以使用拼接图片
并且我们可以使用各种渐变色

00:26:42.703 --> 00:26:43.804 align:middle line:-1
来填充图形

00:26:44.805 --> 00:26:47.107 align:middle line:-1
这是一个使用渐变色的例子

00:26:47.474 --> 00:26:51.545 align:middle line:-2
所有渐变色样式都使用了这个
基础样式

00:26:51.778 --> 00:26:54.014 align:middle line:-1
它只提供了一维的颜色梯度

00:26:54.448 --> 00:26:56.783 align:middle line:-2
在这个例子中
我们给它提供七种颜色

00:26:56.850 --> 00:26:59.052 align:middle line:-1
它将平均地把它们排列到连续线上

00:26:59.253 --> 00:27:00.721 align:middle line:-1
正好为我们提供了梯度

00:27:01.255 --> 00:27:04.258 align:middle line:-2
一旦完成 我们可以选择
其中一种渐变样式

00:27:04.324 --> 00:27:06.727 align:middle line:-1
在这个例子中 我们要使用角渐变

00:27:07.261 --> 00:27:10.564 align:middle line:-2
我们为它提供颜色梯度 然后我们
在这个例子中 使用角渐变

00:27:10.631 --> 00:27:13.300 align:middle line:-1
我们为它提供中心点以及起始角

00:27:13.734 --> 00:27:17.905 align:middle line:-1
然后它就会在那个圆圈周围填充颜色

00:27:17.971 --> 00:27:22.743 align:middle line:-1
并把它们推到无穷以提供颜色填充

00:27:23.243 --> 00:27:27.347 align:middle line:-2
但很明显 我们可使用刚做好的样式
并把它应用到圆圈中

00:27:27.714 --> 00:27:29.550 align:middle line:-2
在这个例子中 执行填充
跟我们之前见过的一样

00:27:29.616 --> 00:27:31.084 align:middle line:-1
现在我们拥有这个颜色漂亮的轮子

00:27:31.151 --> 00:27:32.519 align:middle line:-1
而不是红色圆圈

00:27:33.520 --> 00:27:37.124 align:middle line:-1
但当然了 填充只是其中一个操作

00:27:37.191 --> 00:27:39.359 align:middle line:-2
同样地 我们刚才也只提到描绘边框
并得到一个填充颜色的戒指

00:27:47.734 --> 00:27:51.638 align:middle line:-2
好的 这就是基础信息
我们已经了解了绘制单一物体

00:27:52.039 --> 00:27:54.274 align:middle line:-2
但现在我们想继续
并使用多个绘图操作

00:27:54.341 --> 00:27:56.476 align:middle line:-1
创建更复杂的东西 多个视图

00:27:57.277 --> 00:27:59.680 align:middle line:-2
这是我们要在接下来的演讲中
使用的例子

00:27:59.746 --> 00:28:02.149 align:middle line:-2
它其实是一段时期代码
你可以下载

00:28:02.349 --> 00:28:04.952 align:middle line:-1
并且它是个交互性的饼图

00:28:05.886 --> 00:28:08.822 align:middle line:-2
它由一群颜色楔形构成
你可以添加并移除它们

00:28:08.889 --> 00:28:10.824 align:middle line:-1
它们可以动态出入

00:28:12.292 --> 00:28:16.964 align:middle line:-2
好的 在我们了解如何绘制它之前
我们需要看一下数据

00:28:17.564 --> 00:28:22.569 align:middle line:-2
我们的示例app给我们提供了一个
数据模型 并且它非常简单

00:28:22.636 --> 00:28:26.106 align:middle line:-1
它只是个卡扣 代表其中一个楔形

00:28:26.740 --> 00:28:30.310 align:middle line:-2
并且每个楔形都包含代表
视图的集合图形和颜色的

00:28:30.377 --> 00:28:31.845 align:middle line:-1
一些属性

00:28:32.346 --> 00:28:35.649 align:middle line:-2
然后我们有一大堆楔形
通过ID进行追踪

00:28:35.716 --> 00:28:38.952 align:middle line:-2
最后是一组ID
从而我们知道要按哪个顺序

00:28:39.019 --> 00:28:40.020 align:middle line:-1
把它们绘制进去

00:28:40.454 --> 00:28:42.689 align:middle line:-1
现在我们可以继续并考虑如何绘制了

00:28:44.691 --> 00:28:48.228 align:middle line:-2
正如我们之前所看到的
我们真的希望它能与布局系统相交互

00:28:48.695 --> 00:28:52.699 align:middle line:-2
因此我们要假设整个整个控制
都有一个布局边界

00:28:53.700 --> 00:28:56.670 align:middle line:-2
因为我们希望它能重新调整尺寸
并按预期四处移动

00:28:57.337 --> 00:28:59.840 align:middle line:-1
如果你思考一下要如何实现

00:29:02.910 --> 00:29:05.312 align:middle line:-1
只要它们适合同一个布局边界即可

00:29:05.379 --> 00:29:09.082 align:middle line:-2
然后我们把它们组合到一起
它们就可以无缝对齐了

00:29:10.317 --> 00:29:12.486 align:middle line:-2
那其实意味着我们只需要
考虑一个就可以了

00:29:13.554 --> 00:29:16.990 align:middle line:-2
我们之前看到过这样的东西了
其实就是一些图形

00:29:17.057 --> 00:29:18.091 align:middle line:-1
填充了一些渐变色

00:29:18.892 --> 00:29:20.594 align:middle line:-1
在这个例子中 一个这样的图形

00:29:21.395 --> 00:29:25.265 align:middle line:-2
但我们其实不想要这个在
SwiftUI工具箱中嵌入的图形

00:29:25.332 --> 00:29:29.069 align:middle line:-1
但那不是问题 我们可以继续

00:29:29.136 --> 00:29:30.137 align:middle line:-1
并定义一个自定义图形

00:29:31.138 --> 00:29:34.041 align:middle line:-1
自定义图形与自定义视图很相似

00:29:34.508 --> 00:29:36.944 align:middle line:-1
是遵守协议的类型

00:29:37.411 --> 00:29:39.713 align:middle line:-2
除了 在这个例子中
我们不遵守视图协议

00:29:39.780 --> 00:29:41.248 align:middle line:-1
我们使用图形协议

00:29:42.015 --> 00:29:43.917 align:middle line:-1
形状协议有一个的要求

00:29:43.984 --> 00:29:45.886 align:middle line:-1
就是路径和矩形函数

00:29:46.386 --> 00:29:48.922 align:middle line:-1
你在这里看到的矩形是布局边界

00:29:49.323 --> 00:29:50.324 align:middle line:-1
或引用框架 我猜是这样

00:29:50.724 --> 00:29:52.426 align:middle line:-1
然后它会返回贝塞尔曲线路径

00:29:53.560 --> 00:29:57.064 align:middle line:-2
因此对于自定义图形来说
我们给它提供一个属性

00:29:57.130 --> 00:29:59.399 align:middle line:-1
即楔形描述 包含几何图形

00:30:03.003 --> 00:30:04.571 align:middle line:-2
因为我们要在它里面放东西
然后稍后再返回它

00:30:05.539 --> 00:30:10.177 align:middle line:-2
为了稍微简化这个过程
我还用了帮助

00:30:10.244 --> 00:30:14.681 align:middle line:-2
它提取了我们要绘制的图形的
一些几何图形

00:30:14.748 --> 00:30:16.016 align:middle line:-1
只是为了隐藏正弦和余弦

00:30:16.083 --> 00:30:19.386 align:middle line:-1
因为这是圆形 以及诸如此类的操作

00:30:19.720 --> 00:30:21.989 align:middle line:-1
但它定义了某些变量

00:30:22.155 --> 00:30:25.259 align:middle line:-1
我们接下来可以在这个函数中使用

00:30:26.727 --> 00:30:29.329 align:middle line:-1
首先我们要添加一个内弧形

00:30:30.264 --> 00:30:34.134 align:middle line:-2
然后在路径中添加一条线
连接内外圆形

00:30:35.035 --> 00:30:37.604 align:middle line:-1
然后另一个弧线 在外侧

00:30:38.272 --> 00:30:41.308 align:middle line:-2
最后 我们就可以告诉路径说
嘿 关闭当前子路径

00:30:41.542 --> 00:30:44.344 align:middle line:-1
那将会把终点和起点连接起来

00:30:44.745 --> 00:30:45.746 align:middle line:-1
然后我们就画好形状了

00:30:47.648 --> 00:30:49.516 align:middle line:-2
现在我们可以继续
并着手绘制这个图形了

00:30:50.017 --> 00:30:54.121 align:middle line:-2
我们可以填充渐变色
大多数情况下会这样做

00:30:54.788 --> 00:30:56.190 align:middle line:-1
但我们还有一件事要做

00:30:56.723 --> 00:30:59.626 align:middle line:-2
我们在动画中看到了
我们希望图形是动态的

00:31:02.596 --> 00:31:05.832 align:middle line:-1
SwiftUI没办法让它动起来

00:31:05.899 --> 00:31:06.900 align:middle line:-1
因为它不了解足够多的类型

00:31:07.367 --> 00:31:10.871 align:middle line:-2
因此我们可以继续并给我们的自定义
图形添加一个额外的属性

00:31:10.938 --> 00:31:12.306 align:middle line:-1
叫做可动画数据

00:31:12.673 --> 00:31:16.610 align:middle line:-1
这会提供一个矢量 包含浮点型数字

00:31:16.810 --> 00:31:19.346 align:middle line:-1
是系统可以插入的矢量

00:31:20.013 --> 00:31:23.650 align:middle line:-2
在这个例子中 我们要把这个责任
委托给数据模型

00:31:23.717 --> 00:31:26.253 align:middle line:-1
因为它替我们实施这个属性

00:31:26.320 --> 00:31:28.856 align:middle line:-1
但其实非常简单

00:31:28.922 --> 00:31:32.826 align:middle line:-1
获取三个属性和楔形描述

00:31:32.893 --> 00:31:35.495 align:middle line:-2
然后把它们结合到一个
可以进行插入的值中

00:31:37.064 --> 00:31:40.501 align:middle line:-2
好的 现在我们的图形其实已完成
我们可以把它绘制出来

00:31:41.201 --> 00:31:44.505 align:middle line:-2
我们可以退一步思考我们如何
把这些堆砌在一起做成图表

00:31:45.973 --> 00:31:49.943 align:middle line:-2
我们可以看到我们可以使用渐变色
角渐变色

00:31:50.143 --> 00:31:51.144 align:middle line:-1
用它来填充我们的图形

00:31:51.812 --> 00:31:52.813 align:middle line:-1
但这只是其中一个形状

00:31:52.880 --> 00:31:57.050 align:middle line:-2
我们想要要八个形状
并把它们组合在一起

00:31:57.284 --> 00:32:02.022 align:middle line:-2
我们可以通过一个
ZStack来实现

00:32:02.089 --> 00:32:05.359 align:middle line:-2
类似Dave讲过的HStack和
VStack 但它把东西堆砌一起

00:32:05.425 --> 00:32:07.928 align:middle line:-1
深度对应空间

00:32:08.862 --> 00:32:12.799 align:middle line:-2
我们要创建另一个自定义视图
这一次我们的视图

00:32:12.866 --> 00:32:14.201 align:middle line:-1
将通过环境获取数据模型

00:32:14.268 --> 00:32:15.602 align:middle line:-1
我们已经在其它地方设置好了

00:32:16.336 --> 00:32:17.971 align:middle line:-1
我们要从创建Zstack开始

00:32:19.106 --> 00:32:24.044 align:middle line:-2
现在我们看到在数据模型上
它提供了一组楔形ID

00:32:25.512 --> 00:32:29.483 align:middle line:-2
因此我们可以在SwiftUI中
结合ForEach视图来使用它们

00:32:29.750 --> 00:32:34.087 align:middle line:-1
那会映像到那组ID

00:32:34.321 --> 00:32:37.624 align:middle line:-2
并为每一个我们想要创建的楔形
都创建一个视图

00:32:38.292 --> 00:32:40.327 align:middle line:-1
这个楔形视图非常简单

00:32:40.394 --> 00:32:45.799 align:middle line:-2
它其实只是一个陈述视图
创建自定义图形

00:32:45.866 --> 00:32:46.867 align:middle line:-1
并填充渐变色

00:32:48.468 --> 00:32:50.370 align:middle line:-1
好的 几乎要完成了

00:32:51.104 --> 00:32:53.440 align:middle line:-2
由于SwiftUI
对依赖关系的追踪方式

00:32:53.507 --> 00:32:55.876 align:middle line:-2
当我们的数据模型更新时
视图也会更新

00:32:55.943 --> 00:32:59.179 align:middle line:-2
因为Zstack
处理插入和移除转换

00:32:59.346 --> 00:33:01.949 align:middle line:-1
它们会干净利落地淡入和淡出

00:33:02.216 --> 00:33:04.818 align:middle line:-1
这对于这样一个app来说非常好

00:33:04.885 --> 00:33:06.854 align:middle line:-1
但我们还要做一些其它的操作

00:33:07.654 --> 00:33:10.591 align:middle line:-2
我们在动画中看到了
我们希望能在你轻触楔形时

00:33:10.657 --> 00:33:11.725 align:middle line:-1
删除它

00:33:13.126 --> 00:33:14.862 align:middle line:-2
我们可以添加一个
叫做轻触操作的功能

00:33:15.095 --> 00:33:17.197 align:middle line:-1
这是视图的一个事件处理器

00:33:17.497 --> 00:33:22.035 align:middle line:-2
它表达的是如果你轻触
视图的形状的内部 就运行闭包

00:33:22.302 --> 00:33:26.406 align:middle line:-2
在那种情况下
我们要使用的闭包是启动动画

00:33:26.473 --> 00:33:29.142 align:middle line:-2
然后请求数据模型说
嘿 移除这个楔形ID

00:33:29.743 --> 00:33:31.712 align:middle line:-2
一旦我们完成
我们就可以轻触楔形了

00:33:33.013 --> 00:33:34.982 align:middle line:-1
现在我还要在这里做最后一个操作

00:33:35.182 --> 00:33:38.519 align:middle line:-1
我说过默认转换是淡入淡出效果

00:33:38.785 --> 00:33:40.954 align:middle line:-2
这对于许多东西来说都很不错
但在我们的例子中

00:33:41.021 --> 00:33:44.725 align:middle line:-2
我们想要实现更有趣的效果
我们要让楔形朝中心按比例缩小

00:33:44.791 --> 00:33:45.893 align:middle line:-1
并淡出它们

00:33:46.627 --> 00:33:49.796 align:middle line:-2
我们可以通过添加一个叫做
scaleAndFade的自定义转换实现

00:33:50.364 --> 00:33:52.466 align:middle line:-1
这是需要我们自己创建的东西

00:33:53.767 --> 00:33:56.837 align:middle line:-1
好的 思考一下这个转换是什么效果

00:33:57.337 --> 00:34:01.108 align:middle line:-2
我们希望当添加视图时
我们希望它们从缩小的比例开始

00:34:01.175 --> 00:34:05.012 align:middle line:-1
并淡出 以动画效果进入

00:34:05.412 --> 00:34:06.613 align:middle line:-1
它们将进入并放大到常规状态

00:34:07.247 --> 00:34:08.415 align:middle line:-1
然而它们位于视图等级中

00:34:08.482 --> 00:34:11.784 align:middle line:-1
它们正好会坐落在那里

00:34:11.851 --> 00:34:13.320 align:middle line:-2
最后当移除它们时
转换效果相反

00:34:14.221 --> 00:34:17.324 align:middle line:-2
如果你思考一下 很明显
我们不需要定义全部那些框架

00:34:17.391 --> 00:34:19.493 align:middle line:-1
因为我们有动画系统

00:34:20.027 --> 00:34:23.463 align:middle line:-1
因此我们只需要定义结束状态

00:34:23.530 --> 00:34:24.531 align:middle line:-1
动画系统会替我们执行其余操作

00:34:25.199 --> 00:34:29.570 align:middle line:-2
但当然了 在这个例子中
实际上有一个对称转换

00:34:29.969 --> 00:34:31.605 align:middle line:-1
因此我们实际上有两个结束状态

00:34:31.672 --> 00:34:36.109 align:middle line:-1
我们设置了转换和移除状态

00:34:36.476 --> 00:34:39.179 align:middle line:-2
并且我们有常规状态
但其实并没有发生什么

00:34:40.614 --> 00:34:43.784 align:middle line:-2
那么现在我们知道要定义哪个状态
我们可以在代码中定义它们

00:34:44.784 --> 00:34:47.688 align:middle line:-2
在SwiftUI中我们的实现方式
是通过一个叫做视图修饰器的工具

00:34:48.188 --> 00:34:50.924 align:middle line:-1
现在视图修饰器有点像视图一样

00:34:50.991 --> 00:34:53.126 align:middle line:-1
在视图修饰器中定义了一些视图等级

00:34:53.460 --> 00:34:56.362 align:middle line:-1
但它是根据一些其它视图进行定义的

00:34:56.897 --> 00:35:00.000 align:middle line:-1
这就是它所表达的东西

00:35:03.971 --> 00:35:06.840 align:middle line:-2
但在这个例子中
主体方法是另一个视图的函数

00:35:06.907 --> 00:35:08.675 align:middle line:-1
这就是内容参数

00:35:09.176 --> 00:35:13.413 align:middle line:-2
在这里我们可以做的是把这个应用到
任意其它视图中并应用一些变更

00:35:13.747 --> 00:35:16.450 align:middle line:-1
在我们的例子中我们想要转换效果

00:35:16.817 --> 00:35:20.187 align:middle line:-2
我们有两个转换状态
我们为它提供一个布尔值属性

00:35:20.254 --> 00:35:21.588 align:middle line:-1
比如转换是活跃的吗？

00:35:22.189 --> 00:35:26.960 align:middle line:-2
当转换是活跃的时
我们将应用两个现有的修饰器

00:35:27.394 --> 00:35:31.198 align:middle line:-2
来修改即将进入的视图
使其采用转换效果

00:35:31.265 --> 00:35:33.734 align:middle line:-1
我们把那叫做按比例缩小

00:35:33.800 --> 00:35:36.770 align:middle line:-1
并且当它设置妥了之后就让它淡出

00:35:38.305 --> 00:35:41.408 align:middle line:-1
好的 这就是如何定义转换

00:35:41.475 --> 00:35:43.110 align:middle line:-1
但我们还有最后一步

00:35:44.444 --> 00:35:47.714 align:middle line:-2
我们现在有视图修饰器 但我们需要
为系统提供视图修饰器的两个值

00:35:47.781 --> 00:35:51.351 align:middle line:-1
活跃值和不活跃值

00:35:51.718 --> 00:35:55.889 align:middle line:-2
从而SwiftUI可以
把它们打包到一次转换中

00:35:56.089 --> 00:35:57.591 align:middle line:-1
然后当添加或移除时

00:35:57.658 --> 00:36:01.028 align:middle line:-1
选择正确的值在正确的时间应用

00:36:01.094 --> 00:36:02.529 align:middle line:-2
然后在动画过程中
在它们之间进行插入

00:36:03.864 --> 00:36:06.033 align:middle line:-1
这就是我们可以继续并使用的东西

00:36:06.633 --> 00:36:08.836 align:middle line:-2
完成上述一切操作之后
我们现在可以看到我们创建了什么

00:36:09.036 --> 00:36:10.037 align:middle line:-1
作为一个演示

00:36:11.538 --> 00:36:17.144 align:middle line:-2
好的 你可以下载这个app
我要运行它 但愿如此 是的

00:36:17.211 --> 00:36:18.412 align:middle line:-1
那么这里是窗口

00:36:20.047 --> 00:36:22.115 align:middle line:-1
目前是空的 因为数据模型是空的

00:36:22.549 --> 00:36:23.750 align:middle line:-1
但我可以添加

00:36:24.518 --> 00:36:26.320 align:middle line:-2
你可以看到它们正在采用
我刚创建的转换

00:36:26.386 --> 00:36:28.755 align:middle line:-1
它们按比例放大并淡入

00:36:29.289 --> 00:36:33.327 align:middle line:-1
最棒的是我们可以轻触并移除它们

00:36:33.627 --> 00:36:36.797 align:middle line:-2
正如你所看到的 当我从中间移除
某个楔形时 它会进行漂亮的旋转

00:36:36.864 --> 00:36:38.999 align:middle line:-1
这是由于我们定义形状的方式

00:36:39.666 --> 00:36:41.835 align:middle line:-1
然后我可以开启这里的背景动画

00:36:42.870 --> 00:36:46.106 align:middle line:-2
然后在背景动画上运行着
物理仿真图形

00:36:46.507 --> 00:36:49.910 align:middle line:-1
它随机穿行在参数空间中

00:36:51.411 --> 00:36:52.880 align:middle line:-1
这是个很好的小app

00:36:53.213 --> 00:36:55.616 align:middle line:-2
即使它是动态的
但很明显它仍然是交互式的

00:36:55.682 --> 00:36:58.619 align:middle line:-1
测试是正确地运行

00:36:59.219 --> 00:37:03.457 align:middle line:-2
有意思的是当你思考
我们是如何渲染这个时

00:37:03.991 --> 00:37:07.528 align:middle line:-2
SwiftUI会为出现在屏幕上的
每一个元素

00:37:07.594 --> 00:37:11.298 align:middle line:-2
都创建一个原生的平台视图
比如UI指示器NSView

00:37:11.832 --> 00:37:13.901 align:middle line:-1
因此这与按钮类似

00:37:14.401 --> 00:37:18.005 align:middle line:-2
一般来说 这就是我们想要的效果
因为我们大部分时候是

00:37:18.071 --> 00:37:20.040 align:middle line:-1
处理常规控件之类的东西

00:37:20.908 --> 00:37:25.045 align:middle line:-2
但对于诸如所显示的这个图形
一样的东西

00:37:25.546 --> 00:37:29.216 align:middle line:-2
如果你在UIKit或
AppKit中绘制了它

00:37:29.283 --> 00:37:32.052 align:middle line:-2
这很可能不是你会做的事
你很可能不会

00:37:32.119 --> 00:37:34.321 align:middle line:-2
为每一个元素都创建
一个NSView

00:37:34.621 --> 00:37:36.890 align:middle line:-2
原因是
一旦你开始创建那么多NSView

00:37:37.491 --> 00:37:39.293 align:middle line:-1
性能可能会很差

00:37:39.359 --> 00:37:40.827 align:middle line:-1
这并不是个问题

00:37:40.894 --> 00:37:43.230 align:middle line:-2
因为我们并不打算
这么用NSView

00:37:44.198 --> 00:37:46.466 align:middle line:-1
我们在SwiftUI中有个方案

00:37:47.167 --> 00:37:50.871 align:middle line:-2
就是我们可以把一切
都放到这里的ZStack中

00:37:51.905 --> 00:37:53.473 align:middle line:-1
放在一个绘制小组内

00:37:54.341 --> 00:37:56.543 align:middle line:-1
绘制小组是一种特殊的渲染方式

00:37:56.877 --> 00:37:58.312 align:middle line:-1
仅适用于诸如图形这样的元素

00:37:58.545 --> 00:38:00.814 align:middle line:-1
那么图形和文本和图片 类似这样的

00:38:01.348 --> 00:38:04.985 align:middle line:-2
当我们这么做之后 我们实际上
会把所有SwiftUI视图

00:38:05.052 --> 00:38:09.056 align:middle line:-2
扁平化到NSViewer UI视图中
并用Metal对它们进行渲染

00:38:09.523 --> 00:38:12.125 align:middle line:-2
因此当我开始这样做时
你可以看到它的动作完全相同

00:38:12.192 --> 00:38:14.695 align:middle line:-1
因为它不是行为上的变化

00:38:15.329 --> 00:38:18.732 align:middle line:-2
但一旦我开始增加元素的数量时
你们可以看到

00:38:18.799 --> 00:38:20.300 align:middle line:-1
性能变得更好了 因为…

00:38:28.208 --> 00:38:32.846 align:middle line:-2
这仅仅是因为只有一个视图
就是视图系统想要的视图

00:38:33.046 --> 00:38:39.219 align:middle line:-2
但所发生的绘制
仅适用了一次硬件加速

00:38:40.821 --> 00:38:43.357 align:middle line:-1
那么我想这就是全部内容了 很酷

00:38:55.636 --> 00:38:59.506 align:middle line:-2
好的 在本场演讲中
我们了解了一些图形修饰器

00:38:59.573 --> 00:39:02.543 align:middle line:-1
但我想指出其实还有更多修饰器

00:39:02.910 --> 00:39:06.113 align:middle line:-1
我们做了很多工作来实施

00:39:06.180 --> 00:39:07.681 align:middle line:-2
你能在常规的2D绘图系统中
所能找到的一切

00:39:08.048 --> 00:39:10.484 align:middle line:-1
正如我们所说的 它们都适用于视图

00:39:10.751 --> 00:39:14.354 align:middle line:-2
因此如果这个 如果你需要
本场演讲中的某些信息 请查看文档

00:39:15.989 --> 00:39:20.027 align:middle line:-2
我认为这真的清晰地讲明了
我们所创建的模型的功能

00:39:20.093 --> 00:39:26.166 align:middle line:-1
并且我们想使用这些图形

00:39:26.233 --> 00:39:28.902 align:middle line:-1
但是要与其余的API一起使用

00:39:28.969 --> 00:39:32.005 align:middle line:-1
比如布局、动画和交互

00:39:32.072 --> 00:39:35.776 align:middle line:-2
SwiftUI的主旨就是我们围绕
一个视图协议统一了全部区域

00:39:35.843 --> 00:39:40.147 align:middle line:-1
在同样的程序包中我你提供一切功能

00:39:40.981 --> 00:39:44.651 align:middle line:-2
我们认为这将非常强大
我们真的已经迫不及待地看到

00:39:44.718 --> 00:39:46.053 align:middle line:-1
你们即将把它带到哪里去

00:39:46.386 --> 00:39:47.387 align:middle line:-1
谢谢大家

00:39:54.628 --> 00:39:55.929 align:middle line:-1
我们今天还有一场演讲

00:39:55.996 --> 00:39:59.800 align:middle line:-2
距离开始不到一小时了
因此如果你有任何疑问

00:39:59.867 --> 00:40:02.135 align:middle line:-1
请参加我们的演讲 谢谢

