WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:00.506 --> 00:00:04.516 A:middle
[音乐]

00:00:05.516 --> 00:00:07.546 A:middle
[掌声]

00:00:08.045 --> 00:00:10.456 A:middle
&gt;&gt; 大家好 欢迎大家来到 

00:00:10.456 --> 00:00:11.786 A:middle
《Advances in Networking》的第二部分

00:00:12.356 --> 00:00:13.686 A:middle
如果你没有来听第一部分

00:00:13.686 --> 00:00:17.046 A:middle
应该很快就能在 App 和网页上看到视频

00:00:18.486 --> 00:00:20.456 A:middle
我叫 Eric Kinnear 来自网络技术部

00:00:20.706 --> 00:00:21.866 A:middle
一会将加入讲演的是

00:00:21.866 --> 00:00:23.506 A:middle
我的同事 Tommy 和 Stuart

00:00:23.986 --> 00:00:26.746 A:middle
我们会介绍很多东西

00:00:27.226 --> 00:00:28.336 A:middle
首先 我们会介绍 

00:00:28.336 --> 00:00:31.466 A:middle
如何更加充分地利用 Bonjour 搜索

00:00:32.235 --> 00:00:35.236 A:middle
我们会介绍 如何通过搭建框架协议

00:00:35.236 --> 00:00:37.726 A:middle
高效简便得传递消息

00:00:38.406 --> 00:00:39.556 A:middle
我们会看一些新的 

00:00:39.726 --> 00:00:41.126 A:middle
升级的指标收集

00:00:41.356 --> 00:00:42.746 A:middle
最后我们会介绍一些

00:00:42.746 --> 00:00:44.286 A:middle
状态更新和一些操作

00:00:44.286 --> 00:00:47.986 A:middle
让你的 App 实现最佳联网性能

00:00:49.476 --> 00:00:51.246 A:middle
开始之前 我要提醒大家

00:00:52.646 --> 00:00:54.506 A:middle
如果你在用 URLSession

00:00:54.506 --> 00:00:55.876 A:middle
和 Network.framework

00:00:55.876 --> 00:00:56.786 A:middle
你可以充分利用

00:00:56.876 --> 00:00:58.166 A:middle
我们今天讲的一切东西

00:00:59.116 --> 00:01:00.826 A:middle
如果你还没有用

00:01:00.826 --> 00:01:02.146 A:middle
这就是为什么

00:01:02.146 --> 00:01:05.525 A:middle
你应该改用更现代的网络 API

00:01:05.786 --> 00:01:09.876 A:middle
我们直接从 Bonjour 搜索开始

00:01:09.986 --> 00:01:11.666 A:middle
Bonjour 能在网络上

00:01:11.666 --> 00:01:13.256 A:middle
发布和发现服务

00:01:13.656 --> 00:01:15.666 A:middle
每当你用隔空打印  

00:01:15.666 --> 00:01:17.886 A:middle
连接隔空播放设备

00:01:17.886 --> 00:01:19.906 A:middle
用 HomeKit 让你的家自动化时

00:01:19.906 --> 00:01:21.356 A:middle
你都需要 Bonjour

00:01:21.776 --> 00:01:23.356 A:middle
每次你在连接时

00:01:23.356 --> 00:01:24.726 A:middle
却无需输入 IP 地址或主机名时

00:01:24.726 --> 00:01:26.946 A:middle
你都在用 Bonjour

00:01:27.766 --> 00:01:29.306 A:middle
如你所知 Bonjour 

00:01:29.306 --> 00:01:30.976 A:middle
在所有的 Apple 平台上都可用

00:01:31.546 --> 00:01:36.226 A:middle
它在 Linux Android Chrome OS 上同样可用

00:01:36.226 --> 00:01:37.566 A:middle
Chromecast 就是用它发现设备的

00:01:38.486 --> 00:01:39.886 A:middle
你可能不知道 

00:01:39.886 --> 00:01:41.476 A:middle
早在 2015 年

00:01:41.476 --> 00:01:43.346 A:middle
微软也悄悄将 Bonjour 支持

00:01:43.346 --> 00:01:44.426 A:middle
添加到 Windows 10

00:01:45.316 --> 00:01:47.216 A:middle
从那时起 Bonjour 的实施就已经成熟

00:01:48.066 --> 00:01:49.416 A:middle
这就意味着 Bonjour 

00:01:49.416 --> 00:01:51.456 A:middle
现在在各大主平台均可用

00:01:53.876 --> 00:01:55.866 A:middle
今天 我们将分享一些

00:01:55.866 --> 00:01:57.196 A:middle
这个领域的最新进展

00:01:57.706 --> 00:01:59.416 A:middle
有时 你在一个网络

00:02:03.606 --> 00:02:04.996 A:middle
比如说你有一台设备 

00:02:04.996 --> 00:02:06.226 A:middle
想要连接到

00:02:06.726 --> 00:02:08.286 A:middle
另一个网络上的打印机

00:02:08.286 --> 00:02:09.356 A:middle
二者之间有多个跳跃

00:02:10.196 --> 00:02:11.616 A:middle
现在 如果你在局域网上

00:02:11.616 --> 00:02:13.286 A:middle
发送多点传送数据包

00:02:13.286 --> 00:02:15.436 A:middle
你不会得到任何回应

00:02:16.606 --> 00:02:18.386 A:middle
Discovery Proxy 解决这个问题

00:02:19.356 --> 00:02:22.486 A:middle
现在你可以发送单点传送数据包到 Discovery Proxy

00:02:22.956 --> 00:02:24.176 A:middle
它会把多点传送数据包

00:02:24.176 --> 00:02:27.556 A:middle
发送到目标子网络接收响应

00:02:27.556 --> 00:02:28.806 A:middle
将结果代理给你

00:02:29.636 --> 00:02:30.956 A:middle
现在你就可以直接连接到打印机

00:02:30.956 --> 00:02:32.736 A:middle
看 我们已经

00:02:32.736 --> 00:02:34.976 A:middle
收到了文件

00:02:35.516 --> 00:02:37.946 A:middle
[掌声]

00:02:38.446 --> 00:02:39.756 A:middle
我们很高兴地宣布

00:02:39.756 --> 00:02:42.776 A:middle
客户端上这个的代码 

00:02:42.776 --> 00:02:44.846 A:middle
已经在你的开发者版本里了

00:02:44.846 --> 00:02:47.846 A:middle
服务器实施和操作指南

00:02:48.106 --> 00:02:49.176 A:middle
都可以在 GitHub 上找到

00:02:49.786 --> 00:02:52.596 A:middle
我们来看一下

00:02:52.596 --> 00:02:53.346 A:middle
这对你的 App 来说意味什么

00:02:54.686 --> 00:02:55.956 A:middle
之前比较推荐的做法是 

00:02:55.956 --> 00:02:57.436 A:middle
当你搜索时

00:02:57.436 --> 00:02:59.416 A:middle
你需要将域设置为 nil

00:03:01.236 --> 00:03:02.836 A:middle
对于几乎每一种情况

00:03:02.836 --> 00:03:03.986 A:middle
这种做法都是正确的

00:03:05.096 --> 00:03:06.156 A:middle
以前你不觉得

00:03:06.156 --> 00:03:07.596 A:middle
有多大的不同

00:03:07.596 --> 00:03:08.546 A:middle
但是现在它开始有更大的影响

00:03:08.546 --> 00:03:13.716 A:middle
指定本地会直接阻止发现

00:03:13.806 --> 00:03:15.896 A:middle
任何远程或者代理服务

00:03:16.716 --> 00:03:18.316 A:middle
这也许不是你想要的结果

00:03:18.316 --> 00:03:19.856 A:middle
所以要好好检查

00:03:19.856 --> 00:03:21.226 A:middle
你的搜索调用是不是无意间

00:03:21.226 --> 00:03:22.136 A:middle
指定了一个域

00:03:23.546 --> 00:03:25.316 A:middle
当你创建 App 搜索服务时

00:03:25.746 --> 00:03:26.616 A:middle
让我们来看一下

00:03:26.616 --> 00:03:27.486 A:middle
Network.framework 的

00:03:27.486 --> 00:03:29.366 A:middle
一些新功能

00:03:29.486 --> 00:03:31.346 A:middle
它们使得 Bonjour 搜索更加简便

00:03:31.596 --> 00:03:32.696 A:middle
尤其是在 Swift 里

00:03:34.226 --> 00:03:35.536 A:middle
去年我们介绍了

00:03:35.536 --> 00:03:37.276 A:middle
NWListener 和 NWConnection

00:03:37.516 --> 00:03:38.586 A:middle
以及 Network.framework

00:03:39.286 --> 00:03:40.876 A:middle
比如 你可以让

00:03:40.876 --> 00:03:42.646 A:middle
NWListener 发布一个 Bonjour 服务

00:03:42.646 --> 00:03:45.886 A:middle
你可以让 NWConnection 连接到

00:03:45.886 --> 00:03:46.996 A:middle
Bonjour 服务端点

00:03:47.986 --> 00:03:49.056 A:middle
但是如果想要

00:03:49.056 --> 00:03:50.666 A:middle
发现可用服务

00:03:50.666 --> 00:03:52.366 A:middle
你就需要其他 Bonjour 搜索 API

00:03:53.006 --> 00:03:54.426 A:middle
一旦发现了一个

00:03:54.426 --> 00:03:55.616 A:middle
你就需要做很多工作

00:03:55.616 --> 00:03:56.696 A:middle
将它转换为

00:03:56.696 --> 00:03:57.786 A:middle
一个可用于连接的端点

00:03:59.046 --> 00:04:00.596 A:middle
今天 我们宣布

00:04:00.596 --> 00:04:02.246 A:middle
通过 NWBrowser 对象

00:04:02.466 --> 00:04:03.526 A:middle
Network.framework 

00:04:03.526 --> 00:04:04.826 A:middle
自带搜索支持

00:04:06.016 --> 00:04:07.786 A:middle
NWBrowser 可以连接

00:04:07.786 --> 00:04:09.416 A:middle
并监听其他服务   

00:04:09.416 --> 00:04:11.536 A:middle
覆盖整个工作流

00:04:11.536 --> 00:04:13.866 A:middle
从发布 到发现 再到连接

00:04:13.866 --> 00:04:14.876 A:middle
用的都是大家早已熟悉的

00:04:14.906 --> 00:04:15.966 A:middle
Network.framework 对象 

00:04:19.156 --> 00:04:20.916 A:middle
浏览器在 Network.framework 中   

00:04:20.916 --> 00:04:22.616 A:middle
用现代基于调度的 API

00:04:23.276 --> 00:04:25.386 A:middle
提供发现服务的功能

00:04:25.386 --> 00:04:27.176 A:middle
这个 API 已经优化 

00:04:27.176 --> 00:04:28.686 A:middle
特别适合 Swift

00:04:29.486 --> 00:04:30.796 A:middle
它还包括可选择的

00:04:30.796 --> 00:04:32.596 A:middle
TXT 记录支持

00:04:33.426 --> 00:04:34.816 A:middle
如果你的 App 需要

00:04:34.996 --> 00:04:37.936 A:middle
你可以为每个发现的端点 

00:04:37.936 --> 00:04:38.736 A:middle
请求 TXT 记录

00:04:39.226 --> 00:04:42.846 A:middle
让我们看一下如何使用 browser

00:04:43.866 --> 00:04:45.596 A:middle
我们可以用你想发现的 Bonjour 服务类

00:04:45.596 --> 00:04:46.946 A:middle
和一些 NWParameters 

00:04:46.946 --> 00:04:48.696 A:middle
将它初始化

00:04:48.696 --> 00:04:50.026 A:middle
你可以通过 NWParameters 告诉它

00:04:50.026 --> 00:04:51.016 A:middle
你想如何搜索

00:04:51.016 --> 00:04:52.426 A:middle
和你处理其他所有的 

00:04:52.426 --> 00:04:53.896 A:middle
Network.framework 对象一样

00:04:54.506 --> 00:04:55.596 A:middle
接着 你可以创建一个

00:04:55.596 --> 00:04:56.916 A:middle
browseResultsChangedHandler

00:04:57.876 --> 00:05:00.806 A:middle
它可以被调用传输已发现的

00:05:00.806 --> 00:05:01.546 A:middle
所有可用端点的列表

00:05:02.306 --> 00:05:03.856 A:middle
最后 就像其他

00:05:03.856 --> 00:05:05.206 A:middle
Network.framework 对象一样

00:05:05.206 --> 00:05:07.866 A:middle
你可以在想要接收回调的队列上

00:05:07.866 --> 00:05:08.956 A:middle
创建你的 browser

00:05:09.486 --> 00:05:11.906 A:middle
我们仔细来看一下

00:05:11.906 --> 00:05:13.026 A:middle
browseResultsChangedHandler

00:05:13.946 --> 00:05:14.846 A:middle
你有两个选择

00:05:15.176 --> 00:05:17.026 A:middle
其一 你可以

00:05:17.366 --> 00:05:18.846 A:middle
用一个句柄

00:05:18.846 --> 00:05:19.966 A:middle
接收更新里

00:05:19.966 --> 00:05:20.786 A:middle
所有变化的详单

00:05:21.436 --> 00:05:23.206 A:middle
这与低级 API   

00:05:23.206 --> 00:05:24.546 A:middle
非常一致

00:05:24.546 --> 00:05:26.066 A:middle
你可以清楚地看到

00:05:26.276 --> 00:05:27.496 A:middle
所有的变化

00:05:28.056 --> 00:05:29.696 A:middle
端点可以被添加或移除 

00:05:29.696 --> 00:05:31.686 A:middle
而且还可以

00:05:31.686 --> 00:05:32.886 A:middle
改变它们的内部细节

00:05:33.716 --> 00:05:35.546 A:middle
这些变化通过 Flag 声明

00:05:36.436 --> 00:05:38.076 A:middle
在这种情况下  

00:05:38.076 --> 00:05:39.696 A:middle
随着端点在其他接口上被发现

00:05:39.696 --> 00:05:42.586 A:middle
我们会查看接口是否被添加或移除

00:05:43.136 --> 00:05:45.996 A:middle
你也可以选择

00:05:45.996 --> 00:05:49.916 A:middle
只用句柄查看最新的

00:05:49.956 --> 00:05:50.596 A:middle
发现结果列表

00:05:51.476 --> 00:05:52.786 A:middle
这么做要小心

00:05:52.986 --> 00:05:53.916 A:middle
因为随着可用端点列表改变

00:05:53.916 --> 00:05:57.076 A:middle
这个句柄会重复被调用

00:05:57.676 --> 00:05:58.516 A:middle
所以确保 你更新

00:05:58.516 --> 00:06:01.246 A:middle
App 的状态和其他东西的方式是恰当的

00:06:05.096 --> 00:06:06.566 A:middle
我们来看一个

00:06:06.566 --> 00:06:07.576 A:middle
正在运行的 NWBrowser 的例子

00:06:08.476 --> 00:06:09.976 A:middle
我们准备做一个 App 

00:06:09.976 --> 00:06:12.126 A:middle
可以在两个设备之间

00:06:12.126 --> 00:06:14.246 A:middle
发现服务和安全连接的 App

00:06:15.206 --> 00:06:16.236 A:middle
在我们的例子中 

00:06:16.236 --> 00:06:17.426 A:middle
我将做一个井字游戏

00:06:17.856 --> 00:06:19.846 A:middle
你也可以做其他很多东西

00:06:21.136 --> 00:06:22.516 A:middle
我们会用 NWListener

00:06:22.516 --> 00:06:23.666 A:middle
把游戏发布给周围玩家

00:06:23.666 --> 00:06:26.866 A:middle
我们会用 NWBrowser 

00:06:26.866 --> 00:06:28.746 A:middle
搜索附近可用游戏

00:06:29.036 --> 00:06:30.346 A:middle
一旦用户选择一个

00:06:30.346 --> 00:06:31.416 A:middle
他们想加入的游戏

00:06:31.416 --> 00:06:32.856 A:middle
我们就会取其中一个搜索结果 

00:06:32.856 --> 00:06:34.486 A:middle
传送给 NWConnection

00:06:34.486 --> 00:06:36.946 A:middle
回连到我们的监听器

00:06:36.946 --> 00:06:39.976 A:middle
在 Xcode 中看一下

00:06:47.416 --> 00:06:49.376 A:middle
App 已经在这儿了

00:06:49.376 --> 00:06:50.476 A:middle
我们已经写了一些代码

00:06:50.516 --> 00:06:52.716 A:middle
去处理不同的视图

00:06:52.716 --> 00:06:54.706 A:middle
为用户展示

00:06:54.706 --> 00:06:56.006 A:middle
一系列可玩的游戏

00:06:56.006 --> 00:06:58.366 A:middle
让他们创建游戏 诸如此类

00:06:58.626 --> 00:07:00.286 A:middle
所以这里就只关注浏览器本身

00:07:00.856 --> 00:07:02.816 A:middle
我已经有了一个类 PeerBrowser

00:07:02.886 --> 00:07:04.656 A:middle
我会用这个类

00:07:04.656 --> 00:07:06.676 A:middle
管理我的 NWBrowser 

00:07:06.676 --> 00:07:08.006 A:middle
并且提供一个 PeerBrowserDelegate

00:07:08.006 --> 00:07:09.716 A:middle
它也会传送发现端点的列表 

00:07:09.716 --> 00:07:11.406 A:middle
这样 UI 就可以

00:07:11.406 --> 00:07:12.846 A:middle
将它们展现给用户

00:07:14.536 --> 00:07:15.936 A:middle
首先 我要把我的 NWBrowser 

00:07:15.936 --> 00:07:17.656 A:middle
作为一个实例属性

00:07:17.656 --> 00:07:18.806 A:middle
添加到 PeerBrowser 上 

00:07:21.216 --> 00:07:24.706 A:middle
然后 当 PeerBrowser 被初始化时

00:07:24.706 --> 00:07:26.166 A:middle
它会立即调用 startBrowsing

00:07:27.126 --> 00:07:28.666 A:middle
我们要把这个填上

00:07:29.916 --> 00:07:31.846 A:middle
首先 我要创建

00:07:31.846 --> 00:07:33.576 A:middle
一些 NWParameters

00:07:33.576 --> 00:07:36.206 A:middle
它们和其他 Network.framework 对象一样 

00:07:36.206 --> 00:07:38.126 A:middle
用来描述你想如何与网络互动

00:07:38.716 --> 00:07:39.636 A:middle
在我们的例子里

00:07:39.636 --> 00:07:41.146 A:middle
默认 parameter 就可以

00:07:41.376 --> 00:07:43.046 A:middle
但是要设置 includePeerToPeer 为真

00:07:43.046 --> 00:07:45.276 A:middle
这样 即使设备

00:07:45.276 --> 00:07:46.926 A:middle
不在同一个网络上

00:07:46.926 --> 00:07:49.066 A:middle
我们也能发现其他可玩的游戏

00:07:52.576 --> 00:07:55.006 A:middle
接着 我们创建 NWBrowser

00:07:56.236 --> 00:07:58.076 A:middle
搜索服务类型 

00:07:58.126 --> 00:07:59.216 A:middle
_tictactoe._tcp

00:07:59.216 --> 00:08:01.356 A:middle
我们要确保 

00:08:01.356 --> 00:08:02.286 A:middle
将域设置为 nil

00:08:03.616 --> 00:08:04.856 A:middle
用之前创建的 parameters 

00:08:04.856 --> 00:08:07.296 A:middle
将其存入 PeerBrowser

00:08:07.806 --> 00:08:10.066 A:middle
接下来 我们设置一个

00:08:10.066 --> 00:08:11.876 A:middle
stateUpdateHandler 

00:08:11.876 --> 00:08:12.826 A:middle
就像我们处理

00:08:12.826 --> 00:08:14.756 A:middle
其他 Network.framework 对象一样   

00:08:14.756 --> 00:08:15.966 A:middle
用来接收浏览器状态的更新

00:08:15.966 --> 00:08:17.366 A:middle
有无错误 运行状况如何

00:08:17.366 --> 00:08:18.866 A:middle
诸如此类

00:08:20.936 --> 00:08:23.166 A:middle
然后我们设置 browseResultsChangedHandler

00:08:24.226 --> 00:08:28.216 A:middle
非常简单 我们将结果列表传送给代理

00:08:28.216 --> 00:08:29.776 A:middle
让它呈现在 UI 中

00:08:29.776 --> 00:08:30.806 A:middle
确保代理是这样编码的

00:08:30.806 --> 00:08:32.826 A:middle
这样 每当发生变化时

00:08:32.826 --> 00:08:34.275 A:middle
它就会刷新 UI 

00:08:34.275 --> 00:08:35.275 A:middle
所以我们可以一直呈现

00:08:35.275 --> 00:08:37.736 A:middle
发现端点的最新列表

00:08:41.556 --> 00:08:44.996 A:middle
最后 在主队列启动浏览器

00:08:44.996 --> 00:08:46.276 A:middle
因为想在主队列接收更新

00:08:46.786 --> 00:08:49.696 A:middle
就是这样

00:08:50.236 --> 00:08:51.726 A:middle
通过这样一组代码

00:08:51.726 --> 00:08:53.546 A:middle
我们可以搭建一个 NWBrowser

00:08:53.546 --> 00:08:54.996 A:middle
让它通过 P2P 连接

00:08:55.256 --> 00:08:56.376 A:middle
发现附近的游戏

00:08:56.376 --> 00:08:58.076 A:middle
并为用户展示

00:08:58.076 --> 00:08:59.626 A:middle
一系列可玩的游戏

00:08:59.626 --> 00:09:00.856 A:middle
让用户自己选择连接哪个

00:09:00.856 --> 00:09:05.466 A:middle
一会我们再介绍

00:09:05.466 --> 00:09:07.796 A:middle
监听器和连接这些代码

00:09:07.796 --> 00:09:08.846 A:middle
这个例子的代码

00:09:08.846 --> 00:09:10.376 A:middle
可以从网站下载

00:09:10.376 --> 00:09:12.266 A:middle
在我们继续之前

00:09:12.266 --> 00:09:13.846 A:middle
我想先说一件事 

00:09:14.786 --> 00:09:16.966 A:middle
我们已经有了 NWParameters 

00:09:16.966 --> 00:09:18.926 A:middle
可以用在监听器和连接上

00:09:19.506 --> 00:09:20.536 A:middle
刚才我提到

00:09:20.536 --> 00:09:21.806 A:middle
我们想确保

00:09:21.806 --> 00:09:23.416 A:middle
设备间的连接是安全的

00:09:23.416 --> 00:09:24.866 A:middle
没有人能看到

00:09:24.866 --> 00:09:26.066 A:middle
我们在做什么

00:09:26.246 --> 00:09:28.296 A:middle
更没有人能干扰我们的操作

00:09:29.586 --> 00:09:30.676 A:middle
要实现这个目标

00:09:30.676 --> 00:09:31.736 A:middle
我们要为 NWParameters 

00:09:31.736 --> 00:09:34.526 A:middle
定义一个扩展

00:09:34.526 --> 00:09:35.666 A:middle
并创建一个便利构造函数

00:09:36.976 --> 00:09:38.386 A:middle
它将密码设为字符串

00:09:39.396 --> 00:09:42.836 A:middle
我们会给游戏的创建人 一个密码

00:09:42.896 --> 00:09:45.146 A:middle
让其他想加入游戏的人输入密码

00:09:45.146 --> 00:09:46.976 A:middle
这样就生成了一个

00:09:46.976 --> 00:09:48.436 A:middle
预共享密码

00:09:48.436 --> 00:09:50.346 A:middle
用 TLS 确保连接安全

00:09:50.346 --> 00:09:53.556 A:middle
要实现这个  

00:09:53.556 --> 00:09:55.956 A:middle
我们需要在构造函数中 

00:09:56.336 --> 00:09:57.236 A:middle
创建 TCP 和 TLS 选项

00:09:57.966 --> 00:09:59.666 A:middle
从 TLS 开始

00:10:03.046 --> 00:10:04.266 A:middle
它创建了 TLS 选项

00:10:04.476 --> 00:10:06.126 A:middle
密码做好了

00:10:06.126 --> 00:10:07.076 A:middle
现在我们只是

00:10:07.076 --> 00:10:08.226 A:middle
默认 TLS 选项

00:10:09.656 --> 00:10:11.786 A:middle
接下来 我们用新的 CryptoKit 框架

00:10:11.786 --> 00:10:12.976 A:middle
这个框架今年刚出的

00:10:12.976 --> 00:10:14.586 A:middle
从那个密码中 

00:10:14.586 --> 00:10:20.656 A:middle
生成一个验证密钥和验证码

00:10:20.776 --> 00:10:22.326 A:middle
把那个预共享密码

00:10:22.326 --> 00:10:24.066 A:middle
添加到设置协议选项

00:10:24.266 --> 00:10:25.556 A:middle
还要确保添加一个

00:10:25.556 --> 00:10:27.186 A:middle
TLS 密钥算法套件 

00:10:27.186 --> 00:10:28.236 A:middle
用来支持预共享密码

00:10:28.816 --> 00:10:31.716 A:middle
现在可以回到 TLS 选项

00:10:32.266 --> 00:10:35.836 A:middle
在这儿我们可以做 TCP 选项

00:10:38.456 --> 00:10:40.146 A:middle
大部分情况下

00:10:40.146 --> 00:10:41.276 A:middle
我们会用默认 TCP 选项

00:10:41.276 --> 00:10:41.966 A:middle
但是也要保证 enableKeepalive 为真

00:10:43.186 --> 00:10:45.026 A:middle
接着我们用 

00:10:45.026 --> 00:10:46.276 A:middle
刚才在下面创建的 TLS 选项

00:10:46.276 --> 00:10:47.966 A:middle
和基本上是默认的 TCP 选项

00:10:47.966 --> 00:10:51.396 A:middle
初始化 NWParameters

00:10:51.516 --> 00:10:52.656 A:middle
最后一件要做的事是

00:10:52.656 --> 00:10:55.786 A:middle
在这里设置 includePeerToPeer

00:10:55.786 --> 00:10:57.486 A:middle
这样即便不在同一个网络

00:10:57.486 --> 00:11:00.006 A:middle
我们的连接和监听器

00:11:00.006 --> 00:11:01.976 A:middle
也可以连接到附近设备

00:11:02.506 --> 00:11:07.546 A:middle
就是这样 我们试一下

00:11:07.756 --> 00:11:10.276 A:middle
这里 可以看到有两台设备

00:11:10.586 --> 00:11:11.966 A:middle
正在运行 App

00:11:11.966 --> 00:11:13.856 A:middle
我们已经准备好 UI 创建游戏了

00:11:14.416 --> 00:11:17.236 A:middle
浏览器已经开始搜索

00:11:17.236 --> 00:11:18.476 A:middle
正显示 搜索游戏中

00:11:18.476 --> 00:11:20.266 A:middle
因为我们还没找到游戏

00:11:21.276 --> 00:11:23.106 A:middle
如果我输入名字   

00:11:24.376 --> 00:11:26.516 A:middle
点按创建游戏 你可以看到

00:11:26.596 --> 00:11:28.316 A:middle
我拿到了一个密码

00:11:28.316 --> 00:11:29.726 A:middle
通过发现的端点列表

00:11:29.726 --> 00:11:31.396 A:middle
在这里是我创建的游戏

00:11:31.396 --> 00:11:34.296 A:middle
browseResultsChangedHandler 被调用

00:11:34.516 --> 00:11:35.806 A:middle
我们把界面展示给用户

00:11:36.116 --> 00:11:36.716 A:middle
就是这么简单

00:11:37.316 --> 00:11:41.526 A:middle
如果我点按加入游戏

00:11:41.526 --> 00:11:45.526 A:middle
就会显示输入密码

00:11:45.526 --> 00:11:47.386 A:middle
现在我确认密码

00:11:47.806 --> 00:11:49.276 A:middle
可以看到我们创建了

00:11:49.276 --> 00:11:51.166 A:middle
一个预共享密码

00:11:51.166 --> 00:11:52.276 A:middle
用它回连到监听器

00:11:52.746 --> 00:11:54.366 A:middle
一切正常的话 页面翻转

00:11:54.366 --> 00:11:57.036 A:middle
游戏就可以玩了 就是这样

00:11:58.516 --> 00:12:01.500 A:middle
[掌声]

00:12:08.236 --> 00:12:09.756 A:middle
到现在为止 

00:12:09.756 --> 00:12:11.426 A:middle
我们已经搭建了 App 的开头

00:12:11.426 --> 00:12:13.646 A:middle
在两个设备间建立了连接

00:12:14.386 --> 00:12:15.846 A:middle
我们用 NWListener 

00:12:15.846 --> 00:12:17.276 A:middle
发布一个 Bonjour 

00:12:17.316 --> 00:12:18.246 A:middle
_tictactoe._tcp 服务

00:12:18.246 --> 00:12:21.856 A:middle
用 NWBrowser 

00:12:21.856 --> 00:12:24.016 A:middle
搜索可玩的游戏 展示给用户

00:12:24.456 --> 00:12:25.866 A:middle
我们可以选取一个结果

00:12:25.866 --> 00:12:27.236 A:middle
从浏览器返回

00:12:27.236 --> 00:12:29.186 A:middle
直接传送给 NWConnection

00:12:29.186 --> 00:12:30.956 A:middle
回连到监听器

00:12:30.996 --> 00:12:32.346 A:middle
在两个设备之间

00:12:32.346 --> 00:12:34.546 A:middle
建立一个安全的连接

00:12:35.596 --> 00:12:36.816 A:middle
当然 为了玩游戏

00:12:36.816 --> 00:12:38.336 A:middle
两个设备要能交流

00:12:38.336 --> 00:12:39.446 A:middle
分享游戏状态 

00:12:39.686 --> 00:12:42.666 A:middle
告诉彼此玩家们的操作

00:12:42.666 --> 00:12:44.456 A:middle
诸如此类

00:12:45.276 --> 00:12:46.726 A:middle
要演示这一点

00:12:46.726 --> 00:12:48.216 A:middle
我想请 Tommy 上台

00:12:48.216 --> 00:12:50.466 A:middle
带大家搭建自定义框架协议

00:12:51.516 --> 00:12:56.316 A:middle
[掌声]

00:12:56.816 --> 00:12:57.556 A:middle
&gt;&gt; 好的

00:12:57.556 --> 00:12:58.786 A:middle
谢谢你 Eric

00:12:59.796 --> 00:13:01.416 A:middle
今天 我想给大家分享 

00:13:01.466 --> 00:13:04.006 A:middle
一些新的方法

00:13:04.006 --> 00:13:05.846 A:middle
可以用你写的

00:13:05.846 --> 00:13:08.786 A:middle
自定义协议框架代码

00:13:08.786 --> 00:13:10.776 A:middle
来扩展网络连接  

00:13:10.776 --> 00:13:12.916 A:middle
它和网络栈的

00:13:12.916 --> 00:13:13.956 A:middle
其他协议一样

00:13:13.956 --> 00:13:15.706 A:middle
在同一线程上运行

00:13:16.116 --> 00:13:17.806 A:middle
所以 要做完 Eric 

00:13:17.806 --> 00:13:19.666 A:middle
开始做的那个游戏

00:13:19.666 --> 00:13:21.236 A:middle
我们需要为两个游戏定义一个 

00:13:21.236 --> 00:13:23.236 A:middle
互相发送指令的方法

00:13:23.856 --> 00:13:24.966 A:middle
当一个玩家要操作时

00:13:24.966 --> 00:13:27.066 A:middle
他需要给另一端发送消息

00:13:28.206 --> 00:13:30.386 A:middle
这时我们就需要一个协议

00:13:30.966 --> 00:13:33.546 A:middle
我们的协议

00:13:33.546 --> 00:13:34.276 A:middle
看起来是这样的

00:13:34.836 --> 00:13:37.686 A:middle
它是个简单的 类-长度-值

00:13:37.686 --> 00:13:38.996 A:middle
也就是 TLV 协议

00:13:40.016 --> 00:13:42.196 A:middle
类型占用 4 字节

00:13:42.196 --> 00:13:44.156 A:middle
可能意味着走一步棋

00:13:44.936 --> 00:13:47.116 A:middle
玩家想要把一个给定符号

00:13:47.116 --> 00:13:49.716 A:middle
放在我们井字盘的给定位置

00:13:50.296 --> 00:13:52.796 A:middle
长度也占用 4 字节

00:13:52.796 --> 00:13:54.626 A:middle
声明其他消息

00:13:55.166 --> 00:13:58.726 A:middle
然后是消息体

00:13:59.086 --> 00:14:00.326 A:middle
在我们的例子中

00:14:00.436 --> 00:14:03.696 A:middle
它可能是把猴子脸放在第 1 行第 2 列

00:14:04.506 --> 00:14:05.456 A:middle
然后它会在 TLS 字节流上

00:14:05.456 --> 00:14:07.546 A:middle
像这样重复

00:14:10.196 --> 00:14:11.706 A:middle
你可能已经发现 

00:14:11.956 --> 00:14:13.906 A:middle
尽管我们是在 

00:14:13.906 --> 00:14:15.736 A:middle
TLS 字节流上运行的

00:14:15.736 --> 00:14:17.456 A:middle
这个字节流本身没有被结构化

00:14:17.456 --> 00:14:20.946 A:middle
但它在使用结构化消息

00:14:21.556 --> 00:14:25.026 A:middle
App 并不是 以字节流的方式思考

00:14:25.026 --> 00:14:27.506 A:middle
而是通过清晰的消息

00:14:28.696 --> 00:14:29.976 A:middle
几乎所有的联网 App

00:14:29.976 --> 00:14:31.616 A:middle
都会这么做

00:14:32.806 --> 00:14:34.666 A:middle
它们有一个 Header 或 Body

00:14:34.666 --> 00:14:37.246 A:middle
或分隔符

00:14:37.666 --> 00:14:40.336 A:middle
用来定义消息的界限

00:14:41.756 --> 00:14:45.446 A:middle
但是 传统通讯网络 API

00:14:45.446 --> 00:14:47.266 A:middle
比如套接字

00:14:47.536 --> 00:14:49.986 A:middle
读取连接上的消息

00:14:49.986 --> 00:14:52.336 A:middle
并不简单

00:14:52.536 --> 00:14:53.586 A:middle
你要在 App 中

00:14:53.586 --> 00:14:54.236 A:middle
亲自做这件事

00:14:55.166 --> 00:14:57.436 A:middle
在看这个问题之前  

00:14:57.466 --> 00:14:59.646 A:middle
我们先来看一下

00:14:59.646 --> 00:15:03.526 A:middle
你的 App 和其他网络栈的关系

00:15:03.666 --> 00:15:06.006 A:middle
上面是你的 App

00:15:07.186 --> 00:15:08.746 A:middle
它通过 API

00:15:08.746 --> 00:15:10.586 A:middle
和网络栈交流

00:15:11.806 --> 00:15:13.846 A:middle
所以在 Network.framework 里

00:15:14.366 --> 00:15:18.086 A:middle
TLS 和 TCP 都在 App 的

00:15:18.086 --> 00:15:20.936 A:middle
同一共享线程里运行

00:15:21.346 --> 00:15:22.486 A:middle
这就是我们去年介绍的

00:15:22.486 --> 00:15:24.706 A:middle
用户空间网络栈

00:15:25.786 --> 00:15:27.896 A:middle
让我们近距离看一下

00:15:27.896 --> 00:15:30.266 A:middle
当 App 在一个字节流上方时

00:15:30.266 --> 00:15:33.196 A:middle
是如何读取信息的

00:15:33.376 --> 00:15:34.916 A:middle
如果我们有一个协议

00:15:34.916 --> 00:15:36.146 A:middle
和刚才井字游戏一样的协议

00:15:36.146 --> 00:15:39.086 A:middle
那你可能有一个固定长度的 Header

00:15:39.796 --> 00:15:41.056 A:middle
这里你可以简单地

00:15:41.056 --> 00:15:44.186 A:middle
准确读取 Header 的长度

00:15:45.246 --> 00:15:46.336 A:middle
收到 8 个字节

00:15:47.236 --> 00:15:48.286 A:middle
所以是固定长度

00:15:48.286 --> 00:15:49.266 A:middle
你知道会发生什么

00:15:49.796 --> 00:15:51.456 A:middle
当你读取完整长度时

00:15:51.456 --> 00:15:52.716 A:middle
栈会回调你 

00:15:53.396 --> 00:15:55.156 A:middle
这就让你可以确定

00:15:55.156 --> 00:15:56.436 A:middle
剩余消息的长度

00:15:56.786 --> 00:15:58.776 A:middle
你可以准确读取

00:15:58.776 --> 00:16:00.216 A:middle
然后读取 Header-Body-Header-Body

00:16:00.216 --> 00:16:03.296 A:middle
如此循环往复

00:16:03.826 --> 00:16:07.796 A:middle
这很棒

00:16:07.796 --> 00:16:08.966 A:middle
但是你可能已经注意到

00:16:08.966 --> 00:16:10.816 A:middle
我们要循环多次 

00:16:10.816 --> 00:16:13.226 A:middle
每条消息至少循环两次

00:16:13.776 --> 00:16:15.356 A:middle
如果你的协议更复杂

00:16:15.356 --> 00:16:16.896 A:middle
如果是一个

00:16:16.896 --> 00:16:18.936 A:middle
可变长度 Header 

00:16:18.936 --> 00:16:20.576 A:middle
或者如果是分隔符 

00:16:20.576 --> 00:16:22.226 A:middle
这甚至会变得更没效率

00:16:22.726 --> 00:16:23.876 A:middle
尽管对于你的 App 来说

00:16:23.876 --> 00:16:25.786 A:middle
写这个逻辑很简单

00:16:27.056 --> 00:16:28.716 A:middle
如果你特别重视效率

00:16:28.716 --> 00:16:30.206 A:middle
你有另一个选择

00:16:30.836 --> 00:16:33.436 A:middle
你可以一次接收很多内容

00:16:34.176 --> 00:16:35.936 A:middle
但是现在

00:16:35.936 --> 00:16:36.906 A:middle
你有其他几个问题要处理

00:16:37.766 --> 00:16:39.506 A:middle
首次 你要解决

00:16:39.506 --> 00:16:40.716 A:middle
没能在一个数据块里

00:16:40.716 --> 00:16:42.396 A:middle
接收一条完整消息

00:16:43.226 --> 00:16:44.476 A:middle
或者你在一口气

00:16:44.476 --> 00:16:46.856 A:middle
接收了几条消息

00:16:46.856 --> 00:16:48.976 A:middle
或者你只接收了 Header 的一部分

00:16:48.976 --> 00:16:51.936 A:middle
或者你只有长度域的两三个字节

00:16:51.936 --> 00:16:53.186 A:middle
你需要保存

00:16:53.186 --> 00:16:55.796 A:middle
重建域 然后重新解析出来

00:16:56.926 --> 00:16:58.876 A:middle
要做到完全正确

00:16:58.876 --> 00:17:00.356 A:middle
处理好每一种可能的特殊情况

00:17:00.356 --> 00:17:02.776 A:middle
是非常困难的

00:17:03.186 --> 00:17:04.486 A:middle
情况通常是这样的

00:17:04.486 --> 00:17:06.256 A:middle
一些小的 Bug

00:17:06.256 --> 00:17:07.656 A:middle
只有在用户使用 App 的时候

00:17:07.656 --> 00:17:08.685 A:middle
才会显现出来

00:17:10.756 --> 00:17:14.106 A:middle
好 情况看起来有些不妙

00:17:14.506 --> 00:17:16.695 A:middle
如何才能两全呢

00:17:16.695 --> 00:17:18.786 A:middle
如果能够既保证高效

00:17:18.786 --> 00:17:21.425 A:middle
又保证代码简单

00:17:21.425 --> 00:17:23.256 A:middle
易于验证和组合呢

00:17:24.056 --> 00:17:25.915 A:middle
我很高兴能分享给大家一个消息

00:17:25.915 --> 00:17:28.215 A:middle
现在 在 iOS 13 和 macOS Catalina

00:17:28.215 --> 00:17:29.986 A:middle
你可以自己写

00:17:29.986 --> 00:17:32.226 A:middle
在同一网络线程上运行的

00:17:32.756 --> 00:17:35.986 A:middle
协议代码 来解决这个问题

00:17:36.376 --> 00:17:38.116 A:middle
所以如果你要在

00:17:38.116 --> 00:17:39.916 A:middle
通信网络 API 里定义消息

00:17:39.916 --> 00:17:41.446 A:middle
这个方法 

00:17:41.446 --> 00:17:43.796 A:middle
让这件事变得

00:17:43.796 --> 00:17:44.976 A:middle
前所未有得简单

00:17:44.976 --> 00:17:45.706 A:middle
[掌声]

00:17:45.706 --> 00:17:51.386 A:middle
谢谢 你要在 NWConnection 里

00:17:51.386 --> 00:17:52.926 A:middle
做这些事情

00:17:53.086 --> 00:17:54.546 A:middle
对于上方的 App 来说

00:17:54.546 --> 00:17:56.126 A:middle
你好像只是

00:17:56.126 --> 00:17:57.596 A:middle
在基本连接上

00:17:57.596 --> 00:17:59.206 A:middle
读写数据包一样

00:18:03.066 --> 00:18:04.116 A:middle
这里依旧是 App 

00:18:04.166 --> 00:18:05.686 A:middle
依旧在发送和接收

00:18:05.816 --> 00:18:07.456 A:middle
但是现在你的框架代码

00:18:07.456 --> 00:18:09.556 A:middle
正运行在

00:18:09.556 --> 00:18:11.736 A:middle
和 TLS 和 TCP 相同的线程中

00:18:12.216 --> 00:18:13.146 A:middle
所以现在你可以调用

00:18:13.886 --> 00:18:14.846 A:middle
receiveMessage

00:18:15.226 --> 00:18:16.596 A:middle
当你有一个

00:18:16.596 --> 00:18:17.626 A:middle
App 可以处理的

00:18:17.976 --> 00:18:19.346 A:middle
完整消息时

00:18:19.346 --> 00:18:20.966 A:middle
它会准确地得到一个回调

00:18:21.596 --> 00:18:22.976 A:middle
你可以多次重复这个过程

00:18:23.266 --> 00:18:25.466 A:middle
每个消息一个调用

00:18:25.466 --> 00:18:27.246 A:middle
调试就变得非常简单

00:18:27.246 --> 00:18:28.386 A:middle
很容易就知道发生了什么

00:18:28.926 --> 00:18:31.696 A:middle
所以 这很棒

00:18:31.866 --> 00:18:33.966 A:middle
现在你可能会问

00:18:33.966 --> 00:18:35.916 A:middle
这个框架协议

00:18:35.916 --> 00:18:38.796 A:middle
可以真正实现些什么

00:18:38.796 --> 00:18:39.746 A:middle
有什么限制

00:18:39.856 --> 00:18:42.076 A:middle
好消息是 基本上所有

00:18:42.276 --> 00:18:43.786 A:middle
数据包和编码 App 数据

00:18:43.786 --> 00:18:45.976 A:middle
去传输数据的

00:18:45.976 --> 00:18:47.636 A:middle
都可以被写为

00:18:48.176 --> 00:18:50.466 A:middle
框架协议

00:18:51.146 --> 00:18:53.146 A:middle
如果你进行一次握手   

00:18:53.146 --> 00:18:54.916 A:middle
或者如果你想在连接上

00:18:55.026 --> 00:18:56.736 A:middle
实现 KeepAlive 连接

00:18:56.736 --> 00:18:58.886 A:middle
你甚至可以发送

00:18:59.076 --> 00:19:00.336 A:middle
和 App 数据不对应的 

00:19:00.376 --> 00:19:01.606 A:middle
自己的消息

00:19:02.156 --> 00:19:04.436 A:middle
你在这里实现的协议

00:19:04.436 --> 00:19:09.026 A:middle
可以是标准 IETF 官方协议

00:19:09.616 --> 00:19:12.016 A:middle
也可以是为你的 App 自定义的

00:19:12.066 --> 00:19:13.326 A:middle
我们接下来就会给井字游戏

00:19:13.326 --> 00:19:14.226 A:middle
做一个自定义的协议

00:19:15.096 --> 00:19:16.456 A:middle
如果你想搭建一个协议

00:19:16.456 --> 00:19:17.776 A:middle
需要两步

00:19:18.446 --> 00:19:21.116 A:middle
首先 实现一条可重复使用的代码

00:19:21.116 --> 00:19:23.286 A:middle
定义你的消息框架

00:19:23.836 --> 00:19:24.796 A:middle
这是协议

00:19:25.716 --> 00:19:28.486 A:middle
然后把这个协议

00:19:28.886 --> 00:19:30.776 A:middle
添加到连接协议栈

00:19:30.776 --> 00:19:34.366 A:middle
你就可以用它建立连接

00:19:34.366 --> 00:19:36.626 A:middle
发送和接收消息

00:19:37.176 --> 00:19:40.786 A:middle
好了 进入第一步

00:19:41.016 --> 00:19:41.596 A:middle
我们开始实现

00:19:41.696 --> 00:19:43.446 A:middle
框架协议

00:19:44.786 --> 00:19:47.096 A:middle
你要做的是 创建一个类

00:19:47.096 --> 00:19:48.926 A:middle
让它遵循

00:19:48.926 --> 00:19:51.066 A:middle
ProtocolFramerImplementation

00:19:51.896 --> 00:19:54.166 A:middle
你可以在这个类里做很多事情

00:19:55.136 --> 00:19:56.886 A:middle
但是要记住 

00:19:56.886 --> 00:19:58.216 A:middle
最重要的两件事是

00:19:58.216 --> 00:20:00.456 A:middle
handleOutput 发送消息

00:20:00.786 --> 00:20:02.956 A:middle
和 handleInput 解析消息

00:20:03.516 --> 00:20:04.926 A:middle
如果你可以做到这两件事

00:20:05.256 --> 00:20:06.546 A:middle
太好了 它就是一个 Framer 了

00:20:07.736 --> 00:20:08.806 A:middle
让我们看一下代码

00:20:09.506 --> 00:20:11.636 A:middle
这是协议

00:20:12.266 --> 00:20:13.486 A:middle
它要遵循

00:20:13.486 --> 00:20:15.276 A:middle
ProtocolFramerImplementation

00:20:16.526 --> 00:20:21.346 A:middle
我推荐你先创建一个定义对象

00:20:21.446 --> 00:20:23.476 A:middle
这是你协议的句柄

00:20:23.476 --> 00:20:25.046 A:middle
你可以在整个 App 的其他部分

00:20:25.366 --> 00:20:26.476 A:middle
使用这个句柄

00:20:27.096 --> 00:20:28.826 A:middle
它指的是

00:20:28.826 --> 00:20:30.166 A:middle
你可以添加到连接的协议

00:20:30.626 --> 00:20:34.106 A:middle
接下来你可以处理很多的

00:20:34.106 --> 00:20:36.156 A:middle
基本回调事件

00:20:36.626 --> 00:20:39.226 A:middle
这里最重要的是 start

00:20:39.576 --> 00:20:41.576 A:middle
每当协议载入到连接时 

00:20:41.576 --> 00:20:43.436 A:middle
start 都会被调用 

00:20:43.436 --> 00:20:46.286 A:middle
用来发起连接

00:20:47.036 --> 00:20:48.706 A:middle
如果你想做一个握手

00:20:48.706 --> 00:20:49.806 A:middle
和另一端交换什么东西

00:20:49.806 --> 00:20:51.726 A:middle
你可以在这里实现

00:20:52.626 --> 00:20:54.636 A:middle
如果你的协议很简单  

00:20:54.636 --> 00:20:55.916 A:middle
像我们的井字游戏一样

00:20:56.016 --> 00:20:57.386 A:middle
不需要设置

00:20:57.726 --> 00:20:59.636 A:middle
只需立刻标记连接就绪

00:21:02.806 --> 00:21:05.356 A:middle
现在你需要 handleOutput 和 handleInput

00:21:05.686 --> 00:21:06.796 A:middle
我们深入来看一下

00:21:09.196 --> 00:21:11.666 A:middle
handleOutput 看起来这样

00:21:12.416 --> 00:21:13.316 A:middle
每当 App 发送消息时 

00:21:13.316 --> 00:21:16.036 A:middle
你就会被

00:21:16.036 --> 00:21:17.966 A:middle
handleOutput 调用

00:21:18.546 --> 00:21:19.906 A:middle
如果你需要的话

00:21:19.906 --> 00:21:22.116 A:middle
你会收到消息元数据

00:21:22.116 --> 00:21:25.036 A:middle
还有一些自定义值

00:21:25.036 --> 00:21:26.106 A:middle
以及 App 正尝试发送的

00:21:26.106 --> 00:21:27.356 A:middle
消息长度

00:21:27.986 --> 00:21:31.016 A:middle
所以 如果你有一个

00:21:31.016 --> 00:21:32.626 A:middle
Header-Body 协议 就像我们刚才用的

00:21:33.686 --> 00:21:35.886 A:middle
你可以先创建 Header 结构

00:21:35.886 --> 00:21:38.666 A:middle
试着序列化一些数据

00:21:39.686 --> 00:21:41.266 A:middle
所以这会包括类型

00:21:41.846 --> 00:21:42.836 A:middle
也许是从消息元数据中

00:21:42.836 --> 00:21:44.666 A:middle
得到的类型

00:21:44.666 --> 00:21:47.166 A:middle
还有传送给你

00:21:47.166 --> 00:21:48.036 A:middle
到 handleOutput 的长度

00:21:48.476 --> 00:21:51.086 A:middle
你可以组合这些数据

00:21:51.086 --> 00:21:52.466 A:middle
然后调用 writeOutput

00:21:52.896 --> 00:21:54.656 A:middle
writeOutput 会将字节

00:21:54.656 --> 00:21:56.506 A:middle
排列到输出流

00:21:56.876 --> 00:22:00.706 A:middle
但是实际上它们还没有发出去

00:22:00.986 --> 00:22:03.086 A:middle
然后你需要写主体

00:22:03.226 --> 00:22:04.876 A:middle
在这个例子中 

00:22:04.876 --> 00:22:06.916 A:middle
我们完全不需要转存 App 数据

00:22:07.316 --> 00:22:09.876 A:middle
我们可以只调用 writeOutputNoCopy

00:22:11.086 --> 00:22:13.236 A:middle
它让我们直接

00:22:13.236 --> 00:22:15.686 A:middle
将 App 字节排列到输出流

00:22:16.496 --> 00:22:17.476 A:middle
当我们从 handleOutput 返回时

00:22:17.476 --> 00:22:20.116 A:middle
所有的字节都会被

00:22:20.166 --> 00:22:21.536 A:middle
发送出去连接

00:22:22.016 --> 00:22:25.636 A:middle
好了 我们接着处理输入

00:22:26.416 --> 00:22:28.606 A:middle
处理输入和处理输出类似

00:22:28.606 --> 00:22:29.806 A:middle
但是略微复杂

00:22:30.856 --> 00:22:36.806 A:middle
每当你的 App 接收到连接上的新字节时

00:22:36.806 --> 00:22:37.896 A:middle
你会被 handleInput 调用

00:22:38.506 --> 00:22:40.346 A:middle
如果你做的是 

00:22:40.496 --> 00:22:42.956 A:middle
Header-Body 类型协议 你有两件事要做

00:22:42.956 --> 00:22:45.206 A:middle
你需要解析 Header

00:22:45.206 --> 00:22:46.306 A:middle
然后你需要解析 Body

00:22:46.966 --> 00:22:48.756 A:middle
我们先解析 Header

00:22:49.376 --> 00:22:50.986 A:middle
这儿 我们的协议有一个

00:22:50.986 --> 00:22:52.036 A:middle
固定长度的 Header

00:22:52.036 --> 00:22:53.726 A:middle
正好是 8 个字节

00:22:54.216 --> 00:22:55.526 A:middle
我们做的是

00:22:55.606 --> 00:22:57.436 A:middle
调用 parseInput 开始检查

00:22:57.436 --> 00:22:59.486 A:middle
已经进入连接的字节流

00:23:03.586 --> 00:23:05.026 A:middle
因为我们希望准确查看

00:23:05.026 --> 00:23:05.826 A:middle
8 字节 Header

00:23:06.456 --> 00:23:09.076 A:middle
如果成功了

00:23:09.076 --> 00:23:10.796 A:middle
你会在组块里被调用

00:23:10.796 --> 00:23:12.066 A:middle
你能看到真正的缓冲字节

00:23:12.066 --> 00:23:13.826 A:middle
解析你的值

00:23:13.826 --> 00:23:15.796 A:middle
如果需要的话 

00:23:15.796 --> 00:23:17.576 A:middle
将它们存到本地变量

00:23:18.156 --> 00:23:20.706 A:middle
解析输入的返回值

00:23:21.416 --> 00:23:22.786 A:middle
表示你想用多少字节 

00:23:22.786 --> 00:23:25.086 A:middle
增量输入光标 

00:23:25.186 --> 00:23:27.846 A:middle
我处理完了这 8 个字节

00:23:27.916 --> 00:23:29.046 A:middle
我们不需要再看到它们了

00:23:29.046 --> 00:23:30.896 A:middle
不需要将它们传送给 App

00:23:31.306 --> 00:23:34.936 A:middle
继续 现在你可以处理

00:23:34.936 --> 00:23:36.986 A:middle
不是所有的 8 个字节

00:23:36.986 --> 00:23:37.806 A:middle
都可用的情况

00:23:38.296 --> 00:23:41.346 A:middle
在这种情况下 

00:23:41.416 --> 00:23:43.416 A:middle
parseInput 函数会失效

00:23:43.506 --> 00:23:45.936 A:middle
你只需等待更多字节可用

00:23:46.726 --> 00:23:48.616 A:middle
handleInput 的返回值表明

00:23:48.616 --> 00:23:52.786 A:middle
要有足够的字节数量

00:23:52.786 --> 00:23:54.546 A:middle
然后你才能做更多工作

00:23:54.976 --> 00:23:56.476 A:middle
所以在这个例子中

00:23:56.476 --> 00:23:57.796 A:middle
我们是在告诉连接 

00:23:57.796 --> 00:23:59.496 A:middle
在你再次唤醒我之前

00:23:59.496 --> 00:24:01.376 A:middle
确保有 8 个字节

00:24:01.556 --> 00:24:06.706 A:middle
如果你能成功读出 Header

00:24:06.706 --> 00:24:09.426 A:middle
你可以创建一个消息对象

00:24:09.426 --> 00:24:10.276 A:middle
可以和数据一起

00:24:10.276 --> 00:24:11.826 A:middle
传送给 App

00:24:12.456 --> 00:24:14.796 A:middle
这让你可以放入任何

00:24:14.796 --> 00:24:16.846 A:middle
你想要发送到 App 的

00:24:16.896 --> 00:24:19.326 A:middle
自定义值 类型 或其他指针

00:24:19.936 --> 00:24:23.766 A:middle
最后 在这种情况下

00:24:23.766 --> 00:24:25.326 A:middle
你可以调用 deliverInput 

00:24:25.326 --> 00:24:27.506 A:middle
或者 deliverInputNoCopy 

00:24:28.096 --> 00:24:29.866 A:middle
这可以让你将

00:24:29.866 --> 00:24:31.656 A:middle
下一段确定范围的字节

00:24:31.656 --> 00:24:32.916 A:middle
标记为应该

00:24:32.916 --> 00:24:35.186 A:middle
直接传送给 App 的 App 数据

00:24:35.736 --> 00:24:39.086 A:middle
它返回 Boolean 值

00:24:39.086 --> 00:24:41.446 A:middle
去显示是不是 

00:24:41.446 --> 00:24:43.006 A:middle
所有的字节都是可用的 

00:24:43.136 --> 00:24:45.296 A:middle
是否成功发送

00:24:45.296 --> 00:24:46.656 A:middle
连接需不需要再等

00:24:47.096 --> 00:24:48.766 A:middle
所以如果你需要的话

00:24:48.766 --> 00:24:50.116 A:middle
你真的可以

00:24:50.116 --> 00:24:51.506 A:middle
传送输入消息

00:24:51.506 --> 00:24:53.476 A:middle
兆甚至千兆字节长

00:24:53.476 --> 00:24:54.866 A:middle
那些字节作为信息的一部分 

00:24:54.866 --> 00:24:56.336 A:middle
会持续流出

00:24:56.336 --> 00:24:57.426 A:middle
你无需等待所有的字节都可用

00:24:57.426 --> 00:24:59.956 A:middle
或者亲自处理这些

00:25:04.676 --> 00:25:06.176 A:middle
但是我们马上就可以

00:25:06.176 --> 00:25:09.786 A:middle
为井字游戏实施协议了

00:25:19.176 --> 00:25:22.546 A:middle
好 这就是之前 

00:25:22.666 --> 00:25:24.076 A:middle
Eric 做的游戏

00:25:24.906 --> 00:25:26.676 A:middle
现在我要创建一个新类

00:25:26.816 --> 00:25:28.326 A:middle
命名为游戏协议

00:25:28.396 --> 00:25:31.766 A:middle
它会遵循 NWProtocolFramerImplementation

00:25:32.266 --> 00:25:34.786 A:middle
我已经为这个游戏定义了

00:25:34.786 --> 00:25:36.616 A:middle
两个不同的类型

00:25:36.616 --> 00:25:37.836 A:middle
我想要发送两个

00:25:37.836 --> 00:25:38.726 A:middle
不同的指令

00:25:39.696 --> 00:25:41.336 A:middle
一个是选择角色

00:25:41.826 --> 00:25:43.826 A:middle
游戏的第一步是

00:25:43.826 --> 00:25:45.176 A:middle
玩家需要选择 

00:25:45.276 --> 00:25:46.976 A:middle
他们想用哪个表情符号

00:25:46.976 --> 00:25:48.726 A:middle
他们想当猴子还是当鸟

00:25:49.986 --> 00:25:53.566 A:middle
然当玩家选择了他们的角色后

00:25:53.566 --> 00:25:55.216 A:middle
就开始发送走棋操作

00:25:55.516 --> 00:25:57.006 A:middle
这就会变成更长的 Body

00:25:57.006 --> 00:26:02.026 A:middle
它会包括角色和行 列值

00:26:03.996 --> 00:26:06.826 A:middle
好 我记得 

00:26:06.826 --> 00:26:07.936 A:middle
当我实施协议时 

00:26:07.936 --> 00:26:10.836 A:middle
我要做的第一件事就是

00:26:11.046 --> 00:26:12.126 A:middle
创建一个定义

00:26:12.126 --> 00:26:15.446 A:middle
这是基于我的对象的句柄

00:26:15.446 --> 00:26:17.846 A:middle
它在系统中注册对象

00:26:17.896 --> 00:26:21.796 A:middle
让我可以在连接中使用这个

00:26:26.476 --> 00:26:29.226 A:middle
接下来 我要处理所有的基本回调

00:26:29.576 --> 00:26:30.876 A:middle
这里再一次

00:26:30.876 --> 00:26:32.646 A:middle
因为我不需要自己的握手

00:26:32.926 --> 00:26:34.456 A:middle
当我被启动调用时

00:26:35.026 --> 00:26:37.806 A:middle
我可以返回一个就绪的启动结果

00:26:40.026 --> 00:26:42.246 A:middle
接着 我们来处理

00:26:42.246 --> 00:26:43.796 A:middle
发送和打包消息

00:26:47.616 --> 00:26:49.696 A:middle
我将在这里定义

00:26:49.696 --> 00:26:51.296 A:middle
handleOutput 的实现

00:26:55.696 --> 00:26:58.416 A:middle
所以头部是一个 8 字节 Header

00:26:58.666 --> 00:27:00.436 A:middle
包括一个类型和长度

00:27:00.626 --> 00:27:02.366 A:middle
首先我要知道我的类型是什么

00:27:02.366 --> 00:27:04.786 A:middle
我从 App 发送的消息中

00:27:04.786 --> 00:27:06.636 A:middle
得知类型

00:27:06.636 --> 00:27:08.426 A:middle
我们稍后会看这个

00:27:08.926 --> 00:27:12.376 A:middle
我已经给 framer 消息

00:27:12.376 --> 00:27:14.386 A:middle
创建了一个自定义扩展 

00:27:14.426 --> 00:27:16.456 A:middle
用来提取特定枚举类型

00:27:16.886 --> 00:27:18.646 A:middle
这样我就可以知道

00:27:18.686 --> 00:27:20.356 A:middle
是选棋还是走棋

00:27:21.096 --> 00:27:22.896 A:middle
有了类型

00:27:22.896 --> 00:27:25.426 A:middle
我就可以在 handleOutput  中

00:27:25.426 --> 00:27:27.126 A:middle
通过传输的类型和长度

00:27:27.906 --> 00:27:29.956 A:middle
实例化我的结构

00:27:29.956 --> 00:27:30.796 A:middle
我的游戏协议 Header 

00:27:32.096 --> 00:27:33.736 A:middle
我已经写了代码

00:27:34.096 --> 00:27:35.776 A:middle
编码那份

00:27:35.776 --> 00:27:38.286 A:middle
类型和长度为 

00:27:38.476 --> 00:27:39.466 A:middle
8 字节范围的数据

00:27:39.786 --> 00:27:42.006 A:middle
我调用 writeOutput 

00:27:42.006 --> 00:27:43.356 A:middle
把那个数据加入到输出流队列中

00:27:43.856 --> 00:27:47.676 A:middle
现在我要做最后一件事

00:27:47.706 --> 00:27:48.896 A:middle
既然我已经写了 Header

00:27:49.116 --> 00:27:50.516 A:middle
现在就要写 Body

00:27:50.986 --> 00:27:51.846 A:middle
这里我只需调用

00:27:51.846 --> 00:27:53.606 A:middle
writeOutputNoCopy 

00:27:53.606 --> 00:27:55.956 A:middle
表明下一个宽度的字节 

00:27:55.956 --> 00:27:57.516 A:middle
是这个消息的 Body

00:27:58.736 --> 00:28:00.256 A:middle
一旦这个返回

00:28:00.256 --> 00:28:01.586 A:middle
这些字节就会被发送  

00:28:01.586 --> 00:28:03.306 A:middle
我就可以处理更多的信息

00:28:03.306 --> 00:28:04.086 A:middle
不论是输入还是输出

00:28:04.676 --> 00:28:08.656 A:middle
好 写入就完成了

00:28:08.656 --> 00:28:10.746 A:middle
现在来看读取 

00:28:10.746 --> 00:28:11.646 A:middle
我要处理输入

00:28:14.536 --> 00:28:16.886 A:middle
首先我要读出 

00:28:16.886 --> 00:28:17.676 A:middle
解析 Header

00:28:18.126 --> 00:28:19.836 A:middle
先是一个固定大小的 Header

00:28:20.066 --> 00:28:21.346 A:middle
8 个字节

00:28:22.546 --> 00:28:24.486 A:middle
我将尝试解析出

00:28:24.486 --> 00:28:26.696 A:middle
最小 8 个字节 最大 8 个字节

00:28:26.696 --> 00:28:32.276 A:middle
每当有 8 个字节可用时

00:28:32.276 --> 00:28:34.296 A:middle
我都会被缓冲调用 

00:28:34.916 --> 00:28:37.156 A:middle
这里我确认

00:28:37.156 --> 00:28:39.196 A:middle
缓冲是有效的

00:28:39.196 --> 00:28:42.296 A:middle
然后创建结构 

00:28:42.296 --> 00:28:44.776 A:middle
将那 8 个字节解析为类型和长度域

00:28:46.716 --> 00:28:47.746 A:middle
一旦这一步成功了

00:28:47.746 --> 00:28:51.996 A:middle
就表明我想用 8 个字节增量光标

00:28:52.056 --> 00:28:54.166 A:middle
说明我已经使用了这些字节

00:28:54.276 --> 00:28:59.036 A:middle
这些字节没用了

00:28:59.256 --> 00:29:01.236 A:middle
现在我同样需要处理

00:29:01.236 --> 00:29:02.746 A:middle
没有成功解析

00:29:02.746 --> 00:29:04.596 A:middle
所有 8 个字节的情况

00:29:04.786 --> 00:29:06.596 A:middle
可能只有 5 个字节是可用的

00:29:07.636 --> 00:29:08.876 A:middle
所以解析失败

00:29:09.436 --> 00:29:10.926 A:middle
我将从处理输入返回

00:29:10.926 --> 00:29:13.726 A:middle
表明我需要

00:29:13.726 --> 00:29:15.246 A:middle
等待 8 个字节可用

00:29:15.246 --> 00:29:18.166 A:middle
然后才能继续

00:29:18.716 --> 00:29:20.026 A:middle
但是如果我真的过了这一步

00:29:20.066 --> 00:29:21.786 A:middle
我就知道 Header 是有效的

00:29:21.786 --> 00:29:23.886 A:middle
我可以用它

00:29:23.886 --> 00:29:25.976 A:middle
传送剩余的 App 数据

00:29:29.756 --> 00:29:32.516 A:middle
所以现在我要创建一个信息对象

00:29:32.806 --> 00:29:34.326 A:middle
我要将我的特定消息类型

00:29:34.326 --> 00:29:37.986 A:middle
存储在那个消息对象中

00:29:40.176 --> 00:29:44.066 A:middle
最后我会调用

00:29:44.066 --> 00:29:47.006 A:middle
deliverInputNoCopy

00:29:47.006 --> 00:29:48.976 A:middle
直接告诉连接

00:29:48.976 --> 00:29:50.706 A:middle
接下来的那些

00:29:50.746 --> 00:29:53.506 A:middle
每当有 是 App 数据

00:29:53.506 --> 00:29:55.256 A:middle
当你的 App 收到消息时

00:29:55.256 --> 00:29:56.586 A:middle
它们会准确接收到

00:29:56.586 --> 00:29:58.106 A:middle
那个组块

00:29:59.026 --> 00:30:00.266 A:middle
这就是我要做的

00:30:00.396 --> 00:30:01.606 A:middle
这就是完整的协议

00:30:01.606 --> 00:30:04.236 A:middle
接下来我会介绍

00:30:04.346 --> 00:30:05.846 A:middle
如何初始化 把它输入到游戏连接中去

00:30:09.181 --> 00:30:11.181 A:middle
[掌声]

00:30:11.346 --> 00:30:16.706 A:middle
好 好消息是

00:30:16.706 --> 00:30:17.826 A:middle
这部分比较简单

00:30:18.516 --> 00:30:21.116 A:middle
要把协议添加到连接 并重复使用它 

00:30:21.116 --> 00:30:23.966 A:middle
你只需要选取

00:30:23.966 --> 00:30:25.426 A:middle
之前做的定义

00:30:26.316 --> 00:30:28.306 A:middle
用那个定义

00:30:28.396 --> 00:30:29.516 A:middle
创建一些协议选项

00:30:30.016 --> 00:30:32.426 A:middle
协议选项

00:30:32.476 --> 00:30:34.426 A:middle
是协议栈的组成部分

00:30:35.036 --> 00:30:38.546 A:middle
有 TCP 选项 TLS 选项 

00:30:38.546 --> 00:30:40.396 A:middle
现在有自己的自定义协议选项

00:30:41.036 --> 00:30:42.576 A:middle
当你为连接

00:30:42.576 --> 00:30:43.816 A:middle
创建 parameters 时

00:30:43.996 --> 00:30:45.766 A:middle
比如说你在用 TLS 

00:30:45.766 --> 00:30:46.946 A:middle
因为它可以确保通信安全

00:30:48.226 --> 00:30:50.806 A:middle
以及协议栈里的 TLS 

00:30:50.806 --> 00:30:53.096 A:middle
你可以直接

00:30:53.096 --> 00:30:54.446 A:middle
将自己的协议

00:30:54.446 --> 00:30:56.926 A:middle
添加到 applicationProtocols 数组的顶部

00:30:57.696 --> 00:30:58.736 A:middle
你可以添加多个

00:30:58.736 --> 00:31:01.406 A:middle
运行多层框架

00:31:02.046 --> 00:31:03.206 A:middle
如果你想用 WebSocket

00:31:03.206 --> 00:31:04.806 A:middle
也是在这个地方

00:31:05.346 --> 00:31:06.676 A:middle
WebSocket 是一个今年

00:31:06.676 --> 00:31:07.996 A:middle
新的系统实施

00:31:07.996 --> 00:31:10.496 A:middle
你可以将它添加到你的连接

00:31:11.886 --> 00:31:14.586 A:middle
WebSocket 本身

00:31:14.766 --> 00:31:16.976 A:middle
作为协议框架被实施

00:31:17.266 --> 00:31:19.226 A:middle
和你现在可用的

00:31:19.556 --> 00:31:21.036 A:middle
使用的相同的 API

00:31:21.356 --> 00:31:22.506 A:middle
它向你展示了

00:31:22.506 --> 00:31:25.006 A:middle
一个框架协议有多强大

00:31:25.736 --> 00:31:27.556 A:middle
如果你不想自己写

00:31:27.556 --> 00:31:29.386 A:middle
那你可以用 WebSocket

00:31:33.546 --> 00:31:34.726 A:middle
在这里我想说的是

00:31:34.726 --> 00:31:36.666 A:middle
一些 App  

00:31:36.666 --> 00:31:38.926 A:middle
在不同的情况下

00:31:39.256 --> 00:31:40.456 A:middle
需要使用不同的协议栈

00:31:41.366 --> 00:31:43.156 A:middle
框架协议真的是一个

00:31:43.156 --> 00:31:46.136 A:middle
在 App 和网络连接之间

00:31:46.136 --> 00:31:47.436 A:middle
建立合约的好方法

00:31:47.436 --> 00:31:48.806 A:middle
即便你在使用 

00:31:48.806 --> 00:31:51.006 A:middle
不同的协议栈

00:31:51.006 --> 00:31:52.596 A:middle
依旧如此

00:31:53.466 --> 00:31:54.916 A:middle
为给大家举个例子

00:31:54.916 --> 00:31:58.026 A:middle
我们在 DNS 系统上使用这个

00:31:58.936 --> 00:32:01.506 A:middle
DNS 通常通过 UDP

00:32:01.506 --> 00:32:04.206 A:middle
发送数据包消息

00:32:05.876 --> 00:32:08.306 A:middle
但是偶尔 DNS 会和 TCP 一样 

00:32:08.306 --> 00:32:10.736 A:middle
需要在流的上端运行

00:32:11.236 --> 00:32:12.846 A:middle
当它这么做时 

00:32:12.846 --> 00:32:14.596 A:middle
会有一个 Body 格式

00:32:14.596 --> 00:32:17.356 A:middle
它只有一个非常基本的长度

00:32:17.356 --> 00:32:19.726 A:middle
用 TCP 编码 DNS 

00:32:20.726 --> 00:32:23.206 A:middle
所以我们写了一个 framer

00:32:23.206 --> 00:32:26.216 A:middle
用来定义这个简单的数据包

00:32:26.216 --> 00:32:28.106 A:middle
这样在上方就有相同的代码

00:32:28.106 --> 00:32:32.716 A:middle
发送 DNS 数据包不需要考虑

00:32:32.716 --> 00:32:34.626 A:middle
它用的是 UDP 还是 TCP 

00:32:34.626 --> 00:32:36.876 A:middle
它是同样的逻辑

00:32:37.396 --> 00:32:40.676 A:middle
这样你就无需担心太多

00:32:40.676 --> 00:32:41.946 A:middle
可以分开调试

00:32:41.946 --> 00:32:43.196 A:middle
App 的不同部分

00:32:43.766 --> 00:32:47.506 A:middle
我们已经将框架协议

00:32:47.506 --> 00:32:48.776 A:middle
添加到连接

00:32:48.776 --> 00:32:50.706 A:middle
现在准备发送和接收消息

00:32:50.706 --> 00:32:52.306 A:middle
我们可以使用自定义值 

00:32:52.306 --> 00:32:55.086 A:middle
接下来我们就会在游戏里

00:32:55.086 --> 00:32:56.166 A:middle
用自定义值

00:32:57.476 --> 00:33:00.256 A:middle
Framer.Message 

00:33:00.256 --> 00:33:02.896 A:middle
让你可以存储

00:33:02.896 --> 00:33:05.436 A:middle
任何对象类型的键值对

00:33:05.436 --> 00:33:07.366 A:middle
所以你可以添加到自定义值

00:33:07.886 --> 00:33:10.586 A:middle
去修饰你的发送操作

00:33:10.586 --> 00:33:12.646 A:middle
接收协议的消息

00:33:13.586 --> 00:33:15.416 A:middle
你可以创建一条消息

00:33:15.486 --> 00:33:16.906 A:middle
按你喜欢的方式设置好它

00:33:16.906 --> 00:33:18.516 A:middle
将它发送到

00:33:18.546 --> 00:33:22.126 A:middle
你正在传送数据的上下文上

00:33:22.676 --> 00:33:25.006 A:middle
所以每个发送操作 

00:33:25.006 --> 00:33:28.186 A:middle
都已经有了内容和上下文

00:33:28.526 --> 00:33:31.396 A:middle
上下文会描述你想要如何发送数据

00:33:31.856 --> 00:33:33.546 A:middle
Framer.Message 只是

00:33:33.546 --> 00:33:37.096 A:middle
发送数据的新方式

00:33:37.276 --> 00:33:38.936 A:middle
接收也很相似

00:33:39.046 --> 00:33:40.936 A:middle
当调用 receiveMessage 时

00:33:41.776 --> 00:33:43.196 A:middle
在接收内容的同时

00:33:43.196 --> 00:33:44.936 A:middle
还能接收到上下文

00:33:44.936 --> 00:33:47.276 A:middle
它用来描述数据是如何被接收的

00:33:48.056 --> 00:33:49.746 A:middle
你可以用协议的定义

00:33:49.746 --> 00:33:52.026 A:middle
查看协议 framer 

00:33:52.126 --> 00:33:57.116 A:middle
上下文会描述特定消息值

00:33:58.006 --> 00:34:00.786 A:middle
接下来我们就要

00:34:00.936 --> 00:34:04.556 A:middle
完成这个井字游戏了

00:34:05.316 --> 00:34:09.565 A:middle
好 我们已经做好了游戏协议

00:34:10.206 --> 00:34:12.985 A:middle
要把它加入到连接中

00:34:13.045 --> 00:34:17.025 A:middle
我将返回 Eric 刚才设置的参数

00:34:17.025 --> 00:34:18.166 A:middle
他已经用 TCP 和 TLS

00:34:18.166 --> 00:34:22.216 A:middle
设置好了有密码的连接

00:34:24.106 --> 00:34:28.085 A:middle
现在我要做的只是

00:34:28.085 --> 00:34:29.036 A:middle
把这两行加进去

00:34:29.036 --> 00:34:32.286 A:middle
我要基于游戏协议定义

00:34:32.286 --> 00:34:34.696 A:middle
创建一些选项 

00:34:34.696 --> 00:34:36.485 A:middle
将它们插入到

00:34:36.485 --> 00:34:38.716 A:middle
我想要用在连接里的 App 协议数组

00:34:39.386 --> 00:34:41.036 A:middle
现在当两设备间启动连接时

00:34:41.036 --> 00:34:42.396 A:middle
它会准备就绪 

00:34:42.646 --> 00:34:46.616 A:middle
在流上编码消息

00:34:47.096 --> 00:34:51.576 A:middle
现在我要在连接中

00:34:51.576 --> 00:34:53.346 A:middle
做几个便捷函数

00:34:53.346 --> 00:34:54.676 A:middle
让 App 更简单地

00:34:54.746 --> 00:34:56.116 A:middle
发送和接收

00:34:56.116 --> 00:34:58.786 A:middle
自定义消息类型

00:34:59.836 --> 00:35:01.326 A:middle
这里有一个连接对象

00:35:01.326 --> 00:35:03.856 A:middle
它用刚才

00:35:03.856 --> 00:35:05.646 A:middle
定义的参数

00:35:05.646 --> 00:35:07.216 A:middle
设置了一个 NWConnection

00:35:08.346 --> 00:35:09.726 A:middle
每当连接就绪时

00:35:09.726 --> 00:35:11.326 A:middle
它就开始从 peer

00:35:11.326 --> 00:35:13.786 A:middle
接收消息

00:35:15.286 --> 00:35:16.746 A:middle
我们需要接收下一个消息

00:35:16.746 --> 00:35:17.876 A:middle
来实施这个

00:35:21.376 --> 00:35:23.316 A:middle
我现在做的是

00:35:23.316 --> 00:35:24.776 A:middle
获取连接 在连接上

00:35:24.776 --> 00:35:25.766 A:middle
调用 receiveMessage 

00:35:26.716 --> 00:35:29.656 A:middle
我将得到内容和上下文

00:35:30.516 --> 00:35:31.596 A:middle
我将用上下文

00:35:31.596 --> 00:35:34.506 A:middle
查看我的协议

00:35:34.506 --> 00:35:37.086 A:middle
特定的元数据

00:35:37.086 --> 00:35:38.476 A:middle
和游戏协议定义

00:35:39.516 --> 00:35:40.856 A:middle
这会给我消息对象

00:35:40.856 --> 00:35:43.266 A:middle
让我把消息类型

00:35:43.266 --> 00:35:44.986 A:middle
和数据一起

00:35:44.986 --> 00:35:46.146 A:middle
向上传送到 App 

00:35:47.116 --> 00:35:48.436 A:middle
当然 接下来 如果我

00:35:48.436 --> 00:35:49.616 A:middle
成功接收到一条消息

00:35:49.616 --> 00:35:51.136 A:middle
我会调用 receiveNextMessage 

00:35:51.136 --> 00:35:53.236 A:middle
再次重复这个过程

00:35:56.016 --> 00:35:57.676 A:middle
我还要给发送

00:35:57.946 --> 00:35:59.236 A:middle
定义一些 Helper

00:35:59.646 --> 00:36:01.096 A:middle
所以每当 App 判定

00:36:01.096 --> 00:36:02.206 A:middle
玩家是在选择角色时

00:36:02.206 --> 00:36:04.466 A:middle
我们可以创建一个消息

00:36:04.466 --> 00:36:07.716 A:middle
将所选的角色作为类型

00:36:07.716 --> 00:36:09.306 A:middle
添加到这个消息

00:36:10.096 --> 00:36:12.406 A:middle
并将其发送到上下文中

00:36:12.916 --> 00:36:15.826 A:middle
发送走棋操作

00:36:15.826 --> 00:36:16.816 A:middle
也是这样的 

00:36:16.816 --> 00:36:18.486 A:middle
在这里创建一个便捷函数 

00:36:18.486 --> 00:36:20.106 A:middle
声明我想发送走棋操作

00:36:20.106 --> 00:36:21.846 A:middle
然后只需获取 App 数据

00:36:22.316 --> 00:36:23.556 A:middle
将它向下传送给连接

00:36:24.626 --> 00:36:25.626 A:middle
这就是我们要做的

00:36:25.886 --> 00:36:27.606 A:middle
现在就可以玩游戏了

00:36:27.606 --> 00:36:29.416 A:middle
玩游戏需要两个人

00:36:29.416 --> 00:36:30.626 A:middle
Eric 请回到台上

00:36:32.456 --> 00:36:35.896 A:middle
好的 Eric 已经在这里

00:36:35.896 --> 00:36:38.476 A:middle
创建了一个游戏

00:36:38.476 --> 00:36:39.546 A:middle
但是我想自己创建一个

00:36:40.726 --> 00:36:41.136 A:middle
我们来做这一步

00:36:41.136 --> 00:36:42.946 A:middle
Eric 我们输入密码

00:36:42.946 --> 00:36:47.406 A:middle
5176

00:36:47.906 --> 00:36:48.686 A:middle
不要告诉别人 [笑声]

00:36:49.906 --> 00:36:51.116 A:middle
好了

00:36:51.116 --> 00:36:52.826 A:middle
现在我们已经设置了一个

00:36:52.826 --> 00:36:53.896 A:middle
安全的连接

00:36:54.286 --> 00:36:55.336 A:middle
它在用 TLS

00:36:55.826 --> 00:36:57.666 A:middle
当 Eric 选择一个角色时

00:36:57.666 --> 00:36:59.746 A:middle
他选择鸟

00:37:02.636 --> 00:37:04.556 A:middle
选择符号信息

00:37:04.556 --> 00:37:06.806 A:middle
我调用 receiveMessage 

00:37:06.806 --> 00:37:07.926 A:middle
收到 他选择了鸟

00:37:07.926 --> 00:37:08.936 A:middle
然后我要选择猴子

00:37:08.936 --> 00:37:10.246 A:middle
为什么不呢

00:37:11.066 --> 00:37:13.566 A:middle
现在 Eric 选择一个位置

00:37:14.326 --> 00:37:16.806 A:middle
然后选择一个符号

00:37:17.846 --> 00:37:21.276 A:middle
好的 他将走棋动作发送给了我

00:37:21.626 --> 00:37:22.616 A:middle
我收到一个消息

00:37:22.616 --> 00:37:23.846 A:middle
我知道他走了一步棋

00:37:23.846 --> 00:37:25.946 A:middle
我知道他把棋放在了哪儿

00:37:25.946 --> 00:37:29.606 A:middle
我要把猴子

00:37:29.606 --> 00:37:30.936 A:middle
放在上面

00:37:31.386 --> 00:37:32.476 A:middle
他下一步会怎么走呢

00:37:33.786 --> 00:37:35.066 A:middle
哦 看起来

00:37:35.106 --> 00:37:36.866 A:middle
他要赢了 我不知道

00:37:36.906 --> 00:37:38.336 A:middle
我玩不了这个

00:37:38.756 --> 00:37:39.896 A:middle
井字游戏太难了

00:37:40.376 --> 00:37:42.736 A:middle
好像鸟赢了

00:37:43.446 --> 00:37:45.636 A:middle
但是可以看出来

00:37:45.636 --> 00:37:47.496 A:middle
这种类型的游戏搭建起来非常简单

00:37:47.496 --> 00:37:50.076 A:middle
你还可以用这个

00:37:50.076 --> 00:37:51.666 A:middle
搭建更多的小游戏

00:37:51.666 --> 00:37:53.846 A:middle
还有很多其他的 App

00:37:53.846 --> 00:37:54.896 A:middle
我们很期待

00:37:54.896 --> 00:37:55.236 A:middle
你们的作品

00:37:56.516 --> 00:38:02.616 A:middle
[掌声]

00:38:03.116 --> 00:38:08.856 A:middle
好的 在我继续之前 

00:38:08.856 --> 00:38:10.276 A:middle
关于框架协议 我想再说

00:38:10.276 --> 00:38:11.316 A:middle
最后一件事

00:38:11.936 --> 00:38:14.156 A:middle
很多人都在问

00:38:14.156 --> 00:38:16.976 A:middle
如何用技术 比如

00:38:17.136 --> 00:38:20.326 A:middle
在 NWConnection 中采用 STARTTLS

00:38:20.776 --> 00:38:23.406 A:middle
STARTTLS 是来自 

00:38:23.406 --> 00:38:25.556 A:middle
SMTP 邮箱协议的技术

00:38:25.556 --> 00:38:29.586 A:middle
它让你可以与较早的服务器交流

00:38:29.586 --> 00:38:31.406 A:middle
你并不知道

00:38:31.406 --> 00:38:32.916 A:middle
这个服务器

00:38:32.996 --> 00:38:35.186 A:middle
是否支持 TLS 和安全连接

00:38:35.186 --> 00:38:36.576 A:middle
你可以和它做一个初次握手

00:38:37.106 --> 00:38:39.096 A:middle
如果它支持 TLS 

00:38:39.096 --> 00:38:41.586 A:middle
你可以部分通过你的连接添加它 

00:38:41.856 --> 00:38:43.476 A:middle
之前没有什么好方法

00:38:43.476 --> 00:38:45.196 A:middle
来做这一步 

00:38:45.196 --> 00:38:46.876 A:middle
但是现在我们有了框架协议

00:38:47.856 --> 00:38:50.726 A:middle
所以 如果你创建一个

00:38:50.726 --> 00:38:52.206 A:middle
STARTTLS 框架协议

00:38:52.206 --> 00:38:53.526 A:middle
将它添加到连接

00:38:53.526 --> 00:38:55.806 A:middle
当 App 启动时

00:38:55.916 --> 00:38:57.186 A:middle
你可以和服务器握手

00:38:57.186 --> 00:38:59.606 A:middle
确定它是否支持 TLS

00:39:01.386 --> 00:39:02.956 A:middle
在表明就绪之前 

00:39:02.956 --> 00:39:04.836 A:middle
在框架协议上 

00:39:04.836 --> 00:39:07.286 A:middle
动态添加协议到栈

00:39:07.956 --> 00:39:09.156 A:middle
这样 App 就会保持不变

00:39:09.156 --> 00:39:11.736 A:middle
不需要担心

00:39:11.736 --> 00:39:13.866 A:middle
部分添加 TLS 

00:39:14.216 --> 00:39:15.926 A:middle
这个过程会自动

00:39:16.226 --> 00:39:17.446 A:middle
通过框架协议进行

00:39:18.246 --> 00:39:19.216 A:middle
所以我们觉得这是一个

00:39:19.216 --> 00:39:19.936 A:middle
干净利落的方法

00:39:21.516 --> 00:39:24.366 A:middle
好 我们继续

00:39:25.006 --> 00:39:27.146 A:middle
我们已经介绍了 Bonjour

00:39:27.146 --> 00:39:28.836 A:middle
如果做更好的 P2P 连接

00:39:28.836 --> 00:39:31.456 A:middle
以及使用广域发现

00:39:31.686 --> 00:39:34.136 A:middle
我们介绍了框架协议

00:39:35.086 --> 00:39:36.136 A:middle
但是现在我想退一步

00:39:36.136 --> 00:39:38.166 A:middle
看看如何收集

00:39:38.166 --> 00:39:40.096 A:middle
你的 App 里

00:39:40.096 --> 00:39:42.306 A:middle
连接的指标

00:39:43.356 --> 00:39:45.726 A:middle
收集指标非常重要

00:39:46.876 --> 00:39:50.006 A:middle
当你给 App 或服务器

00:39:50.006 --> 00:39:52.836 A:middle
添加新功能

00:39:52.836 --> 00:39:54.736 A:middle
以实现更好的效果时

00:39:55.446 --> 00:39:57.546 A:middle
它让你确认这些功能

00:39:57.546 --> 00:39:58.656 A:middle
确实在发挥作用

00:39:58.656 --> 00:40:00.566 A:middle
你确实实现了自己想要的效果

00:40:01.526 --> 00:40:03.756 A:middle
它可以帮助你发现 

00:40:04.346 --> 00:40:06.196 A:middle
用户在真实使用中

00:40:06.196 --> 00:40:08.016 A:middle
可能遭遇的问题

00:40:08.016 --> 00:40:12.056 A:middle
这些问题在设计时并没有发现

00:40:12.516 --> 00:40:14.606 A:middle
今年我们有很多

00:40:14.606 --> 00:40:16.206 A:middle
新的指标

00:40:16.206 --> 00:40:17.696 A:middle
帮你更好地分析连接

00:40:18.446 --> 00:40:20.426 A:middle
URLSession 已经有了很多

00:40:20.426 --> 00:40:22.236 A:middle
很好的指标

00:40:22.236 --> 00:40:23.476 A:middle
但是其实还有更多

00:40:23.546 --> 00:40:24.996 A:middle
第一次 在 Network.framework 里

00:40:24.996 --> 00:40:26.496 A:middle
你可以检查连接

00:40:26.496 --> 00:40:28.286 A:middle
更全面地了解

00:40:28.286 --> 00:40:31.166 A:middle
它们的表现

00:40:32.926 --> 00:40:35.326 A:middle
在 URLSession 中

00:40:35.326 --> 00:40:37.016 A:middle
你已经得到一个 

00:40:37.286 --> 00:40:40.896 A:middle
DNS TCP TLS 和 HTTP 消息的

00:40:40.896 --> 00:40:43.016 A:middle
时间细分

00:40:44.456 --> 00:40:46.086 A:middle
现在你可以

00:40:46.386 --> 00:40:48.726 A:middle
在你的 App 里自检

00:40:49.706 --> 00:40:53.006 A:middle
更多的连接属性

00:40:53.006 --> 00:40:54.146 A:middle
和个人请求和响应 

00:40:54.146 --> 00:40:56.546 A:middle
正在发送的数据

00:40:58.816 --> 00:41:00.376 A:middle
在 Network.framework 里

00:41:00.376 --> 00:41:01.856 A:middle
你可以访问

00:41:01.856 --> 00:41:03.506 A:middle
连接建立报告

00:41:03.506 --> 00:41:06.396 A:middle
它总结了连接中发生的一切

00:41:06.396 --> 00:41:08.966 A:middle
以及数据传输报告

00:41:08.966 --> 00:41:10.946 A:middle
让你可以查看

00:41:10.946 --> 00:41:12.236 A:middle
连接过程中

00:41:12.346 --> 00:41:15.036 A:middle
各个时间段的性能

00:41:15.106 --> 00:41:16.666 A:middle
很多这些过程

00:41:16.666 --> 00:41:17.836 A:middle
同时进行

00:41:18.426 --> 00:41:21.546 A:middle
我们先从 URLSession 开始

00:41:21.996 --> 00:41:25.116 A:middle
我要提醒大家

00:41:25.116 --> 00:41:26.596 A:middle
URLSession 里所有的指标

00:41:26.596 --> 00:41:27.356 A:middle
在 didFinishCollecting 指标

00:41:27.356 --> 00:41:30.116 A:middle
代理调用里 都是可用的

00:41:32.096 --> 00:41:34.086 A:middle
这里有一些

00:41:34.086 --> 00:41:36.016 A:middle
你可以访问的新东西

00:41:36.016 --> 00:41:37.326 A:middle
连接的端点

00:41:38.276 --> 00:41:41.236 A:middle
本地和远程地址以及端口

00:41:41.646 --> 00:41:43.756 A:middle
你还可以查看

00:41:43.756 --> 00:41:45.036 A:middle
安全属性

00:41:45.396 --> 00:41:48.836 A:middle
有没有用 TLS 1.3

00:41:48.836 --> 00:41:50.986 A:middle
它是 TLS 最新的 最安全的 

00:41:50.986 --> 00:41:52.436 A:middle
性能最好的版本

00:41:52.436 --> 00:41:56.666 A:middle
你还可以用它查看路径属性

00:41:57.636 --> 00:41:59.546 A:middle
它会告诉你 比如说

00:41:59.796 --> 00:42:01.606 A:middle
你的连接用的是

00:42:01.606 --> 00:42:03.446 A:middle
约束低数据模式网络

00:42:03.446 --> 00:42:05.656 A:middle
还是一个

00:42:05.656 --> 00:42:07.586 A:middle
比较贵的蜂窝数据网络

00:42:10.216 --> 00:42:14.586 A:middle
Network.framework 里的等价指标

00:42:14.586 --> 00:42:15.506 A:middle
是在建立报告里面的

00:42:16.346 --> 00:42:17.776 A:middle
每当连接进入稳定状态

00:42:17.776 --> 00:42:20.816 A:middle
你就可以使用这些指标

00:42:20.926 --> 00:42:23.416 A:middle
这会给你一个细分

00:42:23.486 --> 00:42:26.426 A:middle
你的 DNS 次数 

00:42:26.426 --> 00:42:29.216 A:middle
协议和 TCP 和 TLS 的握手

00:42:29.216 --> 00:42:31.006 A:middle
以及你是否使用了代理

00:42:31.536 --> 00:42:33.576 A:middle
在代码里它看起来是这样的

00:42:33.856 --> 00:42:35.476 A:middle
获取连接 并调用

00:42:35.676 --> 00:42:37.146 A:middle
requestEstablishmentReport

00:42:37.806 --> 00:42:39.886 A:middle
这里有一个队列

00:42:39.886 --> 00:42:41.516 A:middle
它会把报告加入到队列里

00:42:42.696 --> 00:42:43.986 A:middle
有了这个 你就可以查看

00:42:43.986 --> 00:42:45.776 A:middle
连接花费的所有时间 

00:42:46.296 --> 00:42:49.626 A:middle
你可以查看各个解决步骤

00:42:49.836 --> 00:42:51.306 A:middle
如果一个 Bonjour 名称连接到你

00:42:51.306 --> 00:42:53.416 A:middle
它可能会解析 Bonjour 名称

00:42:53.416 --> 00:42:55.056 A:middle
为主机名

00:42:55.056 --> 00:42:56.886 A:middle
再把主机名解析为地址

00:42:56.886 --> 00:42:58.756 A:middle
你可以查看

00:42:58.786 --> 00:43:00.626 A:middle
每个步骤的时间细分

00:43:01.136 --> 00:43:03.806 A:middle
你还可以查看

00:43:03.806 --> 00:43:06.286 A:middle
TCP 的 TLS 的 

00:43:06.346 --> 00:43:08.256 A:middle
和往返次数的

00:43:08.256 --> 00:43:09.126 A:middle
单独计时

00:43:09.346 --> 00:43:13.476 A:middle
我想强调一点

00:43:13.476 --> 00:43:15.386 A:middle
这一点对于连接建立的

00:43:15.386 --> 00:43:16.566 A:middle
整体表现来说

00:43:16.566 --> 00:43:18.936 A:middle
非常重要

00:43:18.936 --> 00:43:20.756 A:middle
这一点就是它 

00:43:20.886 --> 00:43:23.376 A:middle
解析 DNS 的时间

00:43:23.376 --> 00:43:25.166 A:middle
以及 DNS 解析的来源

00:43:27.386 --> 00:43:30.286 A:middle
很多服务器 

00:43:30.286 --> 00:43:32.876 A:middle
只有很短的时间 

00:43:32.876 --> 00:43:34.046 A:middle
在 DNS 记录上配置

00:43:34.446 --> 00:43:36.846 A:middle
它们这样做的目的是

00:43:36.846 --> 00:43:39.866 A:middle
当服务器发生故障

00:43:39.866 --> 00:43:40.886 A:middle
或者想在另一个 IP 地址上

00:43:40.946 --> 00:43:43.246 A:middle
平衡负载时

00:43:43.246 --> 00:43:44.956 A:middle
它可以快速改变 IP 地址记录

00:43:44.956 --> 00:43:47.546 A:middle
调整客户端

00:43:47.546 --> 00:43:49.056 A:middle
使用新地址

00:43:50.166 --> 00:43:52.116 A:middle
但是 缺点是

00:43:52.116 --> 00:43:54.546 A:middle
这会影响客户端性能

00:43:55.736 --> 00:43:57.666 A:middle
在很短的时间内

00:43:57.666 --> 00:43:59.546 A:middle
客户端需要往返

00:43:59.616 --> 00:44:01.646 A:middle
做 DNS 域名解析

00:44:01.646 --> 00:44:04.236 A:middle
请求你要连接的

00:44:04.236 --> 00:44:06.766 A:middle
主机名地址

00:44:07.286 --> 00:44:11.066 A:middle
对于要连接到

00:44:11.366 --> 00:44:12.866 A:middle
高延迟链接的客户端来说 

00:44:12.866 --> 00:44:13.636 A:middle
这就特别糟糕

00:44:14.286 --> 00:44:16.396 A:middle
这将会延长连接时间

00:44:16.396 --> 00:44:17.946 A:middle
增加数百毫秒

00:44:17.946 --> 00:44:19.156 A:middle
甚至好几秒

00:44:19.786 --> 00:44:22.126 A:middle
最糟糕的是 大部分时间  

00:44:22.126 --> 00:44:23.816 A:middle
服务器地址并没有改变

00:44:23.816 --> 00:44:26.256 A:middle
所以这就是一个

00:44:26.256 --> 00:44:27.296 A:middle
没用的往返

00:44:28.426 --> 00:44:33.016 A:middle
我们 去年发布了 Optimistic DNS

00:44:33.016 --> 00:44:34.256 A:middle
可以解决这个问题

00:44:35.786 --> 00:44:37.636 A:middle
Optimistic DNS 

00:44:37.636 --> 00:44:39.636 A:middle
让你连接到 

00:44:39.916 --> 00:44:42.376 A:middle
主机名的最后一个

00:44:42.376 --> 00:44:43.846 A:middle
已知良好的 IP 地址

00:44:44.816 --> 00:44:49.766 A:middle
同时请求主机名的当前地址

00:44:51.146 --> 00:44:52.776 A:middle
大部分情况下

00:44:52.776 --> 00:44:55.246 A:middle
都没有什么改变

00:44:55.246 --> 00:44:56.456 A:middle
连接还是建立在

00:44:56.456 --> 00:44:58.356 A:middle
之前的 IP 地址

00:44:58.676 --> 00:45:00.016 A:middle
如果有变化

00:45:00.016 --> 00:45:01.266 A:middle
你会得到一个新的 IP 地址

00:45:01.266 --> 00:45:02.776 A:middle
转而连接到新地址

00:45:03.376 --> 00:45:06.676 A:middle
我们一直在测试它

00:45:07.206 --> 00:45:09.456 A:middle
它真的是一个好方法

00:45:09.456 --> 00:45:11.126 A:middle
所以今年 对于使用 

00:45:11.126 --> 00:45:12.976 A:middle
Network.framework 

00:45:12.976 --> 00:45:14.156 A:middle
和 URLSession 的连接

00:45:14.156 --> 00:45:14.936 A:middle
它是默认开启的

00:45:16.736 --> 00:45:17.866 A:middle
当你查看

00:45:17.866 --> 00:45:19.146 A:middle
连接报告时 

00:45:19.146 --> 00:45:21.046 A:middle
你可以通过查看来源

00:45:21.046 --> 00:45:23.636 A:middle
辨认你用的是不是 Optimistic DNS

00:45:24.116 --> 00:45:25.216 A:middle
如果是来自过期缓存

00:45:25.216 --> 00:45:27.746 A:middle
这就意味着

00:45:27.746 --> 00:45:30.966 A:middle
我们用的是 Optimistic DNS

00:45:31.726 --> 00:45:34.566 A:middle
我想向大家展示一下

00:45:34.566 --> 00:45:36.416 A:middle
如何使用指标

00:45:36.416 --> 00:45:38.196 A:middle
查看连接性能

00:45:38.196 --> 00:45:39.926 A:middle
以及 Optimistic DNS

00:45:39.926 --> 00:45:47.196 A:middle
和 TLS 1.3 的优点

00:45:47.426 --> 00:45:49.766 A:middle
好 我这里有一个 App

00:45:49.766 --> 00:45:51.556 A:middle
一款非常基本的 App

00:45:51.556 --> 00:45:54.216 A:middle
用来收集指标

00:45:54.346 --> 00:45:57.286 A:middle
只需要对一个给定网站运行 probe

00:45:57.756 --> 00:46:00.186 A:middle
好 有了

00:46:00.186 --> 00:46:01.836 A:middle
我点按“Run Probe”

00:46:01.836 --> 00:46:03.306 A:middle
连接上了 非常快

00:46:03.306 --> 00:46:07.916 A:middle
Wi-Fi 信号非常好

00:46:08.506 --> 00:46:10.336 A:middle
如果你想在一个

00:46:10.336 --> 00:46:12.176 A:middle
更现实的场景中测试它

00:46:12.176 --> 00:46:13.496 A:middle
或者看它在

00:46:13.496 --> 00:46:15.606 A:middle
不同网络条件下的表现

00:46:16.146 --> 00:46:18.026 A:middle
你现在可以到设备内部

00:46:18.026 --> 00:46:20.806 A:middle
在 Xcode 的模拟器面板中

00:46:20.806 --> 00:46:23.226 A:middle
访问设备条件

00:46:23.646 --> 00:46:25.626 A:middle
模拟不同的网络连接环境

00:46:25.806 --> 00:46:26.886 A:middle
这样你就可以看到

00:46:26.886 --> 00:46:29.226 A:middle
不同的情景下

00:46:29.446 --> 00:46:30.416 A:middle
用户的体验 [掌声]

00:46:31.196 --> 00:46:33.286 A:middle
这很棒

00:46:35.736 --> 00:46:37.126 A:middle
我们看一下如果是高延迟 DNS 链接

00:46:37.296 --> 00:46:39.096 A:middle
会发生什么

00:46:40.256 --> 00:46:41.826 A:middle
我点按 Start  

00:46:41.826 --> 00:46:42.936 A:middle
可以看出它在运行

00:46:42.936 --> 00:46:45.496 A:middle
因为左上角有一个

00:46:45.496 --> 00:46:46.426 A:middle
灰色框

00:46:47.546 --> 00:46:50.716 A:middle
现在 再次运行 probe

00:46:50.716 --> 00:46:53.086 A:middle
很快

00:46:53.796 --> 00:46:55.926 A:middle
很好 你会发现 

00:46:55.926 --> 00:46:57.486 A:middle
它来自过期缓存

00:46:57.966 --> 00:46:59.226 A:middle
也就是说 我们用的是

00:46:59.276 --> 00:47:00.616 A:middle
Optimistic DNS

00:47:01.486 --> 00:47:04.476 A:middle
Optimistic DNS 是默认运行的

00:47:04.476 --> 00:47:06.196 A:middle
如果你觉得

00:47:06.196 --> 00:47:07.626 A:middle
它不适合你的服务器的话

00:47:07.626 --> 00:47:09.236 A:middle
但是你可以关掉它

00:47:09.956 --> 00:47:11.186 A:middle
再次运行 probe 

00:47:11.836 --> 00:47:14.796 A:middle
你可以感受到几秒钟过去了

00:47:15.796 --> 00:47:18.606 A:middle
也许我有点夸张

00:47:18.696 --> 00:47:19.936 A:middle
希望你的用户不会遭遇

00:47:19.936 --> 00:47:21.986 A:middle
3 秒 DNS 延迟的情况

00:47:21.986 --> 00:47:23.526 A:middle
但是两种情况是很不一样的

00:47:24.146 --> 00:47:26.956 A:middle
现在我们尝试一个

00:47:26.956 --> 00:47:30.086 A:middle
更加现实的场景

00:47:30.086 --> 00:47:31.836 A:middle
比如常用的 3G 网络

00:47:32.496 --> 00:47:35.956 A:middle
启动

00:47:35.956 --> 00:47:37.166 A:middle
再一次运行 probe 

00:47:37.766 --> 00:47:40.436 A:middle
不像第一次运行的时候

00:47:40.436 --> 00:47:41.356 A:middle
那么快了

00:47:42.096 --> 00:47:43.726 A:middle
总的来说 你可以看到

00:47:43.726 --> 00:47:45.866 A:middle
建立连接

00:47:45.866 --> 00:47:46.846 A:middle
要 600 毫秒

00:47:47.306 --> 00:47:51.786 A:middle
TLS 花了不到

00:47:51.786 --> 00:47:53.416 A:middle
300 毫秒

00:47:53.416 --> 00:47:56.826 A:middle
也就是说差不多一半

00:47:57.016 --> 00:47:59.006 A:middle
所以我们的服务器被配置成

00:47:59.006 --> 00:48:00.506 A:middle
支持 TLS 1.3

00:48:00.906 --> 00:48:04.166 A:middle
现在 TLS 1.3 通常只需要一个往返

00:48:04.206 --> 00:48:06.486 A:middle
就可以完成一次握手

00:48:06.776 --> 00:48:08.146 A:middle
这是很大的进步

00:48:09.086 --> 00:48:10.286 A:middle
但是如果你的服务器

00:48:10.286 --> 00:48:11.946 A:middle
不支持 TLS 1.3

00:48:11.946 --> 00:48:14.806 A:middle
如果它只支持 TLS 1.2 

00:48:14.806 --> 00:48:18.416 A:middle
如果你 App 上使用的 API 

00:48:18.416 --> 00:48:22.476 A:middle
不支持 TLS 1.3

00:48:22.476 --> 00:48:24.836 A:middle
你可能会看到这种情况

00:48:24.836 --> 00:48:27.326 A:middle
TLS 自己花去 500 毫秒

00:48:27.616 --> 00:48:30.246 A:middle
多进行一轮往返

00:48:31.166 --> 00:48:31.906 A:middle
你可以看到

00:48:31.906 --> 00:48:34.286 A:middle
连接时间已经超过了

00:48:34.286 --> 00:48:35.576 A:middle
四分之三秒

00:48:35.656 --> 00:48:36.496 A:middle
差不多要一秒了

00:48:36.926 --> 00:48:37.946 A:middle
如果你有很多连接

00:48:37.946 --> 00:48:39.796 A:middle
用户会感受到

00:48:39.796 --> 00:48:42.466 A:middle
更久的延迟

00:48:43.216 --> 00:48:44.376 A:middle
所以我们建议

00:48:44.376 --> 00:48:45.326 A:middle
每当你测试 App 时

00:48:45.326 --> 00:48:47.576 A:middle
通过网络连接模拟器

00:48:47.576 --> 00:48:49.276 A:middle
运行它

00:48:49.276 --> 00:48:50.856 A:middle
测试一些场景

00:48:50.856 --> 00:48:53.026 A:middle
验证 App 是否运行良好

00:49:02.476 --> 00:49:04.546 A:middle
和建立连接后的

00:49:04.546 --> 00:49:07.186 A:middle
数据传输有关

00:49:08.356 --> 00:49:10.576 A:middle
所以在 URLSession 中 

00:49:10.576 --> 00:49:12.456 A:middle
现在你可以访问更多指标

00:49:12.456 --> 00:49:13.566 A:middle
数量相当于

00:49:13.566 --> 00:49:15.496 A:middle
你发送到请求的

00:49:15.496 --> 00:49:17.186 A:middle
Header 和 Body 的字节数

00:49:17.186 --> 00:49:19.606 A:middle
以及你从

00:49:19.606 --> 00:49:21.356 A:middle
请求的 Header 和 Body

00:49:21.356 --> 00:49:24.686 A:middle
收到的字节数

00:49:25.606 --> 00:49:27.286 A:middle
如果你选的是不同的 URL 

00:49:27.286 --> 00:49:29.866 A:middle
在一个低数据模式网络环境 

00:49:30.126 --> 00:49:32.916 A:middle
来下载较少的数据

00:49:32.916 --> 00:49:35.946 A:middle
这个就非常重要 

00:49:36.026 --> 00:49:37.196 A:middle
你要用它确认 

00:49:37.256 --> 00:49:40.106 A:middle
确实存储了用户的字节

00:49:42.796 --> 00:49:44.616 A:middle
在 Network.framework 中

00:49:44.616 --> 00:49:46.506 A:middle
你现在可以访问数据传输报告

00:49:46.506 --> 00:49:48.426 A:middle
这个报告总结了运行情况

00:49:48.426 --> 00:49:52.886 A:middle
包括字节 数据包 

00:49:53.416 --> 00:49:56.606 A:middle
和给定时间段内的往返次数

00:49:56.986 --> 00:49:58.136 A:middle
多个这些过程 

00:49:58.136 --> 00:49:59.156 A:middle
会同时运行 

00:49:59.246 --> 00:50:00.976 A:middle
并且它们要与 App 活动相对应

00:50:01.236 --> 00:50:03.116 A:middle
所以如果你要突然发送一段流

00:50:03.116 --> 00:50:06.236 A:middle
把它放入数据传输报告里

00:50:06.896 --> 00:50:11.446 A:middle
它不如闲置时间报告有趣

00:50:11.976 --> 00:50:14.176 A:middle
你要做的是  

00:50:14.176 --> 00:50:15.956 A:middle
在任何时间 你都可以在连接上

00:50:15.956 --> 00:50:18.776 A:middle
调用 startDataTransferReport 

00:50:19.286 --> 00:50:21.896 A:middle
首先 收集连接的

00:50:21.896 --> 00:50:23.366 A:middle
运行情况数据

00:50:24.336 --> 00:50:25.946 A:middle
发完一堆数据后

00:50:25.946 --> 00:50:27.606 A:middle
调用 collect

00:50:28.316 --> 00:50:29.746 A:middle
这会总结所有数据

00:50:29.746 --> 00:50:31.606 A:middle
给你一个报告

00:50:32.836 --> 00:50:34.936 A:middle
如果你用的是多路径协议

00:50:34.996 --> 00:50:36.996 A:middle
它会给你一个细分 

00:50:36.996 --> 00:50:39.446 A:middle
多路径线程

00:50:39.446 --> 00:50:41.456 A:middle
每条链接上正在使用的

00:50:41.456 --> 00:50:42.976 A:middle
数量细分

00:50:43.896 --> 00:50:45.006 A:middle
但是你们很多人 

00:50:45.006 --> 00:50:47.316 A:middle
只对聚合路径报告有兴趣

00:50:48.716 --> 00:50:50.506 A:middle
这里你可以查看

00:50:50.506 --> 00:50:51.566 A:middle
发送和接收的数据包数

00:50:51.566 --> 00:50:53.386 A:middle
传输的字节数

00:50:53.386 --> 00:50:55.036 A:middle
以及你观察到的

00:50:55.036 --> 00:50:57.336 A:middle
往返时间详细信息

00:50:58.806 --> 00:51:00.756 A:middle
这就是指标

00:51:00.756 --> 00:51:02.306 A:middle
我们特别想看到大家

00:51:02.306 --> 00:51:04.316 A:middle
用更多的指标

00:51:04.416 --> 00:51:06.076 A:middle
并且提升 App 的性能

00:51:06.966 --> 00:51:08.726 A:middle
现在我想把 Stuart 请上台

00:51:08.726 --> 00:51:10.386 A:middle
他将为大家带来

00:51:10.386 --> 00:51:11.856 A:middle
好的建议和新的更新

00:51:12.516 --> 00:51:14.866 A:middle
[掌声]

00:51:15.366 --> 00:51:16.116 A:middle
&gt;&gt; 谢谢你 Tommy

00:51:17.516 --> 00:51:19.286 A:middle
很荣幸

00:51:19.606 --> 00:51:21.306 A:middle
我能总结

00:51:21.306 --> 00:51:23.326 A:middle
我的同伴们 

00:51:23.326 --> 00:51:24.766 A:middle
用两个小时介绍的

00:51:24.766 --> 00:51:26.046 A:middle
联网信息

00:51:26.916 --> 00:51:29.986 A:middle
首先 我要介绍

00:51:29.986 --> 00:51:30.906 A:middle
Mac 版的 iPad App

00:51:31.956 --> 00:51:33.666 A:middle
我知道你们很多人对此很感兴趣

00:51:34.206 --> 00:51:36.936 A:middle
说到联网在 Apple 平台上

00:51:36.936 --> 00:51:38.726 A:middle
没有多大的区别

00:51:39.536 --> 00:51:41.056 A:middle
你需要注意的一件事是

00:51:41.056 --> 00:51:44.626 A:middle
在你的 Xcode 设置里

00:51:44.626 --> 00:51:47.166 A:middle
当你选择 Mac 的复选框时

00:51:47.166 --> 00:51:51.826 A:middle
现在你可以看到更多新选项

00:51:52.216 --> 00:51:56.306 A:middle
默认允许传出连接

00:51:56.366 --> 00:51:57.636 A:middle
如果你也想要传入连接

00:51:57.636 --> 00:51:59.916 A:middle
你要勾选那个复选框

00:52:07.976 --> 00:52:09.396 A:middle
我们有新的联网功能

00:52:11.036 --> 00:52:12.946 A:middle
用 AVFoundation 

00:52:12.946 --> 00:52:16.016 A:middle
做音频流的 App

00:52:16.016 --> 00:52:18.756 A:middle
现在可以使用直接联网

00:52:18.756 --> 00:52:20.696 A:middle
只要用的是 URLSession

00:52:21.046 --> 00:52:22.136 A:middle
或 Network.framework

00:52:23.036 --> 00:52:24.576 A:middle
Sockets 不可用

00:52:30.156 --> 00:52:33.226 A:middle
我们也介绍了 TLS 1.3

00:52:33.636 --> 00:52:35.196 A:middle
它会给你带来很多好处

00:52:36.136 --> 00:52:38.866 A:middle
TLS 1.3 联网性能更出色

00:52:39.036 --> 00:52:42.106 A:middle
TLS 1.2 一般需要两个往返 

00:52:42.106 --> 00:52:43.466 A:middle
才能建立一个连接

00:52:43.546 --> 00:52:46.806 A:middle
TLS 1.3 基本只需一个往返

00:52:48.146 --> 00:52:51.646 A:middle
TLS 1.2 用的是加密算法

00:52:51.646 --> 00:52:53.236 A:middle
我们曾经认为

00:52:53.236 --> 00:52:54.896 A:middle
加密算法很好

00:52:54.896 --> 00:52:56.586 A:middle
但是出现了问题

00:52:56.586 --> 00:52:58.756 A:middle
这不只是一个学术问题

00:52:58.806 --> 00:53:00.486 A:middle
这些都是实践出来的

00:53:01.676 --> 00:53:03.566 A:middle
这些问题都不会出现在

00:53:03.566 --> 00:53:07.026 A:middle
TLS 1.3 中

00:53:07.026 --> 00:53:08.866 A:middle
TLS 1.3 中所有的加密算法

00:53:08.866 --> 00:53:13.696 A:middle
都支持相关数据的认证加密

00:53:13.986 --> 00:53:14.996 A:middle
增强安全性

00:53:16.176 --> 00:53:18.626 A:middle
最后 大家都知道

00:53:18.626 --> 00:53:20.466 A:middle
对于 Apple 来说 隐私非常重要

00:53:20.986 --> 00:53:23.416 A:middle
TLS 1.3 在隐私方面做得更好

00:53:24.176 --> 00:53:26.796 A:middle
在 TLS 1.2 中 

00:53:27.006 --> 00:53:30.166 A:middle
很多 Header 域和证书

00:53:30.166 --> 00:53:30.706 A:middle
都是明文发送的

00:53:31.186 --> 00:53:34.076 A:middle
在 TLS 1.3 中都加密了

00:53:34.686 --> 00:53:38.276 A:middle
所以我们希望

00:53:38.276 --> 00:53:39.736 A:middle
大家都开始 

00:53:39.736 --> 00:53:41.856 A:middle
在 App 上用 TLS 1.3

00:53:41.856 --> 00:53:43.456 A:middle
当然也要确保服务器已更新 

00:53:43.456 --> 00:53:46.996 A:middle
支持 TLS 1.3

00:53:47.616 --> 00:53:49.476 A:middle
现在 大家都知道了

00:53:49.476 --> 00:53:50.476 A:middle
对于 Apple 来说隐私的重要性

00:53:51.146 --> 00:53:52.936 A:middle
我们意识到

00:53:52.936 --> 00:53:56.416 A:middle
接入 Wi-Fi

00:53:56.416 --> 00:53:59.286 A:middle
可能会暴露位置

00:53:59.916 --> 00:54:02.936 A:middle
从现在开始   

00:54:02.936 --> 00:54:05.066 A:middle
要访问那个 Wi-Fi 信息

00:54:05.456 --> 00:54:07.586 A:middle
和获取其他位置信息一样

00:54:07.586 --> 00:54:09.736 A:middle
你需要同样的权限

00:54:10.786 --> 00:54:12.626 A:middle
第一步是 

00:54:12.626 --> 00:54:14.716 A:middle
在 Xcode 里

00:54:14.716 --> 00:54:16.846 A:middle
添加访问 Wi-Fi 信息的能力

00:54:16.846 --> 00:54:18.666 A:middle
添加权限到你的项目

00:54:18.666 --> 00:54:22.266 A:middle
然后你的 App 必须满足

00:54:22.266 --> 00:54:23.706 A:middle
其他三个标准之一

00:54:23.706 --> 00:54:26.086 A:middle
其一 如果用户已经给了你的 App

00:54:26.386 --> 00:54:28.496 A:middle
位置访问权限 

00:54:28.496 --> 00:54:30.416 A:middle
那么你可以访问 Wi-Fi 网络信息

00:54:31.556 --> 00:54:33.356 A:middle
其二 如果你的 App 是设备上

00:54:33.356 --> 00:54:35.766 A:middle
当前启用的 VPN App

00:54:36.376 --> 00:54:37.816 A:middle
你可以访问信息

00:54:37.986 --> 00:54:40.146 A:middle
最后 如果你的 App 

00:54:40.146 --> 00:54:42.276 A:middle
是任何热点配置 App 

00:54:42.676 --> 00:54:44.036 A:middle
它可以访问信息 

00:54:44.036 --> 00:54:45.396 A:middle
但是只能访问

00:54:45.396 --> 00:54:47.276 A:middle
配置的网络信息

00:54:48.496 --> 00:54:49.896 A:middle
如果想要了解更多

00:54:49.896 --> 00:54:51.436 A:middle
可以看一下 Wi-Fi 框架

00:54:52.066 --> 00:54:55.996 A:middle
今天你已经听到过很多次了

00:54:55.996 --> 00:54:57.096 A:middle
最后我要再提一下

00:54:57.096 --> 00:55:00.356 A:middle
使用网络模拟工具的重要性

00:55:02.166 --> 00:55:03.716 A:middle
当你在 Mac 上开发 App 时

00:55:03.716 --> 00:55:05.446 A:middle
如果模拟器是千兆以太网

00:55:05.446 --> 00:55:08.666 A:middle
或在环回接口上

00:55:08.666 --> 00:55:10.296 A:middle
与本地服务器对话时

00:55:10.296 --> 00:55:12.816 A:middle
就会很简单

00:55:13.396 --> 00:55:15.686 A:middle
如果你的服务器没有延迟

00:55:15.786 --> 00:55:18.216 A:middle
带宽是无限的

00:55:18.776 --> 00:55:20.496 A:middle
那毫无疑问 性能会很好

00:55:20.496 --> 00:55:23.276 A:middle
但是如果你按这种条件搭建 App

00:55:23.276 --> 00:55:25.996 A:middle
那就大错特错了

00:55:25.996 --> 00:55:27.836 A:middle
当用户真正开始

00:55:27.836 --> 00:55:29.186 A:middle
使用你的 App 时 

00:55:29.186 --> 00:55:30.336 A:middle
你就会发现性能并不好

00:55:31.006 --> 00:55:33.566 A:middle
如果你从 

00:55:33.826 --> 00:55:36.736 A:middle
一开始开发 App

00:55:37.406 --> 00:55:40.706 A:middle
就养成习惯 

00:55:40.706 --> 00:55:44.056 A:middle
到设备情况里选择现实的

00:55:44.056 --> 00:55:46.396 A:middle
网络连接环境 

00:55:46.396 --> 00:55:47.626 A:middle
一直模拟真实的网络环境

00:55:47.936 --> 00:55:49.516 A:middle
检测运行你的 App

00:55:49.516 --> 00:55:52.866 A:middle
那么那些 Bug

00:55:52.866 --> 00:55:57.106 A:middle
就根本不会出现

00:55:57.186 --> 00:55:59.056 A:middle
多年来 我们一直向大家传递的 

00:55:59.056 --> 00:56:01.706 A:middle
另一个信息是

00:56:01.706 --> 00:56:04.966 A:middle
避免启动时检查

00:56:05.186 --> 00:56:08.936 A:middle
使用蜂窝数据

00:56:08.936 --> 00:56:10.696 A:middle
或较贵的网络之类的约束

00:56:10.696 --> 00:56:13.216 A:middle
实现更好的控制

00:56:13.366 --> 00:56:14.756 A:middle
这样就简单多了

00:56:14.926 --> 00:56:16.606 A:middle
一旦你开始这样开发 App

00:56:16.606 --> 00:56:18.606 A:middle
你就会问自己

00:56:18.606 --> 00:56:19.986 A:middle
为什么之前要启动时检查

00:56:20.236 --> 00:56:22.326 A:middle
而且启动时检查

00:56:22.326 --> 00:56:24.156 A:middle
并不可靠 

00:56:24.156 --> 00:56:25.636 A:middle
因为它们总是带来问题

00:56:26.526 --> 00:56:28.666 A:middle
我举个例子

00:56:28.666 --> 00:56:30.556 A:middle
来说明这一点

00:56:30.556 --> 00:56:32.776 A:middle
这个是我很喜欢的一个 App

00:56:33.316 --> 00:56:36.136 A:middle
因为要说明这个情况 

00:56:36.636 --> 00:56:38.356 A:middle
我故意做了一个

00:56:38.626 --> 00:56:41.366 A:middle
夸张的例子 看看

00:56:41.366 --> 00:56:42.506 A:middle
如果这个 App 写的不好 

00:56:42.506 --> 00:56:43.166 A:middle
会发生什么

00:56:43.736 --> 00:56:45.036 A:middle
这是在告诉用户

00:56:45.176 --> 00:56:46.646 A:middle
确保连接了 Wi-Fi 

00:56:46.646 --> 00:56:47.376 A:middle
然后点按按钮

00:56:48.056 --> 00:56:49.536 A:middle
但是用户并不能

00:56:49.536 --> 00:56:51.836 A:middle
控制选择

00:56:51.836 --> 00:56:52.926 A:middle
哪条联网路径

00:56:53.366 --> 00:56:55.556 A:middle
他们一般会

00:56:55.556 --> 00:56:57.406 A:middle
找 Wi-Fi 栏 希望连接到最佳网络

00:56:58.226 --> 00:57:00.016 A:middle
但是今天你知道了

00:57:01.536 --> 00:57:03.336 A:middle
在测试之前 

00:57:03.336 --> 00:57:06.776 A:middle
你不可能知道 Wi-Fi 情况是什么样

00:57:07.516 --> 00:57:09.696 A:middle
设备可能以为自己连接了 Wi-Fi

00:57:09.696 --> 00:57:11.286 A:middle
但是当它想用的时候

00:57:11.286 --> 00:57:13.396 A:middle
发现  Wi-Fi 不能用

00:57:13.496 --> 00:57:15.906 A:middle
现在 当 Wi-Fi Assist

00:57:15.906 --> 00:57:18.036 A:middle
把你从 Wi-Fi 转换到蜂窝数据时

00:57:18.036 --> 00:57:19.776 A:middle
那些 Wi-Fi 栏都消失了

00:57:20.236 --> 00:57:21.496 A:middle
但是已经晚了

00:57:21.496 --> 00:57:22.746 A:middle
你已经开始连接了

00:57:23.546 --> 00:57:28.816 A:middle
所以不要让用户猜测

00:57:29.256 --> 00:57:30.436 A:middle
不要只是

00:57:30.436 --> 00:57:31.136 A:middle
期待最优的网络

00:57:31.706 --> 00:57:32.576 A:middle
我来演示一下

00:57:32.576 --> 00:57:35.096 A:middle
这个 App 实际上是什么样

00:57:35.386 --> 00:57:36.886 A:middle
它将连接限制到

00:57:37.796 --> 00:57:40.576 A:middle
不允许访问蜂窝数据

00:57:41.176 --> 00:57:44.816 A:middle
在 iOS 13 里启动它

00:57:44.816 --> 00:57:47.186 A:middle
实际上 它使用

00:57:47.186 --> 00:57:49.036 A:middle
allowsExpensiveNetworkAccess 控件

00:57:49.186 --> 00:57:50.956 A:middle
让系统选择

00:57:51.096 --> 00:57:52.486 A:middle
哪个是较贵的网络

00:57:53.666 --> 00:57:55.226 A:middle
它还设置

00:57:55.226 --> 00:57:57.076 A:middle
waitsForConnectivity 为真

00:57:57.466 --> 00:57:58.866 A:middle
这意味着 

00:57:59.196 --> 00:58:01.276 A:middle
App 不需要反复重试

00:58:01.586 --> 00:58:02.766 A:middle
系统会一直

00:58:02.766 --> 00:58:04.046 A:middle
耐心等待

00:58:04.046 --> 00:58:05.726 A:middle
直到成功连接

00:58:07.306 --> 00:58:09.876 A:middle
当 App 尝试连接时

00:58:09.876 --> 00:58:11.896 A:middle
如果没有 Wi-Fi

00:58:12.526 --> 00:58:14.506 A:middle
它的 taskIsWaitingForConnectivity 代理

00:58:14.506 --> 00:58:16.776 A:middle
会被调用 

00:58:16.776 --> 00:58:18.616 A:middle
这时它会显示 UI

00:58:18.616 --> 00:58:20.906 A:middle
让用户选择

00:58:20.906 --> 00:58:22.516 A:middle
要么移步到有 Wi-Fi 的地方

00:58:22.516 --> 00:58:23.986 A:middle
要么按下按钮

00:58:23.986 --> 00:58:25.576 A:middle
使用蜂窝数据

00:58:26.896 --> 00:58:29.126 A:middle
一些关于弃用的消息

00:58:30.236 --> 00:58:31.786 A:middle
如果还有人在用 PAC 文件 

00:58:31.786 --> 00:58:35.046 A:middle
用这种文件 或者 FTP URL 方案

00:58:35.226 --> 00:58:37.476 A:middle
要注意 我们已经不支持这些了

00:58:38.656 --> 00:58:40.366 A:middle
SPDY 曾是非常好的

00:58:40.366 --> 00:58:41.906 A:middle
实验协议

00:58:41.906 --> 00:58:44.176 A:middle
如果还有人用 SPDY 要注意

00:58:44.176 --> 00:58:46.496 A:middle
SPDY 现在已经被 HTTP 2 取代了

00:58:47.006 --> 00:58:48.786 A:middle
Apple 现在支持的是 HTTP 2

00:58:48.786 --> 00:58:50.726 A:middle
一切都应朝着这个方向发展

00:58:51.516 --> 00:58:54.066 A:middle
而且 Secure Transport 

00:58:54.066 --> 00:58:56.906 A:middle
不支持 TLS 1.3 

00:58:56.906 --> 00:58:59.636 A:middle
永远也不会支持 TLS 1.3 

00:58:59.636 --> 00:59:01.646 A:middle
这也是选择 URLSession 或

00:59:01.646 --> 00:59:02.536 A:middle
Network.framework 的另一原因

00:59:03.066 --> 00:59:08.156 A:middle
所以 总的来说 今天早晨

00:59:08.156 --> 00:59:10.606 A:middle
我们介绍了广域 Bonjour 发现  

00:59:10.606 --> 00:59:17.756 A:middle
以及如何发布一个

00:59:17.756 --> 00:59:18.796 A:middle
井字游戏 

00:59:19.076 --> 00:59:22.386 A:middle
有些人可能会想

00:59:22.386 --> 00:59:23.816 A:middle
serviceType_tictactoe

00:59:23.816 --> 00:59:26.796 A:middle
是否注册到了 Ayana

00:59:27.056 --> 00:59:28.786 A:middle
答案是肯定的

00:59:28.786 --> 00:59:29.716 A:middle
你可以去网站上看看 [笑声]

00:59:33.376 --> 00:59:34.736 A:middle
Tommy 介绍了

00:59:34.736 --> 00:59:37.086 A:middle
搭建协议框架

00:59:37.086 --> 00:59:39.436 A:middle
收集指标

00:59:39.436 --> 00:59:40.936 A:middle
让你写 App 变得更容易

00:59:41.396 --> 00:59:43.616 A:middle
也更容易考量性能

00:59:44.226 --> 00:59:48.226 A:middle
今天早晨 我们还讨论了

00:59:48.226 --> 00:59:50.506 A:middle
低数据模式

00:59:50.506 --> 00:59:52.206 A:middle
要尊重用户

00:59:52.206 --> 00:59:53.836 A:middle
何时保存数据的需求

00:59:54.526 --> 00:59:56.006 A:middle
我们还讨论了

00:59:56.006 --> 00:59:57.636 A:middle
结合 URLSession 

00:59:57.636 --> 00:59:59.866 A:middle
可以很好地链接异步操作

00:59:59.866 --> 01:00:01.976 A:middle
我们还讨论了 WebSocket

01:00:02.046 --> 01:00:04.776 A:middle
如果你的 App 是基于网页的

01:00:04.776 --> 01:00:06.466 A:middle
它用 WebSocket

01:00:06.466 --> 01:00:08.126 A:middle
和服务器交流

01:00:08.126 --> 01:00:09.726 A:middle
现在你可以在本地 iOS App 中

01:00:09.726 --> 01:00:11.876 A:middle
使用同一台服务器

01:00:12.886 --> 01:00:14.816 A:middle
Christoph Paasch 

01:00:14.816 --> 01:00:16.376 A:middle
介绍了所有的移动改进

01:00:16.376 --> 01:00:20.626 A:middle
通过多路径 TCP 和 Wi-Fi Assist 实现

01:00:21.486 --> 01:00:23.946 A:middle
关于这一点

01:00:24.456 --> 01:00:27.446 A:middle
你们很多人会知道 ACM SIGCOMM 

01:00:27.806 --> 01:00:30.906 A:middle
是世界上最重要的

01:00:31.116 --> 01:00:32.546 A:middle
网络研究学术会议

01:00:34.036 --> 01:00:35.686 A:middle
每年都有

01:00:35.686 --> 01:00:37.446 A:middle
网络系统奖

01:00:37.446 --> 01:00:39.366 A:middle
选出网络领域

01:00:39.366 --> 01:00:42.586 A:middle
最有影响力的成就

01:00:43.336 --> 01:00:45.286 A:middle
今年 今天

01:00:45.516 --> 01:00:47.536 A:middle
他们宣布 今年的奖颁给了 

01:00:47.996 --> 01:00:49.566 A:middle
Christoph Paasch

01:00:49.566 --> 01:00:51.676 A:middle
以及多路径 TCP 团队的其他人

01:00:52.516 --> 01:01:00.886 A:middle
[掌声]

01:01:01.386 --> 01:01:02.606 A:middle
我们希望在明天的

01:01:02.606 --> 01:01:04.376 A:middle
网络实验室看到大家

01:01:04.986 --> 01:01:07.036 A:middle
如果你们有人现在在写

01:01:07.036 --> 01:01:08.076 A:middle
网络内核扩展的话

01:01:08.076 --> 01:01:09.786 A:middle
明天一定要去参加

01:01:09.786 --> 01:01:11.746 A:middle
《Network Extensions for Modern macOS》

01:01:11.746 --> 01:01:13.976 A:middle
这一场会议 谢谢大家

01:01:14.516 --> 01:01:17.500 A:middle
[掌声]

