WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:06.640 --> 00:00:09.743 align:middle line:0
（自定义工具建模
建立更智能的工具）

00:00:12.813 --> 00:00:13.680 align:middle line:-1
谢谢

00:00:16.149 --> 00:00:18.252 align:middle line:-2
大家下午好
我是Chad Woolf

00:00:18.318 --> 00:00:20.220 align:middle line:-1
Apple的性能工具工程师

00:00:20.287 --> 00:00:24.291 align:middle line:-1
演讲421的主题是自定义工具建模

00:00:24.925 --> 00:00:26.894 align:middle line:-1
在自定义工具架构中

00:00:27.227 --> 00:00:30.030 align:middle line:-1
负责建模的是中间这个 建模模块

00:00:30.097 --> 00:00:32.266 align:middle line:-1
它是要推出

00:00:32.799 --> 00:00:35.035 align:middle line:-1
操作系统记录的原始事件

00:00:35.102 --> 00:00:37.905 align:middle line:-1
完成转换 创建可显示的事件

00:00:37.971 --> 00:00:42.543 align:middle line:-2
或导入另一个建模模块
给Air Instruments UI的工具

00:00:42.910 --> 00:00:46.046 align:middle line:-1
这个架构的完整介绍收录在

00:00:46.113 --> 00:00:48.549 align:middle line:-1
2018年“创建自定义工具”演讲

00:00:49.082 --> 00:00:50.450 align:middle line:-1
本场演讲的内容

00:00:50.517 --> 00:00:52.719 align:middle line:-1
重点关注的是

00:00:52.786 --> 00:00:54.488 align:middle line:-1
中间的这个 建模模块

00:00:55.222 --> 00:00:57.224 align:middle line:-1
建模模块对所有工具都很重要

00:00:57.291 --> 00:00:59.993 align:middle line:-2
包括这里的
Time Profiler

00:01:04.230 --> 00:01:07.034 align:middle line:-1
与内核记录的数据形式不一样

00:01:07.534 --> 00:01:09.636 align:middle line:-1
我们用建模模块进行转换

00:01:10.137 --> 00:01:12.806 align:middle line:-1
内核读取线程内容的样本时

00:01:12.873 --> 00:01:16.543 align:middle line:-1
会创建或捕捉一个叫原始回溯的东西

00:01:17.010 --> 00:01:19.112 align:middle line:-1
并添加到时间样本表格

00:01:19.613 --> 00:01:22.049 align:middle line:-2
之后由Time Profiler
的建模模块读取

00:01:22.649 --> 00:01:25.919 align:middle line:-1
再转换成可显示的回溯

00:01:25.986 --> 00:01:27.821 align:middle line:-2
放入
Time Profiler表格

00:01:28.422 --> 00:01:30.824 align:middle line:-2
最终由Time Profiler
工具显示

00:01:31.225 --> 00:01:32.693 align:middle line:-1
这样做是为了

00:01:32.759 --> 00:01:36.830 align:middle line:-1
更简单有效地捕捉原始回溯

00:01:36.997 --> 00:01:39.933 align:middle line:-1
以便之后在模块的用户空间中修复

00:01:40.133 --> 00:01:42.970 align:middle line:-1
从而有效地在内核留下记录

00:01:43.637 --> 00:01:46.874 align:middle line:-1
内核做的另一种优化是

00:01:47.341 --> 00:01:52.346 align:middle line:-2
如果内核对之前抽样过
但没有移动的线程 再次抽样

00:01:52.546 --> 00:01:54.248 align:middle line:-1
它不需要全部回溯

00:01:54.648 --> 00:01:58.085 align:middle line:-2
只要在样本表格中
放入一个占位符回溯

00:01:58.585 --> 00:02:00.821 align:middle line:-2
然后
Time Profiler模块会

00:02:01.388 --> 00:02:03.423 align:middle line:-1
提取最后一次回溯

00:02:03.924 --> 00:02:06.393 align:middle line:-2
复制到
Time Profiler表

00:02:06.460 --> 00:02:07.895 align:middle line:-1
然后由工具审阅

00:02:08.294 --> 00:02:09.562 align:middle line:-1
它做了两件事

00:02:09.729 --> 00:02:12.566 align:middle line:-1
它大量节省了内核的记录缓冲

00:02:12.633 --> 00:02:14.168 align:middle line:-1
特别是当线程为闲置状态

00:02:14.768 --> 00:02:17.070 align:middle line:-1
还能保持UI的效率

00:02:17.237 --> 00:02:19.940 align:middle line:-1
因为UI不知道这个占位符转换

00:02:20.274 --> 00:02:23.177 align:middle line:-1
因为是由建模模块转换的

00:02:23.844 --> 00:02:25.913 align:middle line:-1
下面这些主题会不断重复出现

00:02:26.380 --> 00:02:29.716 align:middle line:-1
基本上将自定义工具的复杂性

00:02:30.050 --> 00:02:31.919 align:middle line:-1
吸收到建模层面

00:02:32.152 --> 00:02:34.788 align:middle line:-1
这可以简化其他部分 特别是

00:02:35.155 --> 00:02:38.091 align:middle line:-1
对内嵌在逻辑里的追踪代码

00:02:38.158 --> 00:02:40.027 align:middle line:-1
和工具使用UI

00:02:40.994 --> 00:02:42.196 align:middle line:-1
这就今天的内容

00:02:42.262 --> 00:02:43.997 align:middle line:-1
我们会回顾建模基础

00:02:44.064 --> 00:02:47.234 align:middle line:-1
然后了解创建自定义工具的流程

00:02:47.701 --> 00:02:49.803 align:middle line:-1
在创建自定义模块时

00:02:50.604 --> 00:02:52.539 align:middle line:-1
用Scratch很难操作

00:02:53.006 --> 00:02:56.944 align:middle line:-1
因此今年的演讲中会展示样本代码

00:02:57.010 --> 00:02:58.512 align:middle line:-1
你可以模仿样本

00:02:58.745 --> 00:03:00.581 align:middle line:-1
或将其用作创建基础

00:03:01.081 --> 00:03:02.683 align:middle line:-1
现在我们要讲的是

00:03:02.850 --> 00:03:06.019 align:middle line:-1
执行和Cliff规则引擎

00:03:06.320 --> 00:03:08.522 align:middle line:-1
还有关键内容 推断

00:03:09.056 --> 00:03:12.226 align:middle line:-1
首先来重温一些建模基础

00:03:13.994 --> 00:03:15.863 align:middle line:-1
在创建模块时

00:03:16.096 --> 00:03:17.331 align:middle line:-1
你需要定义

00:03:17.397 --> 00:03:19.600 align:middle line:-1
其他架构部分

00:03:19.800 --> 00:03:21.702 align:middle line:-1
比如定义schema

00:03:21.768 --> 00:03:24.004 align:middle line:-1
整合查看器的所有内容

00:03:24.404 --> 00:03:28.108 align:middle line:-1
并最后审阅查看器的输出

00:03:28.609 --> 00:03:31.612 align:middle line:-1
所有这些都建在工具分布包中

00:03:31.678 --> 00:03:34.915 align:middle line:-1
可以在工具内安装并测试

00:03:35.482 --> 00:03:36.984 align:middle line:-1
这里我们假设

00:03:37.050 --> 00:03:39.853 align:middle line:-1
Xcode中已经有一个项目

00:03:39.920 --> 00:03:42.623 align:middle line:-1
你要做的是添加自定义模块

00:03:42.856 --> 00:03:44.791 align:middle line:-1
或使用样本代码

00:03:44.992 --> 00:03:46.560 align:middle line:-1
今年的演讲中有展示

00:03:46.927 --> 00:03:49.062 align:middle line:-1
获得设置好的项目

00:03:50.197 --> 00:03:52.699 align:middle line:-1
何时需要创建自定义模块呢

00:03:53.433 --> 00:03:56.170 align:middle line:-1
Xcode的确可以生成模块

00:03:56.236 --> 00:04:00.040 align:middle line:-2
特别是OS Signpost
作为输入时

00:04:00.607 --> 00:04:02.409 align:middle line:-1
但这些建模模块只是让你

00:04:02.476 --> 00:04:03.944 align:middle line:-1
快速运行工具

00:04:04.011 --> 00:04:07.314 align:middle line:-1
而不是开放所有功能

00:04:07.381 --> 00:04:08.749 align:middle line:-1
让你自定义建块

00:04:09.416 --> 00:04:12.319 align:middle line:-1
比如融合多个输入表的数据

00:04:12.386 --> 00:04:14.288 align:middle line:-1
自定义模块可以做到

00:04:14.354 --> 00:04:15.822 align:middle line:-1
已生成的案例就不行

00:04:16.790 --> 00:04:18.759 align:middle line:-1
更重要的是维护工作记忆

00:04:18.825 --> 00:04:22.029 align:middle line:-1
让模块记录运行总计

00:04:22.095 --> 00:04:23.397 align:middle line:-1
追踪开区间

00:04:23.730 --> 00:04:25.732 align:middle line:-1
运行更多计算

00:04:25.799 --> 00:04:27.968 align:middle line:-1
使用模块的工作记忆

00:04:29.536 --> 00:04:31.538 align:middle line:-1
另外能做的是创建自定义图表

00:04:31.605 --> 00:04:32.906 align:middle line:-1
如果想要创建图表

00:04:32.973 --> 00:04:34.341 align:middle line:-1
但工具不能在本地完成

00:04:34.675 --> 00:04:37.177 align:middle line:-1
你可以在建模模块中合成

00:04:37.244 --> 00:04:40.681 align:middle line:-1
比如 你可以计算移动平均值

00:04:40.747 --> 00:04:42.649 align:middle line:-1
或更复杂的卡尔曼滤波

00:04:42.716 --> 00:04:43.817 align:middle line:-1
这都取决于你

00:04:43.884 --> 00:04:46.353 align:middle line:-1
所有这些都能在自定义建模中完成

00:04:46.920 --> 00:04:49.990 align:middle line:-1
最终目标是建立更为智能的工具

00:04:50.691 --> 00:04:53.560 align:middle line:-1
让工具知道代码在做什么

00:04:53.794 --> 00:04:56.029 align:middle line:-1
甚至能够达到

00:04:56.330 --> 00:04:59.132 align:middle line:-1
让使用代码的人会先查找工具

00:04:59.199 --> 00:05:00.901 align:middle line:-1
然后再找你解决问题

00:05:01.235 --> 00:05:03.971 align:middle line:-1
这就解放了你 让你能投入下个项目

00:05:05.506 --> 00:05:07.407 align:middle line:-1
模块基本等于规则引擎

00:05:07.608 --> 00:05:11.778 align:middle line:-1
捆绑一套输入表和一套输出表

00:05:12.546 --> 00:05:16.683 align:middle line:-2
工具的分析内核
负责对输入表按时间排列

00:05:16.750 --> 00:05:19.186 align:middle line:-1
然后注入模块的工作记忆

00:05:19.586 --> 00:05:21.688 align:middle line:-1
工作记忆中的对象叫做事实

00:05:21.922 --> 00:05:23.156 align:middle line:-1
用来推断

00:05:23.223 --> 00:05:25.125 align:middle line:-1
工作记忆和事实的变化

00:05:25.559 --> 00:05:28.529 align:middle line:-1
是CLIPS语言的规则系统

00:05:28.595 --> 00:05:29.963 align:middle line:-1
CLIPS是开源语言

00:05:30.030 --> 00:05:32.466 align:middle line:-1
八十年代出现 并有很多优秀的案例

00:05:32.766 --> 00:05:34.401 align:middle line:-1
和文献供你参考

00:05:34.635 --> 00:05:36.503 align:middle line:-1
我们的样本代码里也有很多例子

00:05:36.570 --> 00:05:38.005 align:middle line:-1
还有幻灯片中

00:05:39.173 --> 00:05:40.807 align:middle line:-1
当建模模块发现

00:05:40.874 --> 00:05:42.476 align:middle line:-1
它想输出的东西

00:05:42.543 --> 00:05:45.979 align:middle line:-1
模块的函数可以编写绑定的输出表

00:05:46.947 --> 00:05:48.815 align:middle line:-1
要从Scratch编写模块

00:05:48.882 --> 00:05:51.151 align:middle line:-1
可以分三步 首先是

00:05:51.518 --> 00:05:52.753 align:middle line:-1
决定模块内容

00:05:53.120 --> 00:05:55.122 align:middle line:-1
意思是了解技术

00:05:55.189 --> 00:05:56.590 align:middle line:-1
创建自定义工具

00:05:57.124 --> 00:05:58.258 align:middle line:-1
也就是说

00:05:58.325 --> 00:06:00.594 align:middle line:-1
了解自定义工具的结构

00:06:00.661 --> 00:06:02.129 align:middle line:-1
和如何发挥最多用处

00:06:02.896 --> 00:06:05.766 align:middle line:-2
2019年“开发优秀的剖析体验”
演讲中

00:06:05.832 --> 00:06:07.601 align:middle line:-1
我们团队会带你了解

00:06:08.001 --> 00:06:10.704 align:middle line:-1
代码的变化如何讲故事

00:06:10.771 --> 00:06:11.738 align:middle line:-1
通过自定义工具

00:06:11.805 --> 00:06:15.142 align:middle line:-1
它可以作为了解建模内容的起点

00:06:16.343 --> 00:06:19.913 align:middle line:-1
给建模模块定义了输出后

00:06:20.247 --> 00:06:21.648 align:middle line:-1
需要一些输入

00:06:22.049 --> 00:06:24.618 align:middle line:-1
从代码输入工具的最好方法是

00:06:24.685 --> 00:06:26.420 align:middle line:-2
通过
OS Signpost API

00:06:26.920 --> 00:06:29.122 align:middle line:-1
这个API可以穿插在代码中

00:06:29.189 --> 00:06:30.757 align:middle line:-1
追踪代码变化

00:06:30.824 --> 00:06:32.593 align:middle line:-1
传递实参数据

00:06:32.659 --> 00:06:35.896 align:middle line:-1
让模块在输入流中完成推断

00:06:36.496 --> 00:06:38.599 align:middle line:-1
有了输入和输出之后

00:06:38.665 --> 00:06:40.667 align:middle line:-1
要开始定义规则系统

00:06:40.734 --> 00:06:41.768 align:middle line:-1
并编写规则

00:06:42.169 --> 00:06:44.371 align:middle line:-1
第二步和第三步都是迭代的

00:06:44.438 --> 00:06:46.540 align:middle line:-1
因此在写规则时

00:06:46.607 --> 00:06:49.343 align:middle line:-2
可能需要回溯
添加更多Signpost

00:06:49.409 --> 00:06:51.545 align:middle line:-2
或修改Signpost
都没问题

00:06:51.612 --> 00:06:52.446 align:middle line:-1
可以这样做

00:06:52.779 --> 00:06:55.916 align:middle line:-2
但要记住
Signpost是设立界限

00:06:55.983 --> 00:06:58.385 align:middle line:-1
隔离代码和工具的内容

00:06:58.452 --> 00:07:00.554 align:middle line:-1
所以 你要保证

00:07:00.988 --> 00:07:03.423 align:middle line:-1
给Signpost调用添加评论

00:07:03.490 --> 00:07:05.692 align:middle line:-1
让人们知道这实际是个合约

00:07:05.759 --> 00:07:08.462 align:middle line:-1
如果修改就会破坏工具

00:07:09.463 --> 00:07:12.099 align:middle line:-1
要了解这个过程 可能最好是要

00:07:12.165 --> 00:07:13.233 align:middle line:-1
通过实际例子

00:07:13.300 --> 00:07:16.637 align:middle line:-1
所以我要请上我们的建模专家

00:07:16.937 --> 00:07:19.006 align:middle line:-2
Alejandro Lucena
来讲解

00:07:24.211 --> 00:07:26.446 align:middle line:-1
大家下午好 感谢Chad

00:07:27.681 --> 00:07:29.316 align:middle line:-1
我要做的就是

00:07:29.383 --> 00:07:31.218 align:middle line:-1
演示Chad说的思维过程

00:07:31.418 --> 00:07:34.588 align:middle line:-2
并用一个例子演示
如何将所有组件融为一体

00:07:35.389 --> 00:07:38.258 align:middle line:-1
首先 从这个演示app开始

00:07:38.458 --> 00:07:42.029 align:middle line:-1
坦白说 这可能是我做过的最酷的事

00:07:42.496 --> 00:07:44.231 align:middle line:-1
它是列出了各种山羊

00:07:44.831 --> 00:07:48.969 align:middle line:-1
这些山羊不仅是显示在app中

00:07:49.036 --> 00:07:50.637 align:middle line:-1
app还能让我排序

00:07:51.138 --> 00:07:53.006 align:middle line:-1
排序的实现是通过

00:07:53.073 --> 00:07:54.441 align:middle line:-1
“移动主体模式”

00:07:54.975 --> 00:07:58.412 align:middle line:-1
它有很多并列的不同模式可供使用

00:07:58.478 --> 00:08:01.014 align:middle line:-2
比如future和promise
或执行序列

00:08:01.448 --> 00:08:03.483 align:middle line:-1
所以如果“移动主体”这个词

00:08:03.550 --> 00:08:04.484 align:middle line:-1
你听到我们说

00:08:04.718 --> 00:08:08.322 align:middle line:-1
你可以想象成你使用的任何模式

00:08:08.689 --> 00:08:11.491 align:middle line:-1
但本场还是称之为“移动主体”

00:08:12.559 --> 00:08:13.794 align:middle line:-1
如字面意思

00:08:13.861 --> 00:08:16.463 align:middle line:-1
移动主体模式传递的重要概念

00:08:16.530 --> 00:08:17.664 align:middle line:-1
就是移动主体

00:08:18.198 --> 00:08:21.435 align:middle line:-1
可视化为左上角的圆圈

00:08:22.202 --> 00:08:25.372 align:middle line:-1
这个主体是要完成任务 比如排序

00:08:25.439 --> 00:08:27.741 align:middle line:-1
并分成几个子任务

00:08:27.975 --> 00:08:29.743 align:middle line:-1
比如获取初始表

00:08:29.810 --> 00:08:31.578 align:middle line:-1
排序 然后确认结果

00:08:32.145 --> 00:08:35.616 align:middle line:-1
每个子任务会在“站点”执行

00:08:36.183 --> 00:08:37.784 align:middle line:-1
站点告诉主体

00:08:37.851 --> 00:08:40.419 align:middle line:-1
依赖关系或执行上下文

00:08:40.486 --> 00:08:41.688 align:middle line:-1
帮它完成子目标

00:08:43.023 --> 00:08:45.792 align:middle line:-1
下面看看如何执行任务 比如排序

00:08:45.859 --> 00:08:47.294 align:middle line:-1
通过移动主体模式

00:08:47.895 --> 00:08:51.031 align:middle line:-1
我们要做的是点击左上角的“排序”

00:08:51.732 --> 00:08:54.401 align:middle line:-1
主体会移动到第一个站点

00:08:54.568 --> 00:08:56.503 align:middle line:-1
这里的站点由UI控制

00:08:57.037 --> 00:09:00.107 align:middle line:-1
它会执行第一个子任务 获取列表

00:09:00.908 --> 00:09:02.309 align:middle line:-1
获取列表后

00:09:02.509 --> 00:09:06.513 align:middle line:-2
它可以移动到另一个站点
比如分发队列

00:09:07.281 --> 00:09:10.417 align:middle line:-1
在分发队列站点 它可以运行排序

00:09:11.585 --> 00:09:13.086 align:middle line:-1
排序完成后

00:09:13.487 --> 00:09:14.721 align:middle line:-1
它会回到UI

00:09:15.489 --> 00:09:18.091 align:middle line:-1
最后将列表按序整理排列

00:09:19.226 --> 00:09:21.895 align:middle line:-1
最后停泊到“排序”键 供以后使用

00:09:23.230 --> 00:09:25.766 align:middle line:-1
刚才演示的就是移动主体模式

00:09:25.832 --> 00:09:28.268 align:middle line:-1
主体可以是两个初始阶段中的一个

00:09:28.569 --> 00:09:32.105 align:middle line:-2
可以在一个站点执行
也可以移动到另一个站点

00:09:32.539 --> 00:09:34.007 align:middle line:-1
这就是建模有趣的地方

00:09:34.074 --> 00:09:36.610 align:middle line:-1
具体来说 有趣的是看到它们

00:09:36.677 --> 00:09:38.645 align:middle line:-1
交互的时间

00:09:39.446 --> 00:09:40.547 align:middle line:-1
为了更好的可视化

00:09:40.614 --> 00:09:42.182 align:middle line:-1
我再演示一遍这个排序的例子

00:09:42.249 --> 00:09:44.251 align:middle line:-1
带上区间

00:09:44.318 --> 00:09:45.185 align:middle line:-1
我要做的是

00:09:45.252 --> 00:09:47.387 align:middle line:-1
将设备移动到左边

00:09:47.888 --> 00:09:49.189 align:middle line:-1
因为需要一些空间

00:09:50.090 --> 00:09:53.760 align:middle line:-2
然后点击“排序”按钮
这个主体会移动到UI站点

00:09:54.494 --> 00:09:57.064 align:middle line:-1
移动发生时 看到一个区间

00:09:57.130 --> 00:09:59.867 align:middle line:-2
带描述性字符串
或告诉我们发生了什么

00:10:02.169 --> 00:10:04.371 align:middle line:-1
主体会执行第一个子任务

00:10:04.438 --> 00:10:05.973 align:middle line:-1
获取列表

00:10:07.040 --> 00:10:08.809 align:middle line:-1
这里有个不同的区间

00:10:10.410 --> 00:10:13.013 align:middle line:-1
然后主体会移动到分发队列

00:10:13.714 --> 00:10:15.516 align:middle line:-1
由它自己的区间显示

00:10:17.618 --> 00:10:20.087 align:middle line:-1
在分发队列 主体会执行排序

00:10:21.221 --> 00:10:23.190 align:middle line:-1
如所见 它在执行排序模式

00:10:24.691 --> 00:10:26.860 align:middle line:-1
然后回到UI站点

00:10:26.927 --> 00:10:29.763 align:middle line:-1
这是最后一个移动区间 移回UI

00:10:30.931 --> 00:10:34.067 align:middle line:-2
这个站点上
它会执行下一个也是最后一个

00:10:34.134 --> 00:10:36.436 align:middle line:-1
更新排序的子任务

00:10:37.738 --> 00:10:40.107 align:middle line:-2
有了这些区间
就可以设想区间的开始

00:10:40.174 --> 00:10:41.975 align:middle line:-1
就是活动的起始时间

00:10:42.042 --> 00:10:43.377 align:middle line:-1
无论是执行还是移动

00:10:43.744 --> 00:10:46.313 align:middle line:-1
区间的结束就是活动的终止时间

00:10:47.047 --> 00:10:48.282 align:middle line:-1
记住这些区间

00:10:48.348 --> 00:10:51.585 align:middle line:-1
就可以拥有或设计想要的工具

00:10:51.785 --> 00:10:53.587 align:middle line:-1
就是屏幕上展示的这样

00:10:54.421 --> 00:10:55.422 align:middle line:-1
最上面的轨道

00:10:55.489 --> 00:10:57.124 align:middle line:-1
显示了所有的区间

00:10:57.191 --> 00:10:59.259 align:middle line:-1
可以看到不同的移动和执行

00:10:59.793 --> 00:11:01.562 align:middle line:-1
它的下面

00:11:01.628 --> 00:11:03.764 align:middle line:-1
是轨道上不同的活动站点

00:11:04.998 --> 00:11:07.234 align:middle line:-1
除了工具的直观样式

00:11:07.301 --> 00:11:08.802 align:middle line:-1
还要看看细节视图

00:11:09.169 --> 00:11:10.871 align:middle line:-1
细节视图提供更多信息

00:11:10.938 --> 00:11:12.372 align:middle line:-1
关于每个站点的活动

00:11:12.439 --> 00:11:15.309 align:middle line:-1
比如起始时间 时长

00:11:15.642 --> 00:11:17.244 align:middle line:-1
主体是什么 等等

00:11:18.378 --> 00:11:21.849 align:middle line:-1
这里要注意最上面这一列

00:11:22.249 --> 00:11:25.419 align:middle line:-1
它定义了建模的关键兴趣点

00:11:25.953 --> 00:11:27.287 align:middle line:-1
这几列告诉了我们

00:11:27.354 --> 00:11:29.289 align:middle line:-1
起始时间 时长和主体类型

00:11:29.590 --> 00:11:31.625 align:middle line:-1
通常这几列中的定义

00:11:31.692 --> 00:11:34.027 align:middle line:-1
在工具的XML文件包中

00:11:34.528 --> 00:11:37.030 align:middle line:-1
它们共同组成输出表

00:11:37.598 --> 00:11:39.199 align:middle line:-1
这也是我们的第一个检查点

00:11:39.600 --> 00:11:40.834 align:middle line:-1
通过这些列

00:11:40.901 --> 00:11:43.337 align:middle line:-1
定义要存储的数据

00:11:43.670 --> 00:11:45.172 align:middle line:-1
这就完成了第一个目标

00:11:45.239 --> 00:11:47.007 align:middle line:-1
决定模块的内容

00:11:47.841 --> 00:11:48.742 align:middle line:-1
这就好了

00:11:49.576 --> 00:11:52.980 align:middle line:-2
下一步就是获取数据
从app到工具

00:11:53.380 --> 00:11:55.249 align:middle line:-1
通过OS Signpost实现

00:11:56.683 --> 00:11:58.118 align:middle line:-1
再回到之前的区间

00:11:58.652 --> 00:11:59.486 align:middle line:-1
就是它们

00:12:03.123 --> 00:12:04.992 align:middle line:-1
是本地为区间而创建的

00:12:05.759 --> 00:12:07.494 align:middle line:-1
但我们想更进一步

00:12:07.728 --> 00:12:10.864 align:middle line:-1
使用Event Signpost

00:12:11.331 --> 00:12:13.400 align:middle line:-2
每个event Signpost
会出现在

00:12:13.467 --> 00:12:15.469 align:middle line:-1
活动区间之间的界限上

00:12:15.836 --> 00:12:17.871 align:middle line:-1
这样做不仅是为了

00:12:17.938 --> 00:12:21.642 align:middle line:-1
节省大约50%的Signpost

00:12:21.975 --> 00:12:23.944 align:middle line:-1
更是为了更准确的显示

00:12:24.011 --> 00:12:25.145 align:middle line:-1
移动主体模式

00:12:25.812 --> 00:12:28.348 align:middle line:-1
就是主体结束当前活动后

00:12:28.415 --> 00:12:29.783 align:middle line:-1
会立即开始另一个

00:12:29.850 --> 00:12:32.152 align:middle line:-2
所以只能发射一个Signpost
告诉我们

00:12:32.319 --> 00:12:33.520 align:middle line:-1
主体开始下一个活动了

00:12:35.422 --> 00:12:36.623 align:middle line:-1
为实现它

00:12:36.857 --> 00:12:40.260 align:middle line:-2
需要executeStop函数
是移动主体的一部分

00:12:40.694 --> 00:12:42.996 align:middle line:-1
在运行内部逻辑

00:12:43.063 --> 00:12:45.232 align:middle line:-1
执行该站点活动之前

00:12:45.666 --> 00:12:47.401 align:middle line:-2
要有一个Signpost
带有名称

00:12:47.668 --> 00:12:50.838 align:middle line:-2
具体的Signpost ID
和内嵌消息

00:12:52.306 --> 00:12:53.140 align:middle line:-1
除此之外

00:12:53.674 --> 00:12:57.578 align:middle line:-2
visitNextStop函数中
配置相同的OS Signpost

00:12:57.644 --> 00:13:00.814 align:middle line:-1
执行主体在站点间移动的逻辑

00:13:01.315 --> 00:13:03.016 align:middle line:-1
同样 执行移动之前

00:13:03.317 --> 00:13:05.586 align:middle line:-2
命名
Mobile Agent Moved

00:13:05.652 --> 00:13:08.021 align:middle line:-2
再给一个Signpost ID
和一条消息

00:13:11.825 --> 00:13:14.294 align:middle line:-1
现在注意看中间的模块

00:13:14.361 --> 00:13:16.430 align:middle line:-1
它会转换Signpost

00:13:16.496 --> 00:13:17.698 align:middle line:-1
把刚输入app的

00:13:18.065 --> 00:13:20.567 align:middle line:-1
变成可用的区间 写入输出表

00:13:22.035 --> 00:13:23.170 align:middle line:-1
举个例子

00:13:23.237 --> 00:13:24.238 align:middle line:-1
这个模块

00:13:24.304 --> 00:13:26.640 align:middle line:-1
一开始 工作记忆是空的

00:13:26.707 --> 00:13:29.276 align:middle line:-1
因为它不知道app的状态

00:13:30.244 --> 00:13:31.778 align:middle line:-1
但我们知道

00:13:32.145 --> 00:13:35.315 align:middle line:-2
模块与OS Signpost表
交互频繁

00:13:35.649 --> 00:13:37.918 align:middle line:-2
OS Signpost表
由app生成

00:13:38.785 --> 00:13:41.488 align:middle line:-1
假设模块想要侦测

00:13:41.688 --> 00:13:43.490 align:middle line:-1
Signpost上的移动主体

00:13:44.591 --> 00:13:46.827 align:middle line:-1
点击演示app上的排序按钮后

00:13:47.094 --> 00:13:49.263 align:middle line:-2
模块会接收一个
OS Signpost

00:13:49.563 --> 00:13:51.999 align:middle line:-1
然后将它表述为一个事实

00:13:52.266 --> 00:13:53.901 align:middle line:-1
这个事实带有信息栏

00:13:53.967 --> 00:13:56.069 align:middle line:-2
根据调用
OS Signpost的方法

00:13:57.271 --> 00:13:59.106 align:middle line:-1
现在 建模模块看到

00:13:59.173 --> 00:14:01.241 align:middle line:-2
OS Signpost事实
实际上是

00:14:01.308 --> 00:14:02.809 align:middle line:-1
移动主体的各种信息

00:14:03.310 --> 00:14:07.080 align:middle line:-2
模块就能通过
OS Signpost事实推断主体

00:14:07.247 --> 00:14:09.983 align:middle line:-1
通过确定事实 注入工作记忆

00:14:10.284 --> 00:14:12.920 align:middle line:-1
确定知道有一个排序主体

00:14:12.986 --> 00:14:14.054 align:middle line:-1
移动到后台

00:14:16.223 --> 00:14:19.193 align:middle line:-1
然后 模块要决定主体的活动

00:14:19.259 --> 00:14:22.729 align:middle line:-1
比如实际在做什么 以及时间

00:14:23.363 --> 00:14:25.799 align:middle line:-1
然后模块会查看已知事实 然后说

00:14:25.866 --> 00:14:28.101 align:middle line:-1
我知道主体正在移动

00:14:28.468 --> 00:14:31.538 align:middle line:-2
而Signpost事实的
起始时间是42

00:14:32.005 --> 00:14:33.607 align:middle line:-1
建模模块会记住它

00:14:33.674 --> 00:14:35.943 align:middle line:-1
在工作记忆中再输入一个事实

00:14:36.443 --> 00:14:38.445 align:middle line:-1
表明起始时间为42

00:14:39.980 --> 00:14:42.216 align:middle line:-1
这时Signpost事实消失了

00:14:43.183 --> 00:14:45.686 align:middle line:-1
没问题 因为我们把所有相关信息

00:14:45.752 --> 00:14:48.021 align:middle line:-1
确定的事实 都存入了工作记忆

00:14:49.156 --> 00:14:51.658 align:middle line:-1
我把它们往上挪一点 留些空间

00:14:52.759 --> 00:14:54.494 align:middle line:-1
最后建模模块要做的

00:14:54.795 --> 00:14:57.264 align:middle line:-1
是决定活动的完整区间

00:14:57.564 --> 00:15:00.434 align:middle line:-1
现在只有起始时间 没有完整区间

00:15:01.134 --> 00:15:02.469 align:middle line:-1
但我们知道某个点上

00:15:02.870 --> 00:15:05.072 align:middle line:-2
演示app会发出
另一个Signpost

00:15:05.305 --> 00:15:06.640 align:middle line:-1
同样的 建模模块接收后

00:15:06.840 --> 00:15:08.475 align:middle line:-1
会表述为相应事实

00:15:09.309 --> 00:15:10.878 align:middle line:-1
因为Signpost经过架构

00:15:10.944 --> 00:15:13.313 align:middle line:-1
会在区间间隙发出

00:15:13.780 --> 00:15:16.850 align:middle line:-2
模块知道何时接收
下一个Signpost

00:15:16.917 --> 00:15:20.087 align:middle line:-1
它可以查看任何之前打开的区间事实

00:15:20.587 --> 00:15:21.421 align:middle line:-1
并关闭

00:15:22.155 --> 00:15:25.359 align:middle line:-1
这里 它会查看事实的值

00:15:25.592 --> 00:15:28.729 align:middle line:-1
用足够的值决定完整区间

00:15:29.129 --> 00:15:31.031 align:middle line:-1
为此 它要调出输出表

00:15:32.432 --> 00:15:34.668 align:middle line:-1
删除已有的开区间事实

00:15:35.335 --> 00:15:36.837 align:middle line:-1
用完整区间替代

00:15:36.904 --> 00:15:38.071 align:middle line:-1
这里是移动到后台

00:15:38.872 --> 00:15:40.874 align:middle line:-1
并使用这个区间填写输出表

00:15:43.210 --> 00:15:44.077 align:middle line:-1
好了

00:15:44.645 --> 00:15:47.614 align:middle line:-1
在研究实际的CLIPS代码之前

00:15:47.681 --> 00:15:51.752 align:middle line:-2
还是要了解app代码
调用的API如何

00:15:51.818 --> 00:15:53.620 align:middle line:-1
能翻译成CLIPS事实

00:15:54.688 --> 00:15:58.659 align:middle line:-2
特别是当调用特殊名称的
OS Signpost

00:15:58.725 --> 00:16:02.696 align:middle line:-2
这个名称会成为
OS Signpost事实中的名称

00:16:04.698 --> 00:16:07.668 align:middle line:-2
另外 这个事件里的
Signpost类型

00:16:07.734 --> 00:16:10.704 align:middle line:-2
会成为OS Signpost
事件中的事件类型栏

00:16:12.105 --> 00:16:14.174 align:middle line:-1
最后 Signpost ID

00:16:14.575 --> 00:16:17.744 align:middle line:-2
会成为OS Signpost
事件内的标识符值

00:16:18.445 --> 00:16:20.080 align:middle line:-1
还有消息 内嵌的消息

00:16:20.147 --> 00:16:23.650 align:middle line:-2
也是OS Signpost
事实的信息值

00:16:26.787 --> 00:16:27.721 align:middle line:-1
现在我们知道

00:16:27.788 --> 00:16:30.057 align:middle line:-1
可以通过查找规则来侦测移动主体

00:16:30.123 --> 00:16:31.525 align:middle line:-1
这是一个CLIPS规则

00:16:31.758 --> 00:16:32.926 align:middle line:-1
首先要做的是

00:16:32.993 --> 00:16:35.062 align:middle line:-1
侦测OS Signpost

00:16:35.996 --> 00:16:38.532 align:middle line:-2
通过名称
比如Mobile Agent Moved

00:16:39.900 --> 00:16:41.935 align:middle line:-1
我们要捕捉这个值

00:16:42.002 --> 00:16:45.138 align:middle line:-2
位于标识符栏
在instance变量中

00:16:47.007 --> 00:16:49.376 align:middle line:-1
另外 我们可以对消息进行解析

00:16:49.443 --> 00:16:51.411 align:middle line:-1
提取有用信息 如图

00:16:54.014 --> 00:16:54.948 align:middle line:-1
第二部分

00:16:55.015 --> 00:16:56.884 align:middle line:-1
我们要表述一个条件

00:16:57.050 --> 00:17:00.921 align:middle line:-1
就是要匹配缺失的移动主体

00:17:00.988 --> 00:17:02.923 align:middle line:-1
Signpost标识过的

00:17:03.223 --> 00:17:05.826 align:middle line:-2
我们会用Signpost
去找到移动主体

00:17:05.893 --> 00:17:07.661 align:middle line:-1
但是不想增加任何重复

00:17:07.994 --> 00:17:10.263 align:middle line:-1
因此关键词not就是告诉模块

00:17:10.430 --> 00:17:12.598 align:middle line:-1
前提是没有移动主体

00:17:12.665 --> 00:17:14.835 align:middle line:-2
在这个instance变量中
被识别

00:17:16.069 --> 00:17:17.003 align:middle line:-1
如果是这样

00:17:17.069 --> 00:17:19.839 align:middle line:-2
模块可以确认这个移动主体
并注入工作记忆

00:17:22.776 --> 00:17:25.679 align:middle line:-1
同样的 在侦测移动主体活动时

00:17:26.280 --> 00:17:27.981 align:middle line:-2
会再次匹配
OS Signpost事实

00:17:28.048 --> 00:17:30.117 align:middle line:-1
因为需要确定某些属性

00:17:30.984 --> 00:17:31.852 align:middle line:-1
但这里

00:17:32.252 --> 00:17:34.021 align:middle line:-1
省略了关键词not

00:17:34.087 --> 00:17:36.623 align:middle line:-1
因为要将这个主体事实显示到

00:17:36.690 --> 00:17:37.824 align:middle line:-1
工作记忆中

00:17:37.891 --> 00:17:39.893 align:middle line:-1
现在已经解析了主体

00:17:40.160 --> 00:17:41.295 align:middle line:-1
并可以用它做更多事情

00:17:42.462 --> 00:17:45.465 align:middle line:-1
具体来说 一旦有了这两个事实

00:17:45.966 --> 00:17:48.368 align:middle line:-1
就能确定或添加移动事实

00:17:48.669 --> 00:17:51.271 align:middle line:-1
让建模模块可以追踪主体的实际活动

00:17:53.674 --> 00:17:56.577 align:middle line:-1
以上是CLIPS代码的例子

00:17:56.777 --> 00:17:59.746 align:middle line:-1
用来侦测主体和主体的活动

00:17:59.947 --> 00:18:02.716 align:middle line:-1
但我们还需要更多底层执行的知识

00:18:03.217 --> 00:18:05.485 align:middle line:-1
以便更好地架构建模模块

00:18:06.119 --> 00:18:08.488 align:middle line:-1
我要请Chad回到舞台

00:18:08.555 --> 00:18:09.790 align:middle line:-1
讲解规则执行

00:18:14.161 --> 00:18:16.530 align:middle line:-1
好的 下面来讲规则执行

00:18:16.597 --> 00:18:19.032 align:middle line:-1
CLIPS语言下的规则引擎

00:18:20.667 --> 00:18:22.269 align:middle line:-1
当我们在CLIPS中定义规则时

00:18:22.336 --> 00:18:24.771 align:middle line:-2
分为左边(LHS)
和右边(RHS)

00:18:24.838 --> 00:18:26.974 align:middle line:-1
用=&gt;隔开

00:18:27.374 --> 00:18:30.511 align:middle line:-1
左边是描述性语言

00:18:30.577 --> 00:18:32.145 align:middle line:-1
定义了一个模式

00:18:32.212 --> 00:18:35.549 align:middle line:-1
让规则引擎在工作记忆中查找事实

00:18:36.283 --> 00:18:38.919 align:middle line:-1
当规则引擎找到了事实

00:18:38.986 --> 00:18:41.488 align:middle line:-1
满足左边的模式

00:18:41.788 --> 00:18:43.156 align:middle line:-1
会创建一个 激活

00:18:43.557 --> 00:18:46.960 align:middle line:-1
每次激活会触发规则的右边

00:18:47.561 --> 00:18:48.729 align:middle line:-1
规则的右边

00:18:48.795 --> 00:18:50.330 align:middle line:-1
是命令式语言

00:18:50.397 --> 00:18:52.733 align:middle line:-1
让你控制函数 比如“取消”

00:18:52.799 --> 00:18:55.035 align:middle line:-1
就是从工作记忆中删除事实

00:18:55.636 --> 00:18:59.106 align:middle line:-2
或“确认” 就是
在工作记忆中添加事实

00:18:59.706 --> 00:19:01.341 align:middle line:-1
还有特殊函数

00:19:01.408 --> 00:19:04.411 align:middle line:-1
让你写入模块的输出表

00:19:04.811 --> 00:19:06.013 align:middle line:-1
就能编写输出了

00:19:07.614 --> 00:19:08.982 align:middle line:-1
先讲讲事实

00:19:09.383 --> 00:19:11.451 align:middle line:-1
在工作记忆中确认事实

00:19:11.718 --> 00:19:13.053 align:middle line:-1
要用assert函数

00:19:13.520 --> 00:19:16.857 align:middle line:-1
每个新事实分配一个事实地址

00:19:16.924 --> 00:19:20.093 align:middle line:-1
标识为f-加一些数字

00:19:20.894 --> 00:19:24.531 align:middle line:-1
如果要在工作记忆中修改事实

00:19:24.698 --> 00:19:26.700 align:middle line:-1
我们还要有modify函数

00:19:27.367 --> 00:19:29.870 align:middle line:-1
它将修改的事实地址和栏

00:19:29.937 --> 00:19:31.238 align:middle line:-1
替换进工作记忆

00:19:31.905 --> 00:19:34.575 align:middle line:-1
这实际上结合了

00:19:34.641 --> 00:19:36.243 align:middle line:-1
一个撤回和一个确认

00:19:36.310 --> 00:19:39.513 align:middle line:-1
也就是先从工作记忆中撤回一个事实

00:19:39.780 --> 00:19:42.783 align:middle line:-1
修改后重新在工作记忆中确认

00:19:42.850 --> 00:19:44.818 align:middle line:-1
更新后的字段或栏

00:19:45.552 --> 00:19:47.421 align:middle line:-1
这很重要 因为

00:19:47.487 --> 00:19:49.389 align:middle line:-1
工作记忆中重新确认内容

00:19:49.456 --> 00:19:52.259 align:middle line:-1
会再次触发或激活某些规则

00:19:52.526 --> 00:19:54.494 align:middle line:-1
大部分情况下是好的

00:19:54.561 --> 00:19:56.797 align:middle line:-1
因为这就是规则系统反应

00:19:56.864 --> 00:19:59.666 align:middle line:-1
工作记忆事实变化的过程

00:20:03.303 --> 00:20:05.339 align:middle line:-1
我说的是逻辑回路

00:20:05.873 --> 00:20:07.608 align:middle line:-1
我们可能一不小心

00:20:07.674 --> 00:20:09.543 align:middle line:-1
在代码中包括了逻辑回路

00:20:10.277 --> 00:20:11.812 align:middle line:-1
所以这里有个小规则

00:20:11.879 --> 00:20:15.449 align:middle line:-1
是为了给移动主体计数

00:20:15.782 --> 00:20:18.051 align:middle line:-1
工作记忆中的移动主体

00:20:18.652 --> 00:20:21.889 align:middle line:-2
它首先是带计数器的事实
初始值为0

00:20:22.489 --> 00:20:25.559 align:middle line:-1
每个进入工作记忆的移动主体

00:20:25.626 --> 00:20:27.394 align:middle line:-1
会触发规则的右边

00:20:27.895 --> 00:20:32.666 align:middle line:-1
只要修改计数器的数字栏 +1

00:20:32.833 --> 00:20:34.234 align:middle line:-1
这就很直白了

00:20:34.801 --> 00:20:37.471 align:middle line:-1
来看看实际执行的样子

00:20:38.138 --> 00:20:39.072 align:middle line:-1
首先

00:20:39.139 --> 00:20:40.674 align:middle line:-1
工作记忆中的计数器

00:20:40.741 --> 00:20:42.276 align:middle line:-1
初始值为0

00:20:43.810 --> 00:20:45.646 align:middle line:-1
之后的某个时点

00:20:45.712 --> 00:20:47.848 align:middle line:-1
一个移动主体在工作记忆中确认

00:20:47.915 --> 00:20:50.984 align:middle line:-1
现在左边足以触发右边

00:20:51.818 --> 00:20:54.021 align:middle line:-1
调用modify函数

00:20:54.087 --> 00:20:57.257 align:middle line:-1
它先是撤回这个事实

00:20:57.891 --> 00:21:00.627 align:middle line:-1
增加计数的值

00:21:01.094 --> 00:21:03.397 align:middle line:-1
然后回到工作记忆中重新确认

00:21:03.697 --> 00:21:04.698 align:middle line:-1
这样做时

00:21:04.898 --> 00:21:06.967 align:middle line:-1
注意它重新触发了同一个规则

00:21:07.467 --> 00:21:09.436 align:middle line:-1
现在对同一个移动主体实体

00:21:09.503 --> 00:21:12.206 align:middle line:-1
它会计数2 3 4 5 6 7

00:21:12.272 --> 00:21:13.774 align:middle line:-1
一直数下去

00:21:14.208 --> 00:21:15.676 align:middle line:-1
直到追踪停止

00:21:15.742 --> 00:21:17.811 align:middle line:-1
工具会警告有严重错误

00:21:18.178 --> 00:21:20.113 align:middle line:-1
规则引擎卡住了

00:21:20.747 --> 00:21:23.650 align:middle line:-1
模块界面的工具查看器中

00:21:24.084 --> 00:21:25.552 align:middle line:-1
你看到的追踪

00:21:25.619 --> 00:21:27.654 align:middle line:-1
显示了所有事件和激活

00:21:27.721 --> 00:21:29.656 align:middle line:-1
在回路中发生的

00:21:29.723 --> 00:21:32.793 align:middle line:-2
这就给你一个好的开始
让你知道怎么调试和消除

00:21:33.594 --> 00:21:35.329 align:middle line:-1
在我来看 最简单的方法

00:21:35.395 --> 00:21:36.663 align:middle line:-1
消除逻辑回路

00:21:36.730 --> 00:21:38.398 align:middle line:-1
就是目的引导式编程

00:21:38.966 --> 00:21:40.901 align:middle line:-1
不是直接修改计数器事实

00:21:40.968 --> 00:21:45.506 align:middle line:-1
而是创建目标事件 帮我们计数

00:21:46.240 --> 00:21:48.575 align:middle line:-1
现在要侦测移动主体时

00:21:48.775 --> 00:21:51.245 align:middle line:-1
就要确认目标事实 来对实体计数

00:21:51.945 --> 00:21:53.247 align:middle line:-1
计数规则中

00:21:53.614 --> 00:21:56.350 align:middle line:-1
要捕捉计数器和目标

00:21:56.783 --> 00:21:59.553 align:middle line:-1
然后撤回目标 因为已经满足

00:21:59.920 --> 00:22:00.954 align:middle line:-1
计数器计数的规则

00:22:01.021 --> 00:22:02.990 align:middle line:-1
这样规则就会不断回来

00:22:03.056 --> 00:22:04.992 align:middle line:-1
从而打破逻辑回路

00:22:06.660 --> 00:22:09.663 align:middle line:-1
现在来看规则的触发顺序

00:22:09.730 --> 00:22:12.165 align:middle line:-1
及其对模块结果的影响

00:22:13.367 --> 00:22:15.068 align:middle line:-2
现在回到
executeStop函数

00:22:15.135 --> 00:22:17.371 align:middle line:-1
它先被调用 然后移动主体才会

00:22:17.437 --> 00:22:18.906 align:middle line:-1
进入执行阶段

00:22:19.740 --> 00:22:21.909 align:middle line:-2
现在你看到
OS Signpost中

00:22:21.975 --> 00:22:24.444 align:middle line:-1
第一版代码的第一个实参

00:22:24.611 --> 00:22:27.281 align:middle line:-1
实际上是主体的类型字符串

00:22:27.781 --> 00:22:29.183 align:middle line:-1
这里就是排序主体

00:22:29.249 --> 00:22:32.853 align:middle line:-2
或者是记入追踪缓冲的
14个字节的数据

00:22:33.187 --> 00:22:34.655 align:middle line:-1
我想还可以改善

00:22:35.155 --> 00:22:38.659 align:middle line:-1
将它从字符串变成类型代码

00:22:39.059 --> 00:22:41.228 align:middle line:-1
就是一个四字节整数

00:22:41.295 --> 00:22:43.463 align:middle line:-1
每个事件可节省10个字节

00:22:43.764 --> 00:22:46.066 align:middle line:-1
如果数据成千上百的进来

00:22:46.466 --> 00:22:49.436 align:middle line:-1
就可以节省几万字节的追踪缓冲

00:22:50.370 --> 00:22:51.238 align:middle line:-1
为实现它

00:22:51.305 --> 00:22:53.540 align:middle line:-1
就要在模块里创建映射

00:22:53.707 --> 00:22:55.976 align:middle line:-1
将代码转化为字符串

00:22:56.043 --> 00:22:57.711 align:middle line:-1
通过使用事实

00:22:58.512 --> 00:23:01.448 align:middle line:-1
在侦测规则中

00:23:01.615 --> 00:23:04.284 align:middle line:-1
捕捉主体的类型代码

00:23:04.918 --> 00:23:06.687 align:middle line:-1
在确认移动主体时

00:23:06.753 --> 00:23:09.857 align:middle line:-1
类型那一栏标记为sentinel

00:23:09.923 --> 00:23:11.859 align:middle line:-1
表示还没有完整的字符串

00:23:12.693 --> 00:23:14.161 align:middle line:-1
因为在第二个规则

00:23:14.228 --> 00:23:16.430 align:middle line:-1
我们要找到所有移动主体

00:23:16.597 --> 00:23:17.965 align:middle line:-1
类型为sentinel的

00:23:18.799 --> 00:23:22.469 align:middle line:-1
然后找到对应的类型代码

00:23:22.636 --> 00:23:25.405 align:middle line:-1
就是上一张图里的类型字符串映射

00:23:26.106 --> 00:23:27.674 align:middle line:-1
找到它们后

00:23:27.741 --> 00:23:29.643 align:middle line:-1
修改类型栏

00:23:29.877 --> 00:23:32.813 align:middle line:-2
从sentinel
改为真实的字符串

00:23:33.614 --> 00:23:37.985 align:middle line:-1
这一切都基于第二个查找规则

00:23:38.051 --> 00:23:40.320 align:middle line:-1
在运行确认后立即触发

00:23:41.121 --> 00:23:42.823 align:middle line:-1
但如果系统中有其他规则

00:23:42.890 --> 00:23:44.658 align:middle line:-1
比如主体停靠规则

00:23:44.725 --> 00:23:46.493 align:middle line:-1
也是引用移动主体

00:23:47.194 --> 00:23:49.162 align:middle line:-1
捕捉和使用类型栏的

00:23:49.229 --> 00:23:52.900 align:middle line:-2
如果它出现在确认
和查找规则之间会怎样

00:23:52.966 --> 00:23:54.401 align:middle line:-1
这会有一个sentinel

00:23:54.835 --> 00:23:56.703 align:middle line:-1
鉴于这是对规则系统的修改

00:23:56.770 --> 00:23:57.704 align:middle line:-1
你要准备好

00:23:57.771 --> 00:23:59.072 align:middle line:-1
面对很多新的缺陷

00:23:59.673 --> 00:24:01.008 align:middle line:-1
为了解决问题

00:24:01.074 --> 00:24:05.045 align:middle line:-1
要添加规则限制 就是

00:24:05.412 --> 00:24:07.614 align:middle line:-1
只要类型不是sentinel

00:24:07.681 --> 00:24:09.550 align:middle line:-1
这有效的延迟了规则触发

00:24:09.616 --> 00:24:13.453 align:middle line:-1
直到查找规则实际改变了主体的类型

00:24:14.121 --> 00:24:15.822 align:middle line:-1
从sentinel变为实际内容

00:24:16.557 --> 00:24:17.558 align:middle line:-1
这完全可行

00:24:17.624 --> 00:24:19.226 align:middle line:-1
但要用于所有规则

00:24:19.293 --> 00:24:20.961 align:middle line:-1
否则就会有维护问题

00:24:21.028 --> 00:24:25.532 align:middle line:-2
特别是当现有的规则集
设为永不为sentinel时

00:24:26.466 --> 00:24:28.802 align:middle line:-1
再来看另一种方法

00:24:29.036 --> 00:24:31.471 align:middle line:-1
我们实际是让查找规则

00:24:31.538 --> 00:24:33.807 align:middle line:-1
在确认后立即触发

00:24:34.007 --> 00:24:35.375 align:middle line:-1
其中一种方法是

00:24:35.976 --> 00:24:39.980 align:middle line:-1
告诉CLIPS那个规则更重要

00:24:40.047 --> 00:24:43.817 align:middle line:-1
或比默认的0突出值更突出

00:24:44.518 --> 00:24:48.488 align:middle line:-1
只要这个规则是系统中最突出的

00:24:48.789 --> 00:24:50.691 align:middle line:-1
那么第一个规则结束时

00:24:50.757 --> 00:24:52.459 align:middle line:-1
第二个就会被触发

00:24:52.793 --> 00:24:54.461 align:middle line:-1
如果在其他位置使用突出性

00:24:54.528 --> 00:24:56.230 align:middle line:-1
就要过一遍代码 确保

00:24:56.630 --> 00:24:58.966 align:middle line:-1
100仍是最高突出值

00:24:59.032 --> 00:25:00.634 align:middle line:-1
但这是后话了

00:25:01.034 --> 00:25:03.537 align:middle line:-1
这里还有一个更直接的方法

00:25:03.604 --> 00:25:05.806 align:middle line:-1
控制规则的排序和触发

00:25:06.206 --> 00:25:09.476 align:middle line:-1
这就要了解激活

00:25:10.444 --> 00:25:12.846 align:middle line:-1
提示一下 激活实际上是

00:25:12.913 --> 00:25:14.948 align:middle line:-1
工作记忆中的事实集合

00:25:15.015 --> 00:25:16.917 align:middle line:-1
满足规则的左边

00:25:17.217 --> 00:25:19.486 align:middle line:-1
每次激活都会触发规则的右边

00:25:20.354 --> 00:25:23.257 align:middle line:-1
现在不要直接触发规则的左边

00:25:23.557 --> 00:25:24.691 align:middle line:-1
而是要将

00:25:24.892 --> 00:25:27.628 align:middle line:-1
激活记入数据结构

00:25:27.995 --> 00:25:30.497 align:middle line:-1
叫做agenda

00:25:32.032 --> 00:25:35.602 align:middle line:-1
agenda实际是激活列表

00:25:35.669 --> 00:25:37.471 align:middle line:-1
是工作记忆更新的结果

00:25:37.638 --> 00:25:39.006 align:middle line:-1
因此所有规则引擎都要

00:25:39.072 --> 00:25:41.008 align:middle line:-1
从上而下过一遍这个列表

00:25:41.074 --> 00:25:43.343 align:middle line:-1
以特定的模式触发规则

00:25:44.244 --> 00:25:46.813 align:middle line:-2
这里先触发第一个规则
然后是第二个

00:25:47.047 --> 00:25:48.515 align:middle line:-1
这个数据结构是动态的

00:25:48.582 --> 00:25:51.718 align:middle line:-1
如果规则99是要撤回事实17

00:25:52.419 --> 00:25:55.822 align:middle line:-1
而事实17由其他两个激活引用

00:25:55.889 --> 00:26:00.127 align:middle line:-2
CLIPS会先撤回激活
然后往下走

00:26:00.194 --> 00:26:02.729 align:middle line:-1
此时agenda会是这样

00:26:02.796 --> 00:26:04.498 align:middle line:-1
在执行继续时

00:26:05.966 --> 00:26:09.837 align:middle line:-2
agenda根据突出性排序
那么salience就很重要

00:26:09.903 --> 00:26:11.738 align:middle line:-2
突出值越高 agenda上的
位置就越高

00:26:12.472 --> 00:26:13.941 align:middle line:-1
但更重要的是

00:26:14.007 --> 00:26:17.010 align:middle line:-1
模块中没有单独的agenda

00:26:17.077 --> 00:26:19.379 align:middle line:-1
定义中一个模块只有一个

00:26:19.713 --> 00:26:21.648 align:middle line:-1
在分析内核中可以用它

00:26:21.715 --> 00:26:24.017 align:middle line:-1
定义部分标准模块

00:26:24.651 --> 00:26:26.553 align:middle line:-1
第一个是建模模块

00:26:26.620 --> 00:26:29.790 align:middle line:-1
这里要放入纯推理逻辑

00:26:29.857 --> 00:26:32.125 align:middle line:-1
和推理规则

00:26:32.192 --> 00:26:34.928 align:middle line:-1
将规则名设为modeler::

00:26:35.896 --> 00:26:39.433 align:middle line:-1
第二个模块是recorder

00:26:39.499 --> 00:26:41.502 align:middle line:-1
放入的是输出规则

00:26:41.568 --> 00:26:43.704 align:middle line:-1
前缀为recorder::

00:26:44.304 --> 00:26:45.506 align:middle line:-1
这么做的原因是

00:26:46.006 --> 00:26:48.275 align:middle line:-1
在执行这些规则时

00:26:48.642 --> 00:26:51.879 align:middle line:-2
首先执行所有模块
agenda上的内容

00:26:52.212 --> 00:26:53.380 align:middle line:-1
直到清空

00:26:53.447 --> 00:26:55.582 align:middle line:-1
然后再到recorder模块

00:26:56.016 --> 00:26:58.418 align:middle line:-1
它会让你拥有自信

00:26:58.719 --> 00:27:00.354 align:middle line:-1
在写输出规则时

00:27:00.521 --> 00:27:02.122 align:middle line:-1
不用查看工作记忆中

00:27:02.189 --> 00:27:04.825 align:middle line:-1
modeler模块推出的过程

00:27:05.759 --> 00:27:07.127 align:middle line:-1
现在你可以利用这个

00:27:07.194 --> 00:27:09.763 align:middle line:-1
自定义CLIPS模块

00:27:09.830 --> 00:27:11.698 align:middle line:-1
现在看看如何实现

00:27:11.965 --> 00:27:16.103 align:middle line:-1
更好的调整查找规则的执行

00:27:16.904 --> 00:27:20.207 align:middle line:-2
首先是定义查找规则模块
lookup

00:27:21.008 --> 00:27:23.210 align:middle line:-1
将查找规则放到

00:27:23.277 --> 00:27:26.079 align:middle line:-1
模块里 命名为lookup::

00:27:27.247 --> 00:27:30.284 align:middle line:-1
确认移动主体事实后

00:27:30.684 --> 00:27:35.155 align:middle line:-2
要立刻告诉CLIPS
关注查找agenda

00:27:35.355 --> 00:27:38.058 align:middle line:-2
就是运行查找agenda里的
所有激活进程

00:27:38.525 --> 00:27:41.395 align:middle line:-2
然后返回
modeler agenda

00:27:41.628 --> 00:27:43.397 align:middle line:-1
执行下一套建模规则

00:27:43.463 --> 00:27:45.232 align:middle line:-1
这是防止规则插入

00:27:45.299 --> 00:27:48.202 align:middle line:-1
执行顺序的好方法

00:27:49.069 --> 00:27:50.771 align:middle line:-1
以上内容已经很充足

00:27:51.071 --> 00:27:55.075 align:middle line:-1
现在可以看看调试和剖析了

00:27:55.142 --> 00:27:58.045 align:middle line:-2
现在有请Alejandro
回到舞台

00:27:58.345 --> 00:27:59.246 align:middle line:-1
讲解这一部分

00:28:06.653 --> 00:28:09.556 align:middle line:-1
我要讲的是调试和剖析基元

00:28:09.623 --> 00:28:11.792 align:middle line:-1
用于搭建这些模块

00:28:12.492 --> 00:28:13.727 align:middle line:-1
首先是日志

00:28:14.294 --> 00:28:16.730 align:middle line:-1
我们可用的日志基元

00:28:16.897 --> 00:28:20.100 align:middle line:-2
很像printf
用来定义格式化字符串

00:28:20.400 --> 00:28:24.671 align:middle line:-1
格式化标记和代表这些类别的变量

00:28:25.506 --> 00:28:28.175 align:middle line:-2
与printf或其常用方法
不同的是

00:28:28.642 --> 00:28:29.776 align:middle line:-1
在工具查看器

00:28:29.843 --> 00:28:31.578 align:middle line:-1
实际上可以动态的

00:28:31.645 --> 00:28:33.180 align:middle line:-1
开关日志声明

00:28:33.247 --> 00:28:34.715 align:middle line:-1
之后会举例说明

00:28:35.716 --> 00:28:38.418 align:middle line:-1
怎么把这些日志声明放入规则？

00:28:39.319 --> 00:28:41.522 align:middle line:-2
CLIPS里有个函数
log-narrative

00:28:41.922 --> 00:28:43.657 align:middle line:-1
它的运行 如我之前所讲

00:28:43.724 --> 00:28:46.226 align:middle line:-1
很像printf 定义字符串

00:28:46.293 --> 00:28:48.028 align:middle line:-1
比如Resolved Agent Kind Code

00:28:48.462 --> 00:28:50.864 align:middle line:-1
然后用%定义格式类别

00:28:51.164 --> 00:28:52.366 align:middle line:-1
实际的工程类别

00:28:52.533 --> 00:28:56.403 align:middle line:-2
这里是UN 64
后跟% to string

00:28:56.770 --> 00:28:59.206 align:middle line:-1
然后是表示数据类别的变量

00:29:04.945 --> 00:29:06.914 align:middle line:-1
就是剖析 通过工具查看器

00:29:07.514 --> 00:29:10.551 align:middle line:-1
剖析基元提供的是规则激活计数

00:29:10.617 --> 00:29:12.853 align:middle line:-1
让我们知道规则触发的次数

00:29:13.420 --> 00:29:14.988 align:middle line:-1
以及时间分布

00:29:15.055 --> 00:29:17.357 align:middle line:-1
我们能知道用了多少秒

00:29:17.424 --> 00:29:20.127 align:middle line:-1
去激活规则 按百分比计算

00:29:20.794 --> 00:29:22.196 align:middle line:-1
为了整体理解

00:29:22.462 --> 00:29:23.730 align:middle line:-1
我要做一个演示

00:29:23.797 --> 00:29:25.532 align:middle line:-1
看看它们怎样放到一起

00:29:29.636 --> 00:29:32.472 align:middle line:-1
这里是样本代码 也是可以下载的

00:29:32.739 --> 00:29:33.674 align:middle line:-1
样本代码中

00:29:33.740 --> 00:29:35.409 align:middle line:-1
有很多可用的不同目标

00:29:35.909 --> 00:29:37.377 align:middle line:-1
我首先要讲的

00:29:37.444 --> 00:29:40.347 align:middle line:-1
是这里的绘制模板建模对象

00:29:41.381 --> 00:29:44.451 align:middle line:-1
它会在创建和运行工具的时候打开

00:29:47.020 --> 00:29:48.188 align:middle line:-1
好像已经搭建成功了

00:29:50.891 --> 00:29:52.693 align:middle line:-1
然后打开工具

00:29:54.027 --> 00:29:58.031 align:middle line:-1
这里那个羊的app已经打开

00:29:58.365 --> 00:29:59.499 align:middle line:-1
我不会最大化窗口

00:29:59.566 --> 00:30:02.102 align:middle line:-1
因为我们要记在脑子里

00:30:02.836 --> 00:30:04.838 align:middle line:-1
我要做的是回到空白模板

00:30:05.639 --> 00:30:06.974 align:middle line:-1
在右上角

00:30:07.040 --> 00:30:08.742 align:middle line:-1
选择要添加的工具

00:30:08.809 --> 00:30:11.245 align:middle line:-1
为此 打开这里

00:30:11.778 --> 00:30:15.582 align:middle line:-1
查找移动主体 就是刚建的目标

00:30:17.184 --> 00:30:18.685 align:middle line:-1
这里 如我所说

00:30:18.752 --> 00:30:21.255 align:middle line:-1
日志叙述可动态开关

00:30:21.321 --> 00:30:22.589 align:middle line:-1
通过工具查看器

00:30:22.656 --> 00:30:23.857 align:middle line:-1
按下command I

00:30:24.191 --> 00:30:25.792 align:middle line:-1
打开工具查看器

00:30:26.059 --> 00:30:28.629 align:middle line:-1
这有个日志标签 默认为无

00:30:28.829 --> 00:30:30.397 align:middle line:-1
但可以改成narrative

00:30:30.464 --> 00:30:32.266 align:middle line:-1
这样就开启了日志叙述声明

00:30:33.133 --> 00:30:34.268 align:middle line:-1
关闭它 继续

00:30:34.434 --> 00:30:36.036 align:middle line:-1
代替所有进程

00:30:36.103 --> 00:30:37.804 align:middle line:-1
现在切换到山羊的列表app

00:30:39.606 --> 00:30:40.641 align:middle line:-1
现在开始记录

00:30:40.974 --> 00:30:42.809 align:middle line:-1
在这个列表里可以进行一些操作

00:30:42.876 --> 00:30:44.811 align:middle line:-1
比如给不同的列表排序

00:30:45.312 --> 00:30:47.414 align:middle line:-1
你看到查看器里弹出一些活动

00:30:48.515 --> 00:30:50.884 align:middle line:-1
再点一次 会有更多活动弹出

00:30:51.385 --> 00:30:53.220 align:middle line:-1
我想这个点已经足够清楚了

00:30:54.655 --> 00:30:56.023 align:middle line:-1
首先我们看这里

00:30:56.790 --> 00:30:59.293 align:middle line:-1
显示不同的区间 我们之前讲过

00:30:59.359 --> 00:31:02.329 align:middle line:-1
比如激活和移动等等

00:31:03.063 --> 00:31:04.698 align:middle line:-1
但在实际的叙述声明

00:31:04.765 --> 00:31:07.167 align:middle line:-1
还是command I打开查看器

00:31:08.001 --> 00:31:10.737 align:middle line:-1
有新的东西 这个模块日志表

00:31:11.004 --> 00:31:12.406 align:middle line:-1
在这个表里

00:31:12.472 --> 00:31:14.308 align:middle line:-1
存着所有日志叙述声明

00:31:14.675 --> 00:31:16.977 align:middle line:-1
比如这个解析代理类型代码

00:31:17.044 --> 00:31:19.179 align:middle line:-1
使用日志叙述的例子里看到过

00:31:19.646 --> 00:31:21.682 align:middle line:-1
还有规则里的许多其他声明

00:31:23.550 --> 00:31:26.320 align:middle line:-1
那如何从日志叙述切换到剖析呢

00:31:26.653 --> 00:31:28.956 align:middle line:-1
还是在这个日志标签

00:31:29.022 --> 00:31:30.858 align:middle line:-1
切换到profile 1

00:31:31.725 --> 00:31:33.260 align:middle line:-1
关闭查看器

00:31:33.694 --> 00:31:35.128 align:middle line:-1
再次运行工具

00:31:35.295 --> 00:31:36.363 align:middle line:-1
再次记录轨迹

00:31:37.030 --> 00:31:39.233 align:middle line:-1
这时看到列表已经排序过了

00:31:39.299 --> 00:31:41.969 align:middle line:-1
但移动主体还是发生了一些活动

00:31:42.903 --> 00:31:44.905 align:middle line:-1
这也足够说明问题了

00:31:45.873 --> 00:31:49.009 align:middle line:-1
所以停止 再次打开查看器

00:31:49.943 --> 00:31:53.380 align:middle line:-2
这里就不再有模块日志表
因为没有可显示的日志叙述了

00:31:54.014 --> 00:31:56.450 align:middle line:-1
但是如果打开这里的模块标签

00:31:57.017 --> 00:31:59.353 align:middle line:-1
会看到整洁的描述性界面

00:31:59.419 --> 00:32:01.255 align:middle line:-1
列出不同的剖析值

00:32:01.555 --> 00:32:04.758 align:middle line:-1
比如这个“查看未知执行站点”规则

00:32:05.092 --> 00:32:09.029 align:middle line:-2
有7条记录
还显示了用时和时间占比

00:32:09.596 --> 00:32:12.232 align:middle line:-1
还有其他建模过程中定义的规则

00:32:13.867 --> 00:32:15.035 align:middle line:-1
在关闭这个界面之前

00:32:15.302 --> 00:32:17.404 align:middle line:-1
我发现一些有趣的点

00:32:17.471 --> 00:32:18.705 align:middle line:-1
我要再运行一次追踪

00:32:18.772 --> 00:32:21.108 align:middle line:-1
因为我想再捕捉一次

00:32:22.109 --> 00:32:24.611 align:middle line:-1
开启排序后 我看到不同的活动出现

00:32:25.245 --> 00:32:26.580 align:middle line:-1
但如果我再次排序

00:32:26.647 --> 00:32:28.582 align:middle line:-1
我注意到这些黄色的长区间

00:32:28.649 --> 00:32:29.716 align:middle line:-1
出现在事实后面

00:32:29.783 --> 00:32:34.721 align:middle line:-2
它们对实时描述或实时解读的跟踪
不同于

00:32:34.788 --> 00:32:36.023 align:middle line:-1
我的预判

00:32:36.823 --> 00:32:38.525 align:middle line:-1
为了找到原因

00:32:38.592 --> 00:32:41.562 align:middle line:-1
搞清楚状况 并找到解决办法

00:32:41.828 --> 00:32:43.964 align:middle line:-1
我要请回Chad 讲解推断

00:32:51.772 --> 00:32:53.106 align:middle line:-1
谢谢Alejandro

00:32:54.208 --> 00:32:57.611 align:middle line:-2
为了描述Alejandro
刚才看到的现象

00:32:57.678 --> 00:32:58.579 align:middle line:-1
并解决它

00:32:58.645 --> 00:33:00.814 align:middle line:-1
就要引入一个概念 叫做推断

00:33:01.849 --> 00:33:03.383 align:middle line:-1
这些区间怎么了？

00:33:03.650 --> 00:33:05.953 align:middle line:-1
它们的特点 第一是长区间

00:33:06.019 --> 00:33:09.056 align:middle line:-2
它们出现的时间
或持续的时间有好几秒

00:33:09.122 --> 00:33:10.524 align:middle line:-1
这显而易见

00:33:11.124 --> 00:33:13.794 align:middle line:-1
第二 真正的问题是

00:33:13.861 --> 00:33:15.796 align:middle line:-1
对这些区间的记录

00:33:15.863 --> 00:33:17.764 align:middle line:-1
只在模块的工作记忆中

00:33:17.998 --> 00:33:21.001 align:middle line:-1
UI只看模块的输出表

00:33:21.068 --> 00:33:22.436 align:middle line:-1
不会看这些

00:33:22.936 --> 00:33:26.807 align:middle line:-2
所以不能把这些区间写入输出表
直到明确了

00:33:26.874 --> 00:33:28.108 align:middle line:-1
它们关闭的时间

00:33:28.175 --> 00:33:30.878 align:middle line:-1
这个例子就是这样

00:33:31.578 --> 00:33:33.113 align:middle line:-1
现在要做的是

00:33:33.180 --> 00:33:35.782 align:middle line:-1
写入临时或占位符行

00:33:35.849 --> 00:33:37.784 align:middle line:-1
给模块的输出表

00:33:37.985 --> 00:33:40.721 align:middle line:-1
为此就要介绍推断模式

00:33:41.922 --> 00:33:44.391 align:middle line:-1
模块中的推断模式表示

00:33:44.458 --> 00:33:47.661 align:middle line:-1
如果这是最后写入输入表的机会

00:33:48.028 --> 00:33:49.463 align:middle line:-1
你要写什么？

00:33:49.897 --> 00:33:51.164 align:middle line:-1
来看个例子

00:33:51.732 --> 00:33:55.102 align:middle line:-2
假设模块处理了
这条白线之前的所有数据

00:33:55.169 --> 00:33:57.137 align:middle line:-1
我们叫做视界

00:33:57.638 --> 00:34:01.308 align:middle line:-2
视界是一个时间点
此后模块看不到任何东西

00:34:01.475 --> 00:34:04.144 align:middle line:-1
原因可能是追踪停止了

00:34:04.478 --> 00:34:06.113 align:middle line:-1
或者分析内核

00:34:06.180 --> 00:34:08.882 align:middle line:-1
还没填入追踪部分

00:34:09.349 --> 00:34:11.552 align:middle line:-1
没人知道线的另一边有什么

00:34:11.985 --> 00:34:14.288 align:middle line:-1
如你所见 我们创建的区间写着

00:34:14.353 --> 00:34:15.489 align:middle line:-1
移动到后台

00:34:15.688 --> 00:34:17.123 align:middle line:-1
这样做是因为它夹在

00:34:17.190 --> 00:34:19.760 align:middle line:-2
一对移动和执行
Signpost之间

00:34:20.260 --> 00:34:23.797 align:middle line:-2
但我们不知道
这个追踪执行区间什么时候结束

00:34:23.864 --> 00:34:26.132 align:middle line:-1
因为它的结束事件在视界的另一边

00:34:26.699 --> 00:34:29.503 align:middle line:-1
因此我们要进入推断模式

00:34:29.670 --> 00:34:32.706 align:middle line:-1
只要在表中写入临时占位符事件

00:34:33.005 --> 00:34:34.842 align:middle line:-1
UI就能看到些什么

00:34:35.475 --> 00:34:39.545 align:middle line:-1
然运行区间从执行Signpost

00:34:39.780 --> 00:34:42.081 align:middle line:-1
直到视界的当前值

00:34:43.283 --> 00:34:45.518 align:middle line:-1
推断模式里的模块

00:34:45.585 --> 00:34:47.154 align:middle line:-1
因为推断事实

00:34:47.221 --> 00:34:50.389 align:middle line:-1
会被注入到工作记忆

00:34:51.123 --> 00:34:52.559 align:middle line:-1
在记录规则中

00:34:52.626 --> 00:34:55.728 align:middle line:-2
可以将推断事实
与任何开区间事实结合

00:34:55.795 --> 00:34:59.466 align:middle line:-1
把这些开区间写入表

00:34:59.533 --> 00:35:01.401 align:middle line:-1
用捕捉到的视界时间戳

00:35:02.503 --> 00:35:04.905 align:middle line:-1
这里就是写入开区间的机会

00:35:05.873 --> 00:35:08.442 align:middle line:-1
下面来看一个示例规则

00:35:08.976 --> 00:35:11.144 align:middle line:-1
首先 将推断式的

00:35:11.512 --> 00:35:13.480 align:middle line:-1
输出编写规则放入记录模块

00:35:13.547 --> 00:35:15.516 align:middle line:-1
前缀为RECORDER::

00:35:16.750 --> 00:35:19.052 align:middle line:-1
然后匹配推断事件

00:35:19.119 --> 00:35:21.121 align:middle line:-1
捕捉视界的值

00:35:21.188 --> 00:35:24.625 align:middle line:-1
这就有了区间的结束时间 理论上

00:35:25.459 --> 00:35:28.762 align:middle line:-1
对工作记忆中的每个区间事实

00:35:28.829 --> 00:35:30.898 align:middle line:-1
触发规则的右边

00:35:31.398 --> 00:35:32.633 align:middle line:-1
我们这里要做的

00:35:32.699 --> 00:35:36.203 align:middle line:-2
是基于结束时间
也就是视界值计算时长

00:35:36.270 --> 00:35:38.605 align:middle line:-1
和区间开始的时间

00:35:39.273 --> 00:35:42.376 align:middle line:-1
然后写新的行 填写栏内容

00:35:42.442 --> 00:35:44.244 align:middle line:-1
和正常的输出编写规则一样

00:35:44.311 --> 00:35:45.379 align:middle line:-1
唯一区分

00:35:45.445 --> 00:35:48.415 align:middle line:-1
正常的和推断式的输出编写规则

00:35:48.916 --> 00:35:53.020 align:middle line:-1
在于当你测试或预测推断事实的规则

00:35:53.453 --> 00:35:56.657 align:middle line:-1
你要查看开区间 而不是闭区间

00:35:56.723 --> 00:35:59.359 align:middle line:-1
像往常编写输出表那样

00:36:03.263 --> 00:36:06.300 align:middle line:-1
在记录前进的过程中

00:36:06.867 --> 00:36:09.670 align:middle line:-1
旧的推断性数据会被清洗

00:36:09.736 --> 00:36:11.872 align:middle line:-1
模块会再次进入推断模式

00:36:11.939 --> 00:36:13.874 align:middle line:-1
以新的视界值

00:36:14.174 --> 00:36:16.376 align:middle line:-1
放回推断事件

00:36:16.643 --> 00:36:19.346 align:middle line:-1
UI会跟往常一样更新

00:36:19.980 --> 00:36:24.751 align:middle line:-2
追踪停止时
模块会再次进入推断模式

00:36:25.085 --> 00:36:26.386 align:middle line:-1
但无论你写什么

00:36:26.453 --> 00:36:29.690 align:middle line:-1
实际都记录在追踪数据中

00:36:29.857 --> 00:36:32.860 align:middle line:-1
对下行模块可用 不仅是UI

00:36:33.827 --> 00:36:37.297 align:middle line:-1
如果修改现有的工具

00:36:37.898 --> 00:36:39.433 align:middle line:-1
它就会变成这样

00:36:39.766 --> 00:36:42.202 align:middle line:-1
这是移动主体轨迹 你看到

00:36:42.269 --> 00:36:45.873 align:middle line:-1
这个parking区间持续延长

00:36:46.440 --> 00:36:47.474 align:middle line:-1
它会实时更新

00:36:47.541 --> 00:36:49.076 align:middle line:-1
如果查看底部的细节表

00:36:49.142 --> 00:36:51.578 align:middle line:-1
你会看到 时长也在增加

00:36:52.279 --> 00:36:55.115 align:middle line:-1
现在如果按下停止键 终止记录

00:36:55.182 --> 00:36:56.950 align:middle line:-1
你会看到区间停住了

00:36:57.017 --> 00:36:59.853 align:middle line:-1
它实际上被记录为轨迹的一部分

00:37:03.557 --> 00:37:05.392 align:middle line:-1
代表巨大的投入

00:37:05.459 --> 00:37:07.394 align:middle line:-1
要投入时间学习新的技术

00:37:07.761 --> 00:37:10.831 align:middle line:-1
但这是使用自定义工具的最好方式

00:37:10.898 --> 00:37:13.433 align:middle line:-1
并智能化自定义工具

00:37:13.800 --> 00:37:15.969 align:middle line:-1
我们看到 智能化工具

00:37:16.036 --> 00:37:18.572 align:middle line:-1
意味着更高效的记录机制

00:37:18.639 --> 00:37:20.274 align:middle line:-1
和更好的用户体验

00:37:21.975 --> 00:37:24.211 align:middle line:-1
更多信息 请参见随附的样本代码

00:37:24.278 --> 00:37:27.981 align:middle line:-1
以及本场演讲网站中的相关演讲

00:37:28.982 --> 00:37:30.884 align:middle line:-1
以上就是今天的内容 谢谢大家

00:37:30.951 --> 00:37:31.852 align:middle line:-1
请享受其余的讲演

