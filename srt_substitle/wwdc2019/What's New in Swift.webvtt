WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:00.506 --> 00:00:04.500 A:middle
[音乐]

00:00:13.131 --> 00:00:15.131 A:middle
[掌声]

00:00:15.246 --> 00:00:15.906 A:middle
&gt;&gt; 早上好

00:00:16.856 --> 00:00:18.716 A:middle
欢迎来到 What's New in Swift 专场

00:00:19.786 --> 00:00:21.086 A:middle
今天 我们将讨论两个重要

00:00:21.146 --> 00:00:23.856 A:middle
且令人兴奋的 Swift 发布版本

00:00:24.276 --> 00:00:28.876 A:middle
Swift 5 是我们最近在三月份发布的版本

00:00:29.036 --> 00:00:32.906 A:middle
Swift 5.1 现在可以在 Xcode 11 中使用开发者预览版

00:00:34.196 --> 00:00:36.326 A:middle
有了这两个新的版本

00:00:36.326 --> 00:00:41.156 A:middle
我们进一步释放了 Swift 作为语言和技术的潜力

00:00:41.216 --> 00:00:42.986 A:middle
Apple 和你们所有人都可以

00:00:43.276 --> 00:00:45.616 A:middle
在此基础上进行开发

00:00:46.666 --> 00:00:49.326 A:middle
从 Swift 和 API 的

00:00:49.326 --> 00:00:54.666 A:middle
强大组合的形式中获益

00:00:55.756 --> 00:00:58.136 A:middle
现在 Apple 的操作系统

00:00:58.206 --> 00:00:59.876 A:middle
已经为第三方 App 提供了

00:00:59.876 --> 00:01:02.356 A:middle
共享的 Swift Runtime

00:01:02.356 --> 00:01:03.726 A:middle
并且用 Swift 写的二进制框架

00:01:03.726 --> 00:01:05.716 A:middle
现在已经可以部署

00:01:06.326 --> 00:01:08.416 A:middle
使用这些 Apple 做出了

00:01:08.616 --> 00:01:10.856 A:middle
仅用于 Swift 的跑马灯效果框架

00:01:11.926 --> 00:01:14.136 A:middle
此外 在 Xcode 中

00:01:14.486 --> 00:01:15.826 A:middle
对 Swift 包管理器的集成支持

00:01:15.826 --> 00:01:17.296 A:middle
使得 Swift 包可以直接

00:01:17.296 --> 00:01:21.516 A:middle
进入 App 开发的核心工作流中

00:01:22.166 --> 00:01:25.066 A:middle
同时 Swift 语言本身有了新的可供性

00:01:25.066 --> 00:01:27.886 A:middle
来构建精美丰富的 API

00:01:28.396 --> 00:01:31.216 A:middle
也有了用于表达 API 发展的新特性

00:01:31.716 --> 00:01:33.096 A:middle
对于该语言及其整个生态环境来说

00:01:33.096 --> 00:01:36.306 A:middle
这都是一个非常激动人心的时刻

00:01:36.966 --> 00:01:38.716 A:middle
那么让我们开始吧

00:01:38.716 --> 00:01:42.296 A:middle
首先我要多说几句二进制框架

00:01:42.296 --> 00:01:43.806 A:middle
特别是深入谈谈

00:01:43.806 --> 00:01:46.176 A:middle
促成这一发展的核心要素

00:01:46.846 --> 00:01:48.536 A:middle
那些要素就是 ABI 稳定性

00:01:48.536 --> 00:01:50.256 A:middle
及模块稳定性

00:01:51.516 --> 00:01:56.496 A:middle
ABI 就是 Application Binary Interface

00:01:56.496 --> 00:01:57.966 A:middle
它是一些规则 用来控制编译后的代码

00:01:57.966 --> 00:02:01.766 A:middle
如何在运行时进行交互的具体细节

00:02:02.576 --> 00:02:04.636 A:middle
就像是函数调用这样的细节

00:02:04.916 --> 00:02:06.796 A:middle
那么它究竟是如何工作的

00:02:07.416 --> 00:02:12.636 A:middle
参数中的值是如何从调用者传递给被调用者的呢

00:02:13.086 --> 00:02:14.386 A:middle
可用的元数据是什么

00:02:14.386 --> 00:02:15.506 A:middle
它在内存中又是如何排列的

00:02:15.626 --> 00:02:16.766 A:middle
所有这些细节都是

00:02:16.766 --> 00:02:19.436 A:middle
编译后的代码相互作用时所必须的

00:02:19.766 --> 00:02:21.526 A:middle
因此为了说明这个观点

00:02:21.526 --> 00:02:24.116 A:middle
假设你有一个用 Swift 写的程序

00:02:24.236 --> 00:02:25.626 A:middle
它是一个 App

00:02:25.626 --> 00:02:27.246 A:middle
可以是命令行工具 这并不是很重要 

00:02:27.246 --> 00:02:28.876 A:middle
只要是可执行的

00:02:29.706 --> 00:02:33.756 A:middle
它使用的框架也是用 Swift 写的

00:02:33.756 --> 00:02:35.066 A:middle
而所有的这些已编译代码

00:02:35.066 --> 00:02:37.786 A:middle
是在一个运行过程中一起运行的

00:02:37.876 --> 00:02:40.926 A:middle
那么这个可执行文件

00:02:41.116 --> 00:02:42.146 A:middle
正在使用框架中的 API

00:02:42.186 --> 00:02:44.456 A:middle
它们必须能在运行时与彼此进行对话

00:02:45.246 --> 00:02:46.966 A:middle
那么 为了完成这个

00:02:46.966 --> 00:02:48.186 A:middle
它们必须有一个可兼容的 ABI

00:02:48.186 --> 00:02:50.926 A:middle
就像这两段代码是被分开进行编译的

00:02:51.006 --> 00:02:53.856 A:middle
但编译后的代码则需要一起共同工作

00:02:54.436 --> 00:02:56.296 A:middle
在 ABI 稳定性之前

00:02:56.296 --> 00:02:58.876 A:middle
我们唯一能保证的是

00:02:59.066 --> 00:03:00.546 A:middle
它们会有一个可兼容的 ABI

00:03:00.546 --> 00:03:02.966 A:middle
只要构建它们的编译器是相同的

00:03:03.056 --> 00:03:04.826 A:middle
之所以这样 是因为

00:03:04.826 --> 00:03:08.176 A:middle
我们真的是在发展 Swift 的核心基础要素

00:03:08.176 --> 00:03:09.746 A:middle
以确保所有我们

00:03:09.746 --> 00:03:13.096 A:middle
想要的构建块都被放在合适的位置上

00:03:13.096 --> 00:03:14.106 A:middle
以便在未来进行构建

00:03:14.766 --> 00:03:18.286 A:middle
那么 在 Swift 5 中我们已经明确了那些细节

00:03:18.386 --> 00:03:20.436 A:middle
现在的 Swift 已有了 ABI 稳定性

00:03:20.436 --> 00:03:23.796 A:middle
这意味着这两个组件不再需要用相同的编译器进行构建了

00:03:23.796 --> 00:03:25.826 A:middle
只要它们是用 Swift 5 编译器

00:03:25.826 --> 00:03:28.106 A:middle
或更新的版本进行构建的

00:03:28.676 --> 00:03:31.386 A:middle
第二个重要的要素

00:03:31.386 --> 00:03:33.346 A:middle
就是模块的稳定性

00:03:33.346 --> 00:03:35.146 A:middle
这是一个编译时的概念

00:03:35.146 --> 00:03:36.996 A:middle
如果你有一个 Swift 框架

00:03:37.156 --> 00:03:38.966 A:middle
使用该框架内的所有 API

00:03:38.966 --> 00:03:43.076 A:middle
那么这些就都是一个被称为模块的共享命名空间的一部分

00:03:43.466 --> 00:03:48.296 A:middle
当 Swift 编译器构建该框架时

00:03:48.296 --> 00:03:53.716 A:middle
它会生成该框架中的所有 API 的 Manifest

00:03:53.716 --> 00:03:56.326 A:middle
之后该框架的客户端就可以使用这些 API

00:03:56.636 --> 00:03:58.776 A:middle
该 Manifest 被称为 Swift 模块文件

00:03:59.196 --> 00:04:00.666 A:middle
那么如果我们回到这个例子

00:04:00.666 --> 00:04:03.346 A:middle
我们就假设我们正在编译程序

00:04:03.386 --> 00:04:04.716 A:middle
有一个源文件

00:04:04.716 --> 00:04:06.396 A:middle
它引用了该框架

00:04:06.466 --> 00:04:09.216 A:middle
接下来该编译器就会去读取模块文件

00:04:09.256 --> 00:04:11.416 A:middle
并获取可用的 API

00:04:11.416 --> 00:04:14.246 A:middle
但是这个模块文件里的细节真的很丰富

00:04:14.246 --> 00:04:17.326 A:middle
并且在很多方面

00:04:17.326 --> 00:04:19.826 A:middle
与编译器本身紧密耦合

00:04:19.826 --> 00:04:22.746 A:middle
所以我们就有和 ABI 稳定性相同的问题了

00:04:22.746 --> 00:04:24.016 A:middle
那么唯一的办法就是

00:04:24.016 --> 00:04:27.446 A:middle
这两块必须要用相同的编译器进行编译

00:04:28.026 --> 00:04:33.446 A:middle
在 Swift 5.1 里我们引入了一个新的补充 Manifest

00:04:33.936 --> 00:04:36.396 A:middle
它被称为 Swift 模块接口文件

00:04:36.996 --> 00:04:38.766 A:middle
它可以被框架用来提供

00:04:39.186 --> 00:04:42.896 A:middle
用户端可以使用的稳定接口

00:04:43.666 --> 00:04:45.736 A:middle
而如果你将它打开

00:04:45.736 --> 00:04:47.816 A:middle
它看起来就像 Swift 源代码

00:04:47.866 --> 00:04:50.836 A:middle
它也是被构建在源稳定性的概念上的

00:04:50.836 --> 00:04:52.776 A:middle
这个概念在 Swift 中很早就有了

00:04:53.086 --> 00:04:54.946 A:middle
那么有了这两个要素

00:04:55.186 --> 00:04:57.626 A:middle
你就可以得到可以部署

00:04:57.626 --> 00:05:00.296 A:middle
并与他人共享的 Swift 框架

00:05:01.516 --> 00:05:06.546 A:middle
[掌声]

00:05:07.046 --> 00:05:08.096 A:middle
那么我们有很多十分有趣的

00:05:08.096 --> 00:05:09.576 A:middle
关于 ABI 稳定性的细节

00:05:09.576 --> 00:05:10.786 A:middle
我们已经准备了

00:05:10.786 --> 00:05:13.216 A:middle
很长一段时间了

00:05:13.216 --> 00:05:14.386 A:middle
如果你有兴趣

00:05:14.386 --> 00:05:15.896 A:middle
了解更多的细节

00:05:15.896 --> 00:05:16.946 A:middle
我们今天就要向大家介绍

00:05:16.946 --> 00:05:19.326 A:middle
swift.org 是一个很好的资源

00:05:19.326 --> 00:05:23.056 A:middle
这是 Swift 开放源代码的项目的主页

00:05:23.056 --> 00:05:24.136 A:middle
里面有很多很棒的

00:05:24.136 --> 00:05:26.276 A:middle
关于 ABI 稳定性的博客文章

00:05:27.816 --> 00:05:29.286 A:middle
同时 如果你有兴趣

00:05:29.286 --> 00:05:33.576 A:middle
使用二进制框架来为你自己所用

00:05:33.576 --> 00:05:34.416 A:middle
比如与他人进行共享

00:05:34.416 --> 00:05:35.866 A:middle
我们会在这周晚些时候的

00:05:35.866 --> 00:05:37.176 A:middle
Swift 中的 Binary Frameworks in Swift 专场中

00:05:37.176 --> 00:05:38.976 A:middle
对这些进行讨论

00:05:39.276 --> 00:05:40.256 A:middle
届时我们还会讨论

00:05:40.256 --> 00:05:41.666 A:middle
当与他人共享框架时

00:05:41.996 --> 00:05:44.036 A:middle
你应该进行考虑的一些事项

00:05:45.316 --> 00:05:48.286 A:middle
那么二进制框架只是 API 中要为大家介绍的一个部分

00:05:48.286 --> 00:05:51.116 A:middle
另一个重要的部分就是 Swift 包

00:05:51.946 --> 00:05:53.336 A:middle
现在 Xcode 中已经

00:05:53.336 --> 00:05:55.216 A:middle
集成了 Swift 包管理器

00:05:55.626 --> 00:05:58.816 A:middle
它们是创建 App 的核心工作流的一部分

00:05:59.666 --> 00:06:00.826 A:middle
这周还会有两个关于

00:06:00.826 --> 00:06:04.206 A:middle
在 Xcode 中创建和使用包的专场

00:06:04.296 --> 00:06:07.766 A:middle
二进制框架和 Swift 包的结合

00:06:07.766 --> 00:06:09.346 A:middle
为我们提供了一组非常丰富的选项

00:06:09.346 --> 00:06:12.766 A:middle
来与他人共享 API

00:06:14.556 --> 00:06:15.966 A:middle
那么让我们换个话题

00:06:15.966 --> 00:06:17.386 A:middle
来谈谈性能

00:06:18.066 --> 00:06:20.386 A:middle
Swift 语言是一种

00:06:20.386 --> 00:06:22.326 A:middle
现代的 安全的

00:06:22.326 --> 00:06:24.216 A:middle
且高性能的编程语言

00:06:24.856 --> 00:06:25.856 A:middle
同时 ABI 稳定性

00:06:25.856 --> 00:06:28.376 A:middle
还带来了一些关键的性能优势

00:06:29.706 --> 00:06:30.976 A:middle
其中的一个性能优势

00:06:30.976 --> 00:06:32.696 A:middle
是因为在操作系统中有了

00:06:32.696 --> 00:06:34.676 A:middle
App 所共享的 Swift Runtime

00:06:34.676 --> 00:06:37.206 A:middle
这是三月份发布的

00:06:37.206 --> 00:06:41.086 A:middle
包括 macOS iOS tvOS watchOS 以及现在的 iPadOS

00:06:41.406 --> 00:06:42.666 A:middle
在这些发布版本中都有

00:06:42.666 --> 00:06:45.176 A:middle
一个共享的 Swift Runtime

00:06:45.176 --> 00:06:46.046 A:middle
第三方 App 和 Apple 原生 App

00:06:46.046 --> 00:06:47.936 A:middle
及系统中的所有东西都在使用

00:06:48.526 --> 00:06:51.546 A:middle
那么 它究竟是如何工作

00:06:51.546 --> 00:06:54.196 A:middle
又是在什么时候开始起作用呢

00:06:54.406 --> 00:06:56.376 A:middle
如果你的 App 是用 Swift 5

00:06:56.376 --> 00:06:58.656 A:middle
或更新的版本创建的

00:06:58.716 --> 00:07:00.496 A:middle
它就会在运行的时候

00:07:00.916 --> 00:07:02.486 A:middle
使用系统中的共享 Runtime

00:07:03.636 --> 00:07:05.336 A:middle
然而 你也许仍然需要将你的 App

00:07:05.336 --> 00:07:08.496 A:middle
构建并部署到较早发行的操作系统版本中

00:07:08.496 --> 00:07:09.546 A:middle
而那时的版本还没有共享 Runtime

00:07:10.886 --> 00:07:13.976 A:middle
在这种情况下 Xcode 会继续在你的 App 中

00:07:13.976 --> 00:07:15.986 A:middle
捆绑一个 Runtime 的副本

00:07:15.986 --> 00:07:18.596 A:middle
以便它可以继续在那些较老的操作系统版本上运行

00:07:19.796 --> 00:07:24.166 A:middle
但是 我们总是倾向于使用在操作系统中的副本

00:07:24.166 --> 00:07:25.986 A:middle
那么这样一来 

00:07:25.986 --> 00:07:27.956 A:middle
当运行在较新的系统上时

00:07:28.566 --> 00:07:29.806 A:middle
这个 App 中的副本将会失效

00:07:30.536 --> 00:07:33.976 A:middle
作为优化

00:07:34.156 --> 00:07:37.906 A:middle
iOS App Store 将不提供 App 中的 Runtime 副本

00:07:38.356 --> 00:07:41.926 A:middle
当下载设备的操作系统包含 Runtime 时

00:07:41.926 --> 00:07:44.966 A:middle
为用户节约下载流量

00:07:45.606 --> 00:07:51.286 A:middle
这是一个非常重要的代码量优化

00:07:51.286 --> 00:07:52.796 A:middle
但在操作系统中拥有这个 Runtime

00:07:52.796 --> 00:07:54.526 A:middle
其真正的好处是

00:07:54.586 --> 00:07:56.476 A:middle
现在它可以作为操作系统本身的一部分

00:07:56.476 --> 00:07:58.126 A:middle
来进行优化

00:07:58.126 --> 00:07:01.676 A:middle
然后这些优化就可以转到 App 本身了

00:08:06.336 --> 00:08:08.506 A:middle
那么让我们回到过去

00:08:08.506 --> 00:08:11.496 A:middle
一年前 我们讨论了 Swift 4.2

00:08:12.996 --> 00:08:14.926 A:middle
如果你有一个 Objective-C App

00:08:14.926 --> 00:08:17.506 A:middle
它什么都不做

00:08:17.506 --> 00:08:19.166 A:middle
它只是启动 然后什么都不做

00:08:19.716 --> 00:08:21.346 A:middle
而一个 Swift App 也是

00:08:21.346 --> 00:08:22.526 A:middle
同样没有功能

00:08:22.526 --> 00:08:23.386 A:middle
它就只是启动

00:08:23.796 --> 00:08:25.446 A:middle
使用 Swift 大约会有 5% 的额外时间消耗

00:08:25.446 --> 00:08:27.326 A:middle
因为我们需要处理

00:08:27.356 --> 00:08:30.116 A:middle
嵌入的 Runtime

00:08:30.306 --> 00:08:32.546 A:middle
但是如果你的 App 是用

00:08:32.546 --> 00:08:34.265 A:middle
Swift 5 编译器重新编译的

00:08:34.265 --> 00:08:35.506 A:middle
并运行在一个有共享 Runtime 的操作系统上

00:08:35.506 --> 00:08:38.686 A:middle
这个时间消耗就没有了

00:08:39.515 --> 00:08:43.216 A:middle
[掌声]

00:08:43.716 --> 00:08:45.676 A:middle
这个真的十分重要

00:08:45.676 --> 00:08:47.006 A:middle
我的意思是 该延时是

00:08:47.006 --> 00:08:50.156 A:middle
用户要开始使用你的 App 的时间

00:08:50.156 --> 00:08:53.866 A:middle
和他们真正开始体验它的时间之间的差别

00:08:54.996 --> 00:08:56.856 A:middle
我们进行优化的

00:08:56.856 --> 00:08:58.476 A:middle
另一个重要的领域

00:08:58.476 --> 00:09:02.686 A:middle
是进一步调整编译器编译后的代码

00:09:02.686 --> 00:09:03.676 A:middle
它进一步减少了

00:09:03.676 --> 00:09:06.026 A:middle
Swift App 的代码规模

00:09:06.026 --> 00:09:07.776 A:middle
这真的很像是微调

00:09:07.776 --> 00:09:11.126 A:middle
考虑 Swift App 中特定的模式

00:09:11.126 --> 00:09:13.086 A:middle
比如说字典在生成代码时

00:09:13.086 --> 00:09:16.656 A:middle
应该怎样表示 等等

00:09:16.656 --> 00:09:19.696 A:middle
我们只是要确保编译器的输出

00:09:19.696 --> 00:09:23.406 A:middle
针对这些用例进行了优化

00:09:23.786 --> 00:09:24.756 A:middle
通过各种各样的优化

00:09:24.756 --> 00:09:29.546 A:middle
我们看到代码规模能够减少 10%

00:09:29.546 --> 00:09:31.506 A:middle
如果使用 Swift 5.1 编译器的话

00:09:31.846 --> 00:09:32.846 A:middle
如果你使用 Optimize for Size 选项

00:09:32.846 --> 00:09:36.566 A:middle
那代码规模会减少 15%

00:09:36.976 --> 00:09:39.086 A:middle
那么这是一些非常重要的优化

00:09:40.076 --> 00:09:42.786 A:middle
我们也已经继续

00:09:42.786 --> 00:09:44.536 A:middle
对桥接的性能进行完善

00:09:45.156 --> 00:09:46.246 A:middle
通过桥接 我说的是

00:09:46.246 --> 00:09:49.046 A:middle
Swift 和 Objective-C 之间的桥接

00:09:49.046 --> 00:09:52.456 A:middle
这两种语言之间有着很强的互操作性

00:09:54.556 --> 00:09:56.666 A:middle
那么 Swift 和 Objective-C

00:09:56.666 --> 00:10:00.206 A:middle
都有我们所谓的通用的流通类型

00:10:00.256 --> 00:10:01.786 A:middle
它们被用在整个 API 空间里

00:10:02.326 --> 00:10:04.206 A:middle
比如 String 和 NSString

00:10:04.556 --> 00:10:06.356 A:middle
Dictionary 以及 NSDictionary

00:10:06.356 --> 00:10:10.296 A:middle
而这些流通类型之间的互操作性

00:10:10.296 --> 00:10:11.136 A:middle
是 Swift 和 Objective-C 之间

00:10:11.136 --> 00:10:13.706 A:middle
互操作性的非常基础的部分

00:10:14.246 --> 00:10:15.646 A:middle
使用自己的流通类型的 Objective-C API

00:10:15.646 --> 00:10:19.326 A:middle
被重新映射到使用 Swift 流通类型的 Swift 中

00:10:19.506 --> 00:10:21.166 A:middle
现在的工作一个编译器

00:10:21.166 --> 00:10:23.006 A:middle
是一个编译器工作的组合

00:10:23.566 --> 00:10:24.696 A:middle
但同时还要使用到 Runtime

00:10:24.696 --> 00:10:26.116 A:middle
它在你将一个类型的值

00:10:26.116 --> 00:10:28.696 A:middle
传递为另一种类型

00:10:28.726 --> 00:10:29.956 A:middle
并跨越 API 边界时出现

00:10:31.026 --> 00:10:32.076 A:middle
这是我们进一步调整的一部分

00:10:32.076 --> 00:10:33.626 A:middle
作为 Swift 的一部分

00:10:33.676 --> 00:10:35.756 A:middle
现在是操作系统的一部分

00:10:36.676 --> 00:10:39.106 A:middle
比如现在 NSDictionary

00:10:39.106 --> 00:10:40.256 A:middle
和 Dictionary 之间的桥接速度

00:10:40.256 --> 00:10:42.156 A:middle
比之前快 1.6 倍

00:10:43.186 --> 00:10:44.966 A:middle
如果你正在传递一个

00:10:44.966 --> 00:10:47.416 A:middle
Swift 字符串给 Objecitive-C

00:10:47.416 --> 00:10:49.346 A:middle
而它作为 NSString 桥接而使用

00:10:49.346 --> 00:10:50.206 A:middle
并且是从 Objective-C 端使用它

00:10:50.206 --> 00:10:55.566 A:middle
那么它的操作就可以达到 15 倍之快

00:10:56.516 --> 00:11:01.096 A:middle
[掌声]

00:11:01.596 --> 00:11:04.666 A:middle
所有的这些小的好处加起来确实不少

00:11:04.666 --> 00:11:05.896 A:middle
因为这些类型

00:11:05.896 --> 00:11:08.436 A:middle
在整个 API 生态系统中都在使用

00:11:09.076 --> 00:11:12.326 A:middle
现在说到字符串

00:11:12.326 --> 00:11:13.986 A:middle
我们继续完善了它们的核心表达

00:11:13.986 --> 00:11:15.316 A:middle
我们做了一个重大的改变

00:11:15.316 --> 00:11:18.826 A:middle
在 Swift 5 中的字符串类型上

00:11:19.786 --> 00:11:20.856 A:middle
这是一个隐藏的变化

00:11:20.856 --> 00:11:23.346 A:middle
我们将字符串的 Unicode 表达

00:11:23.346 --> 00:11:29.326 A:middle
从 UTF-16 更改为 UTF-8

00:11:30.206 --> 00:11:33.416 A:middle
那么这完全是由性能驱动的

00:11:34.296 --> 00:11:36.226 A:middle
这个变化有很多丰富的细节

00:11:36.226 --> 00:11:38.506 A:middle
如果你有兴趣了解更多的相关内容

00:11:38.506 --> 00:11:40.406 A:middle
你可以去 swift.org

00:11:40.406 --> 00:11:41.566 A:middle
那里有一篇博文

00:11:41.566 --> 00:11:43.666 A:middle
讲解了实际的技术变化及其推动力量

00:11:44.196 --> 00:11:45.766 A:middle
那么在这里我要强调一些重要的事情

00:11:46.816 --> 00:11:49.556 A:middle
首先 我们将 Swift 创建为

00:11:49.556 --> 00:11:52.996 A:middle
一种你可以达到像 C 语言性能的语言

00:11:54.256 --> 00:11:55.536 A:middle
但其中的一个关键方面是

00:11:55.536 --> 00:11:56.846 A:middle
我们想要 Swift 对现有的

00:11:56.846 --> 00:12:00.266 A:middle
C API 生态系统有很强的互操作性

00:12:00.266 --> 00:12:05.016 A:middle
当 Swift 字符串使用 UTF-16 时

00:12:05.016 --> 00:12:08.866 A:middle
当你把一个字符串传递给 C API 的时候

00:12:09.186 --> 00:12:10.936 A:middle
你也许不知道

00:12:10.936 --> 00:12:12.796 A:middle
你需要进行的操作是

00:12:12.796 --> 00:12:14.556 A:middle
分配 副本和转码

00:12:14.556 --> 00:12:15.776 A:middle
只是为了把字符串放进

00:12:15.776 --> 00:12:17.746 A:middle
一个可以传递到 C 的兼容格式中

00:12:17.746 --> 00:12:19.366 A:middle
那么这就是很大的开销了

00:12:20.176 --> 00:12:22.346 A:middle
现在通过移动到 UTF-8

00:12:22.346 --> 00:12:23.436 A:middle
我们可以直接将一个

00:12:23.436 --> 00:12:25.396 A:middle
以 null 结尾的 UTF-8 字符串

00:12:25.396 --> 00:12:26.036 A:middle
传递给 C API

00:12:26.396 --> 00:12:29.276 A:middle
不需要分配和副本 且零开销

00:12:30.886 --> 00:12:32.666 A:middle
同时我们还能够

00:12:32.666 --> 00:12:34.816 A:middle
扩大字符串类型本身的优化

00:12:35.576 --> 00:12:37.396 A:middle
字符串有一个小的字符串优化

00:12:37.396 --> 00:12:39.376 A:middle
即如果该字符串中的字符数

00:12:39.376 --> 00:12:41.796 A:middle
大约是 15 个字符或者更少的话

00:12:41.796 --> 00:12:44.746 A:middle
我们就不需要一个单独的分配来获得

00:12:44.746 --> 00:12:45.816 A:middle
这些字符的有效荷载

00:12:45.816 --> 00:12:48.546 A:middle
我们可以直接将它打包到字符串值中

00:12:48.706 --> 00:12:49.726 A:middle
这真的是一个进步

00:12:49.836 --> 00:12:53.026 A:middle
在 Swift 5 中我们能够将这个优化扩展到

00:12:53.026 --> 00:12:55.716 A:middle
包括基本上所有的 Unicode 字符

00:12:55.716 --> 00:12:57.806 A:middle
不仅限于 ASCII 这就意味着

00:12:57.806 --> 00:13:00.946 A:middle
它现在可以应用到非罗马字符的语言中

00:13:01.506 --> 00:13:03.596 A:middle
我们在这样做的同时

00:13:03.596 --> 00:13:06.236 A:middle
也在性能层面上保持

00:13:06.456 --> 00:13:08.036 A:middle
NSStrings 和 String 之间

00:13:08.036 --> 00:13:08.876 A:middle
强大的互操作性

00:13:10.216 --> 00:13:11.456 A:middle
但是真正令人兴奋的是

00:13:11.456 --> 00:13:13.906 A:middle
这完全是关乎性能的

00:13:13.906 --> 00:13:14.966 A:middle
我已经说过好几次了

00:13:16.056 --> 00:13:17.486 A:middle
有一个很好的例子

00:13:17.556 --> 00:13:18.916 A:middle
就是 SwiftNIO

00:13:18.916 --> 00:13:20.266 A:middle
对于不熟悉它的人来说

00:13:20.266 --> 00:13:21.756 A:middle
SwiftNIO 是来自于

00:13:21.756 --> 00:13:23.086 A:middle
用于服务器的 Swift

00:13:23.566 --> 00:13:27.976 A:middle
它是一个用于构建网络协议和服务的跨平台框架

00:13:28.246 --> 00:13:30.486 A:middle
它为了速度而进行了调整

00:13:31.676 --> 00:13:35.156 A:middle
通过切换到 UTF-8

00:13:35.226 --> 00:13:37.776 A:middle
我们可以看到构建在 SwiftNIO 上的

00:13:37.776 --> 00:13:40.266 A:middle
网络服务器的吞吐量增加了 20%

00:13:40.266 --> 00:13:44.136 A:middle
那么这就只是文本处理的一个基准

00:13:44.736 --> 00:13:46.726 A:middle
而这恰恰与我们的想法类似

00:13:46.726 --> 00:13:47.926 A:middle
我们想让字符串成为一种

00:13:47.926 --> 00:13:51.406 A:middle
你可以用它来进行

00:13:51.566 --> 00:13:54.216 A:middle
高性能密集的字符串操作

00:13:54.216 --> 00:13:56.326 A:middle
但同时它对用户友好

00:13:56.386 --> 00:13:59.906 A:middle
且易于使用的类型

00:14:01.696 --> 00:14:03.266 A:middle
她会向大家主要介绍

00:14:03.266 --> 00:14:04.636 A:middle
Swift 5 和 Swift 5.1 

00:14:04.636 --> 00:14:06.536 A:middle
中的语言变化

00:14:06.536 --> 00:14:07.636 A:middle
在此之前 我想再谈一些

00:14:07.636 --> 00:14:09.556 A:middle
核心工具和改进

00:14:09.556 --> 00:14:12.846 A:middle
及其中的开源项目的关键方面

00:14:14.416 --> 00:14:16.766 A:middle
现在 Swift 作为一个开源项目

00:14:16.766 --> 00:14:18.936 A:middle
已经不仅仅是一个项目上的

00:14:18.936 --> 00:14:20.556 A:middle
日常的工程工作了

00:14:20.886 --> 00:14:22.216 A:middle
而是关于 Swift 成为一个

00:14:22.216 --> 00:14:23.926 A:middle
更广泛且更多样化的

00:14:23.986 --> 00:14:25.886 A:middle
软件生态系统的一部分

00:14:26.536 --> 00:14:28.816 A:middle
那么举个例子

00:14:28.816 --> 00:14:30.566 A:middle
Swift 社群聚集在一起

00:14:30.566 --> 00:14:32.746 A:middle
为 Swift 创建了官方的 Docker 镜像

00:14:32.926 --> 00:14:35.786 A:middle
它们都被托管在 Docker Hub 中

00:14:36.446 --> 00:14:37.546 A:middle
而如果你在 Mac 上

00:14:37.546 --> 00:14:38.636 A:middle
安装 Docker 其实就是

00:14:38.636 --> 00:14:40.606 A:middle
敲几下键盘的事情

00:14:40.606 --> 00:14:42.016 A:middle
你就可以拥有一个 Docker

00:14:42.016 --> 00:14:43.406 A:middle
就是这个 Docker 镜像

00:14:43.406 --> 00:14:45.066 A:middle
同时拥有在你的 Mac 上

00:14:45.466 --> 00:14:46.896 A:middle
工作的 Docker Linux 容器

00:14:46.896 --> 00:14:48.866 A:middle
包括一个编译器和包管理器

00:14:48.866 --> 00:14:50.866 A:middle
这就是你需要的一切

00:14:51.366 --> 00:14:52.566 A:middle
之所以能这样做

00:14:52.626 --> 00:14:53.986 A:middle
是因为容器如今被视为

00:14:53.986 --> 00:14:56.306 A:middle
构建服务的一个

00:14:56.406 --> 00:14:58.396 A:middle
固有的部分

00:14:59.736 --> 00:15:01.816 A:middle
另一个重要的开源技术

00:15:01.816 --> 00:15:03.516 A:middle
就是 SourceKit

00:15:03.936 --> 00:15:05.536 A:middle
它是语义代码引擎

00:15:05.656 --> 00:15:07.286 A:middle
支持着很多 Xcode 的特性

00:15:07.426 --> 00:15:08.426 A:middle
如自动补全

00:15:08.426 --> 00:15:11.376 A:middle
跳转到定义 以及重构等等

00:15:12.116 --> 00:15:14.406 A:middle
这是我们继续完善的地方

00:15:14.406 --> 00:15:15.546 A:middle
我们想要使得

00:15:15.546 --> 00:15:17.826 A:middle
代码补全之类的结果更好

00:15:19.186 --> 00:15:21.406 A:middle
所以我们需要不断地迭代

00:15:22.266 --> 00:15:23.886 A:middle
但同时我们想要让它

00:15:23.886 --> 00:15:25.466 A:middle
更可靠也更鲁棒

00:15:27.296 --> 00:15:28.556 A:middle
我们所做的努力之一

00:15:28.556 --> 00:15:29.546 A:middle
作为今年开源项目的一部分

00:15:29.546 --> 00:15:31.006 A:middle
是为 SourceKit 构建一个

00:15:31.006 --> 00:15:32.526 A:middle
新的压力测试工具

00:15:33.676 --> 00:15:37.696 A:middle
它所做的就是用 IDE 可以发出的所有查询

00:15:37.696 --> 00:15:40.086 A:middle
连续击打 SourceKit

00:15:40.136 --> 00:15:42.296 A:middle
以快速找出 SourceKit 的问题

00:15:42.856 --> 00:15:43.816 A:middle
那么比如崩溃和断言

00:15:43.816 --> 00:15:44.756 A:middle
它为我们创造了

00:15:44.796 --> 00:15:46.476 A:middle
可重现的测试用例

00:15:46.896 --> 00:15:49.106 A:middle
这里还有一些变化的东西

00:15:50.466 --> 00:15:52.086 A:middle
我们相信用 Swift

00:15:52.086 --> 00:15:55.096 A:middle
为你们所有人创建

00:15:55.096 --> 00:15:56.996 A:middle
一流的工具

00:15:56.996 --> 00:15:58.396 A:middle
并将其投入我们自己的

00:15:58.396 --> 00:15:59.386 A:middle
工作流程的一部分

00:15:59.386 --> 00:16:01.146 A:middle
这就像是我们在享用

00:16:01.786 --> 00:16:04.386 A:middle
自己的理念 而像这样的努力

00:16:04.486 --> 00:16:06.686 A:middle
就是现在我们日常的

00:16:06.686 --> 00:16:08.766 A:middle
项目工程的一个核心部分

00:16:10.906 --> 00:16:12.986 A:middle
那么我想要谈一谈

00:16:12.986 --> 00:16:14.626 A:middle
一个面向未来的

00:16:14.626 --> 00:16:16.046 A:middle
对 SourceKit 的投入

00:16:16.046 --> 00:16:17.676 A:middle
那就是采用语言服务器协议

00:16:18.386 --> 00:16:20.896 A:middle
举这个之前出现过的例子

00:16:21.576 --> 00:16:23.546 A:middle
你可以用 Xcode

00:16:23.546 --> 00:16:24.896 A:middle
或者把这个图片概括成为

00:16:24.896 --> 00:16:27.636 A:middle
任何一种编辑器或工具

00:16:27.636 --> 00:16:29.086 A:middle
我的意思是 SourceKit 是开源的

00:16:29.406 --> 00:16:30.776 A:middle
它被设计为用于

00:16:30.776 --> 00:16:33.116 A:middle
构建工具的可重用组件

00:16:34.196 --> 00:16:37.386 A:middle
因此这样可以工作 对

00:16:37.386 --> 00:16:40.016 A:middle
但这真的是一种很老的模型

00:16:40.236 --> 00:16:41.646 A:middle
你可以假设那里有

00:16:41.646 --> 00:16:43.996 A:middle
各种各样的工具和编辑器

00:16:43.996 --> 00:16:45.806 A:middle
以及 IDE 它们想要

00:16:45.806 --> 00:16:48.816 A:middle
连接到各种不同的语言服务

00:16:49.246 --> 00:16:50.316 A:middle
因此 虽然它们能够直接

00:16:50.316 --> 00:16:51.526 A:middle
连接逻辑来与 SourceKit 进行对话

00:16:51.526 --> 00:16:53.836 A:middle
但这就都是相当临时的

00:16:53.836 --> 00:16:54.926 A:middle
你必须让每一个编辑器

00:16:54.926 --> 00:16:57.096 A:middle
连接到它自己的支持

00:16:57.096 --> 00:16:58.136 A:middle
同时它们必须理解 SourceKit

00:16:58.136 --> 00:16:58.926 A:middle
而且它们也必须了解

00:16:58.926 --> 00:17:00.526 A:middle
所有它们想要连接的其他服务

00:17:00.526 --> 00:17:02.776 A:middle
所以这不是一个可扩展的模型

00:17:03.296 --> 00:17:04.576 A:middle
但是像大多数

00:17:04.576 --> 00:17:05.626 A:middle
计算机科学中的问题一样

00:17:05.626 --> 00:17:06.486 A:middle
你都可以用一个间接层来解决

00:17:06.486 --> 00:17:08.546 A:middle
除了性能问题

00:17:08.546 --> 00:17:11.776 A:middle
已经出现了一种

00:17:11.776 --> 00:17:12.886 A:middle
行业标准解决方案

00:17:12.886 --> 00:17:15.596 A:middle
称为语言服务协议或 LSP

00:17:15.596 --> 00:17:18.056 A:middle
这个想法是

00:17:18.056 --> 00:17:20.205 A:middle
如果编辑器使用 LSP

00:17:20.205 --> 00:17:22.056 A:middle
这是一组标准的查询

00:17:22.056 --> 00:17:23.846 A:middle
而服务可以将其返回

00:17:23.846 --> 00:17:25.286 A:middle
你就可以直接将它们

00:17:25.286 --> 00:17:26.056 A:middle
混聚在一起

00:17:27.576 --> 00:17:28.976 A:middle
这是一个正在进行的积极的努力

00:17:28.976 --> 00:17:31.136 A:middle
也是一个开放源代码

00:17:31.376 --> 00:17:32.236 A:middle
你可以关注一下

00:17:32.846 --> 00:17:34.446 A:middle
但是要让你们了解一下

00:17:34.446 --> 00:17:36.806 A:middle
它的功能

00:17:36.806 --> 00:17:39.146 A:middle
这个动画显示的是

00:17:39.146 --> 00:17:41.596 A:middle
使用 SourceKit LSP 的代码补全支持

00:17:41.596 --> 00:17:44.296 A:middle
还有对其他各种

00:17:44.296 --> 00:17:45.536 A:middle
编辑器的支持

00:17:45.536 --> 00:17:48.006 A:middle
你可以在 GitHub 的页面上找到说明

00:17:49.516 --> 00:17:54.616 A:middle
[掌声]

00:17:55.116 --> 00:17:56.476 A:middle
正是像这样的投入

00:17:56.476 --> 00:17:57.906 A:middle
让我们感到非常的兴奋

00:17:57.906 --> 00:17:59.416 A:middle
因为 Swift 真的是

00:17:59.416 --> 00:18:00.976 A:middle
我们为通用计算

00:18:00.976 --> 00:18:03.326 A:middle
而构建的语言 对吗

00:18:03.326 --> 00:18:05.166 A:middle
它有巨大的潜力

00:18:05.216 --> 00:18:07.616 A:middle
这实际上是为了

00:18:07.616 --> 00:18:10.036 A:middle
让 Swift 真正蓬勃发展

00:18:10.036 --> 00:18:11.636 A:middle
在一个多样化的软件生态系统中

00:18:12.126 --> 00:18:13.766 A:middle
到这里 我要把舞台

00:18:13.766 --> 00:18:15.146 A:middle
交给我的同事 Anna Zaks

00:18:15.146 --> 00:18:16.496 A:middle
她会向大家分享

00:18:16.496 --> 00:18:18.516 A:middle
Swift 中的语言变化

00:18:19.516 --> 00:18:24.056 A:middle
[掌声]

00:18:24.556 --> 00:18:25.146 A:middle
&gt;&gt; 谢谢你 Ted

00:18:25.756 --> 00:18:26.526 A:middle
Ted 和大家分享了

00:18:26.526 --> 00:18:28.586 A:middle
项目和编译器方面的改进

00:18:28.956 --> 00:18:30.366 A:middle
现在让我来为大家介绍

00:18:30.526 --> 00:18:32.136 A:middle
我们在 Swift 语言

00:18:32.136 --> 00:18:33.516 A:middle
以及 Swift 5 和 Swift 5.1 中的

00:18:33.516 --> 00:18:36.006 A:middle
标准库上所作的改进

00:18:37.126 --> 00:18:38.836 A:middle
这些特性中有许多都在

00:18:38.836 --> 00:18:41.576 A:middle
继续完善语言和库的核心部分

00:18:42.256 --> 00:18:43.956 A:middle
同时为了与 Apple 今年推出的 

00:18:43.956 --> 00:18:45.556 A:middle
几个主要的 Swift 框架

00:18:45.556 --> 00:18:47.086 A:middle
匹配一致

00:18:47.086 --> 00:18:48.626 A:middle
我们已经添加了能支持创建

00:18:48.626 --> 00:18:50.386 A:middle
更好的 Swift API 的特性

00:18:51.356 --> 00:18:52.876 A:middle
你们很多人都知道

00:18:52.876 --> 00:18:54.556 A:middle
Swift 语言经历了

00:18:54.556 --> 00:18:55.516 A:middle
开放的发展过程

00:18:56.006 --> 00:18:57.676 A:middle
你们在幻灯片上看到的

00:18:57.676 --> 00:18:59.716 A:middle
这些 SE 编号

00:18:59.716 --> 00:19:01.006 A:middle
与可以 Swift 发展网站上

00:19:01.006 --> 00:19:02.916 A:middle
找到的特性文档相对应

00:19:03.926 --> 00:19:05.146 A:middle
这是一个很棒的资源

00:19:05.146 --> 00:19:06.786 A:middle
如果你想要进一步了解这些特性

00:19:07.306 --> 00:19:08.486 A:middle
现在 让我来带你们

00:19:08.486 --> 00:19:11.096 A:middle
看看其中的一些特性

00:19:11.256 --> 00:19:12.726 A:middle
首先我要讲几个例子

00:19:12.726 --> 00:19:14.726 A:middle
是关于遗漏缺陷的弥补

00:19:15.296 --> 00:19:18.046 A:middle
许多人都喜欢

00:19:18.046 --> 00:19:20.026 A:middle
单表达式闭包语法的简单性

00:19:20.606 --> 00:19:22.036 A:middle
因此他们需要用单表达式

00:19:22.216 --> 00:19:24.226 A:middle
来编写一个返回

00:19:24.226 --> 00:19:27.066 A:middle
而函数 方法和下标

00:19:27.156 --> 00:19:28.896 A:middle
则像是不必要的负担

00:19:29.216 --> 00:19:31.456 A:middle
那么现在你可以在任何地方

00:19:31.456 --> 00:19:32.676 A:middle
使用简单的语法了

00:19:33.516 --> 00:19:38.476 A:middle
[掌声]

00:19:38.976 --> 00:19:40.466 A:middle
另一个缺陷是被

00:19:40.466 --> 00:19:41.876 A:middle
一个开源贡献者修复的

00:19:42.156 --> 00:19:43.416 A:middle
他就是 Alejandro Alonso 

00:19:43.766 --> 00:19:45.716 A:middle
令人惊讶的是

00:19:45.716 --> 00:19:46.856 A:middle
他刚刚高中毕业

00:19:47.766 --> 00:19:49.146 A:middle
我们看看这个结构体

00:19:49.146 --> 00:19:50.806 A:middle
它便利地为它的

00:19:50.806 --> 00:19:52.436 A:middle
两个属性定义默认值

00:19:53.396 --> 00:19:54.896 A:middle
以前 你可以调用一个初始化

00:19:54.896 --> 00:19:57.146 A:middle
然后不传递参数

00:19:57.806 --> 00:19:58.776 A:middle
你也可以调用一个初始化

00:19:58.776 --> 00:20:00.216 A:middle
然后传递所有参数

00:20:00.216 --> 00:20:02.326 A:middle
但是你不可以

00:20:02.356 --> 00:20:04.196 A:middle
调用一个初始化

00:20:04.196 --> 00:20:05.406 A:middle
然后只传递一些参数

00:20:06.266 --> 00:20:08.626 A:middle
在 Swift 5 中 这个问题被修复了

00:20:09.506 --> 00:20:11.106 A:middle
一切都如你所愿地进行

00:20:11.606 --> 00:20:15.736 A:middle
[掌声]

00:20:16.236 --> 00:20:18.286 A:middle
编译器会为

00:20:18.506 --> 00:20:20.156 A:middle
所有这些情况生成初始化

00:20:21.116 --> 00:20:23.176 A:middle
另一个重要的领域是

00:20:23.176 --> 00:20:24.206 A:middle
高性能计算

00:20:25.106 --> 00:20:26.896 A:middle
在 Swift 5 中 标准库

00:20:26.896 --> 00:20:29.006 A:middle
增加了对 SIMD 

00:20:29.006 --> 00:20:30.396 A:middle
即单指令多数据流

00:20:30.496 --> 00:20:31.576 A:middle
指令和类型的支持

00:20:32.496 --> 00:20:33.986 A:middle
这些通常用于

00:20:33.986 --> 00:20:36.056 A:middle
为图形编写底层性能敏感的代码

00:20:36.056 --> 00:20:39.766 A:middle
比如图像处理或 AR

00:20:40.276 --> 00:20:41.706 A:middle
事实上 我们今年发布的

00:20:41.706 --> 00:20:43.036 A:middle
新的 RealityKit 库

00:20:43.276 --> 00:20:44.496 A:middle
就正在使用这些类型

00:20:45.226 --> 00:20:47.716 A:middle
新的 SIMD 类型表示

00:20:47.916 --> 00:20:49.486 A:middle
固定大小的 SIMD 矢量

00:20:50.136 --> 00:20:51.786 A:middle
正如你所期望的

00:20:51.786 --> 00:20:53.566 A:middle
你可以在这里使用

00:20:53.606 --> 00:20:55.966 A:middle
标准库整型和浮点类型作为元素

00:20:56.916 --> 00:20:58.396 A:middle
让我来带你们了解一下

00:20:58.396 --> 00:21:01.916 A:middle
你可以用这些类型来做什么

00:21:02.096 --> 00:21:03.876 A:middle
你可以从数组字面量

00:21:03.876 --> 00:21:04.786 A:middle
初始化 SIMD 矢量

00:21:05.626 --> 00:21:07.676 A:middle
这里我们有大小为 4 的数组

00:21:08.156 --> 00:21:09.696 A:middle
实际上是两个大小为 4 的数组

00:21:09.696 --> 00:21:11.816 A:middle
而新的点运算符

00:21:11.816 --> 00:21:14.046 A:middle
允许你在这些矢量上

00:21:14.096 --> 00:21:16.096 A:middle
执行逐点运算

00:21:16.706 --> 00:21:18.676 A:middle
比如等式和比较

00:21:19.296 --> 00:21:20.906 A:middle
这里举个例子

00:21:20.906 --> 00:21:23.636 A:middle
我们正在检查 x 是否在每个点上

00:21:23.936 --> 00:21:24.616 A:middle
都比 y 点大

00:21:25.406 --> 00:21:27.136 A:middle
结果告诉我们

00:21:27.136 --> 00:21:30.076 A:middle
x 只在最后两点比 y 大

00:21:30.676 --> 00:21:33.076 A:middle
该结果被储存在

00:21:33.076 --> 00:21:36.136 A:middle
另一种叫 SIMDMask 的类型中

00:21:36.136 --> 00:21:37.906 A:middle
而 SIMDMask 类型上的点运算符

00:21:37.906 --> 00:21:40.096 A:middle
让你可以进一步操作

00:21:40.496 --> 00:21:42.036 A:middle
这些生成的掩码

00:21:42.246 --> 00:21:43.226 A:middle
举个例子在这里

00:21:43.226 --> 00:21:45.466 A:middle
我们在对之前的计算结果取反

00:21:48.376 --> 00:21:50.456 A:middle
Swift 5 还为你提供了

00:21:50.456 --> 00:21:53.576 A:middle
更多的文本操作表达能力

00:21:53.806 --> 00:21:55.246 A:middle
字符串内插已经

00:21:55.246 --> 00:21:56.946 A:middle
在 Swift 5 中被重新设计

00:21:57.506 --> 00:22:00.346 A:middle
新设计的速度和距离

00:22:00.346 --> 00:22:03.376 A:middle
达到之前的 1.7 倍

00:22:03.376 --> 00:22:05.256 A:middle
你可以自定义

00:22:05.256 --> 00:22:07.116 A:middle
所构建的内插

00:22:07.116 --> 00:22:08.676 A:middle
通过提供自己的助手

00:22:08.676 --> 00:22:10.956 A:middle
你可以用内插字符串

00:22:10.956 --> 00:22:12.946 A:middle
将你的类型初始化

00:22:12.946 --> 00:22:14.786 A:middle
来赋予字符串内插自定义的意义

00:22:15.886 --> 00:22:17.576 A:middle
Swift 从一开始

00:22:17.576 --> 00:22:19.116 A:middle
就可以支持字符串内插

00:22:19.466 --> 00:22:20.666 A:middle
如果你写一个反斜杠符号

00:22:21.016 --> 00:22:22.266 A:middle
后面跟着一些括号内引用

00:22:22.266 --> 00:22:23.566 A:middle
在一个字符串字面量中

00:22:23.566 --> 00:22:25.166 A:middle
编译器就会

00:22:25.166 --> 00:22:26.636 A:middle
执行该代码

00:22:26.636 --> 00:22:28.916 A:middle
并将值插入字符串

00:22:28.916 --> 00:22:31.246 A:middle
这一直是行得通的

00:22:31.246 --> 00:22:32.546 A:middle
但也会有一些限制

00:22:33.556 --> 00:22:35.736 A:middle
举个例子 用一个封闭在

00:22:35.736 --> 00:22:37.816 A:middle
NSLocalizedString 中的内插字符串

00:22:37.816 --> 00:22:40.056 A:middle
这样是行不通的

00:22:41.236 --> 00:22:44.276 A:middle
内插绘发生在转换之前

00:22:44.946 --> 00:22:46.986 A:middle
比如说在这里

00:22:46.986 --> 00:22:48.996 A:middle
字符串文件不包含

00:22:48.996 --> 00:22:51.246 A:middle
对字符串中

00:22:51.296 --> 00:22:53.306 A:middle
插入的整型的转换

00:22:53.726 --> 00:22:57.636 A:middle
因此 You have 10 apples

00:22:57.636 --> 00:22:58.466 A:middle
将无法被转换

00:22:59.576 --> 00:23:01.016 A:middle
相反 你首先需要做的是

00:23:01.016 --> 00:23:03.416 A:middle
创建 formatString

00:23:05.146 --> 00:23:07.166 A:middle
接着 将它本地化

00:23:08.176 --> 00:23:10.046 A:middle
然后 将值插入

00:23:10.046 --> 00:23:11.716 A:middle
已经本地化的字符串中

00:23:12.836 --> 00:23:14.376 A:middle
这就是用 UIKit 和 AppKit

00:23:14.376 --> 00:23:17.406 A:middle
来完成字符串本地化的正确方法

00:23:18.456 --> 00:23:20.476 A:middle
但是新的字符串内插设计

00:23:20.476 --> 00:23:22.236 A:middle
让我们更进一步

00:23:22.236 --> 00:23:24.526 A:middle
来设计出更有表现力的 API

00:23:24.526 --> 00:23:28.036 A:middle
比如 SwiftUI 框架中的文本

00:23:28.706 --> 00:23:30.666 A:middle
文本用于表示 SwiftUI 中的标签

00:23:30.666 --> 00:23:33.506 A:middle
我们想要将其本地化

00:23:34.616 --> 00:23:35.606 A:middle
我们来看看要怎么做

00:23:36.336 --> 00:23:39.096 A:middle
这里我们传递一个

00:23:39.096 --> 00:23:40.256 A:middle
内插字符串

00:23:40.256 --> 00:23:41.526 A:middle
给文本的初始化

00:23:42.506 --> 00:23:44.126 A:middle
而这里的技巧是

00:23:44.126 --> 00:23:46.656 A:middle
文本初始化不接受

00:23:46.656 --> 00:23:48.046 A:middle
字符串类型作为输入

00:23:48.616 --> 00:23:50.026 A:middle
而是接受另一种类型

00:23:50.146 --> 00:23:52.456 A:middle
它叫做 LocalizedStringKey

00:23:52.456 --> 00:23:54.616 A:middle
该类型被定义在 SwiftUI 框架内

00:23:54.726 --> 00:23:56.916 A:middle
因此 Swift 编译器

00:23:56.946 --> 00:23:58.316 A:middle
就将自定义的规则

00:23:58.316 --> 00:24:00.186 A:middle
应用到了字符串中

00:24:00.186 --> 00:24:02.026 A:middle
通过字符串内插协议

00:24:02.236 --> 00:24:03.876 A:middle
来处理该内插

00:24:04.896 --> 00:24:06.496 A:middle
一旦它知道使用哪个规则

00:24:06.496 --> 00:24:08.656 A:middle
编译器就会转换

00:24:08.656 --> 00:24:10.606 A:middle
这个字符串内插

00:24:10.606 --> 00:24:12.156 A:middle
用该自动生成的代码

00:24:13.306 --> 00:24:15.276 A:middle
我们用三步来理解它的作用

00:24:16.166 --> 00:24:18.546 A:middle
第一步 Swift 创建

00:24:18.596 --> 00:24:21.296 A:middle
一个实例给构建器

00:24:21.296 --> 00:24:23.076 A:middle
针对 LocalizedStringKey

00:24:23.566 --> 00:24:25.396 A:middle
这个实例会包含两个东西

00:24:25.396 --> 00:24:27.876 A:middle
分别是 formatKey

00:24:27.876 --> 00:24:29.276 A:middle
和一个变量数组

00:24:30.756 --> 00:24:33.216 A:middle
第二步 我们通过处理

00:24:33.716 --> 00:24:36.336 A:middle
内插的段来构建字符串

00:24:37.076 --> 00:24:38.666 A:middle
首先 我们有一个字符串字面量

00:24:38.786 --> 00:24:40.036 A:middle
我们将它添加给 formatKey

00:24:41.296 --> 00:24:43.506 A:middle
其次 在处理 quantity 时

00:24:43.646 --> 00:24:45.856 A:middle
分别恢复 formatKey 中的

00:24:45.856 --> 00:24:48.256 A:middle
格式说明符

00:24:48.256 --> 00:24:50.186 A:middle
和变量数组中的值

00:24:51.666 --> 00:24:54.046 A:middle
最后给 formatKey 添加另一段字面值

00:24:55.346 --> 00:24:58.946 A:middle
第三步 调用 LocalizedStringKey 的初始化器

00:24:58.946 --> 00:25:00.806 A:middle
这个时候你有了足够的信息

00:25:00.806 --> 00:25:03.306 A:middle
来将字符串合理地本地化

00:25:05.356 --> 00:25:06.856 A:middle
这样 SwiftUI 就可以使用

00:25:06.856 --> 00:25:08.326 A:middle
该语言特性将文本本地化

00:25:08.386 --> 00:25:12.646 A:middle
然后用户就可以读取信息 很酷吧

00:25:13.516 --> 00:25:19.036 A:middle
[掌声]

00:25:19.536 --> 00:25:21.266 A:middle
这个例子只是

00:25:21.266 --> 00:25:22.796 A:middle
粗浅地介绍了一点

00:25:22.796 --> 00:25:23.886 A:middle
字符串内插的使用

00:25:24.296 --> 00:25:26.196 A:middle
如果你像我们一样

00:25:26.196 --> 00:25:27.886 A:middle
对这个新特性感兴趣的话

00:25:27.916 --> 00:25:30.646 A:middle
那么你可以去阅读

00:25:30.646 --> 00:25:33.056 A:middle
ExpressibleByStringInterpolation 协议的文档

00:25:35.166 --> 00:25:36.926 A:middle
现在 我们来谈谈焦点

00:25:37.506 --> 00:25:39.896 A:middle
API 设计的一部分就是要

00:25:39.896 --> 00:25:42.806 A:middle
决定从你的 API 中排除什么

00:25:42.876 --> 00:25:44.766 A:middle
在 Swift 5.1 中 我们已经

00:25:44.866 --> 00:25:47.466 A:middle
专门针对返回的类型做了改进

00:25:47.986 --> 00:25:50.146 A:middle
虽然很重要的一点是

00:25:50.146 --> 00:25:51.636 A:middle
返回的类型表示

00:25:51.636 --> 00:25:53.166 A:middle
类型的性能

00:25:53.166 --> 00:25:54.956 A:middle
你的 API 的用户可以从中推断

00:25:54.956 --> 00:25:57.416 A:middle
但有时我们想要

00:25:57.416 --> 00:25:59.246 A:middle
将返回的内容抽象化

00:26:01.906 --> 00:26:05.066 A:middle
在运行时返回多次 

00:26:05.066 --> 00:26:06.736 A:middle
或者它总是返回相同的类型

00:26:07.366 --> 00:26:08.716 A:middle
但是该类型也许会透露

00:26:08.716 --> 00:26:11.426 A:middle
你的 API 的实现细节

00:26:12.456 --> 00:26:14.446 A:middle
且显示一些你的 API 的用户

00:26:14.446 --> 00:26:16.186 A:middle
不应该推出的东西

00:26:17.026 --> 00:26:18.456 A:middle
让我们来看看 Swift

00:26:18.666 --> 00:26:20.766 A:middle
提供给这些例子的选项

00:26:22.226 --> 00:26:23.846 A:middle
我们在例子中

00:26:24.176 --> 00:26:25.106 A:middle
使用简单的形状 API

00:26:25.626 --> 00:26:27.116 A:middle
那么正如你所期待的

00:26:27.116 --> 00:26:29.626 A:middle
我们这里有一个 Shape 协议

00:26:29.626 --> 00:26:31.696 A:middle
我们有定义如圆形 椭圆形

00:26:31.696 --> 00:26:34.616 A:middle
和正方形等基本图形的类型

00:26:35.736 --> 00:26:37.226 A:middle
同时我们还有这样的结构

00:26:37.226 --> 00:26:40.136 A:middle
可以操作图形来创建

00:26:40.136 --> 00:26:42.256 A:middle
图形的并集然后转换它们

00:26:42.916 --> 00:26:45.076 A:middle
看看这个 FaceShape 的例子

00:26:45.796 --> 00:26:47.906 A:middle
注意 这个 API 会根据你的图形的类型

00:26:47.946 --> 00:26:50.206 A:middle
也就是 faceType

00:26:50.296 --> 00:26:53.016 A:middle
来返回不同的类型

00:26:53.216 --> 00:26:55.686 A:middle
但它们都是符合 Shape 协议的

00:26:55.996 --> 00:26:57.806 A:middle
因此它是一个很好的例子

00:26:57.876 --> 00:26:59.466 A:middle
将协议类型用作我们的返回类型

00:27:02.916 --> 00:27:05.126 A:middle
我们来构建一个八角星

00:27:05.216 --> 00:27:07.696 A:middle
通过创建一个正方形

00:27:07.696 --> 00:27:10.596 A:middle
和转换后的正方形的并集 对吗

00:27:11.866 --> 00:27:13.476 A:middle
在这里声明具体的返回类型

00:27:13.476 --> 00:27:15.376 A:middle
就会将大部分实现细节

00:27:15.376 --> 00:27:16.696 A:middle
透露给客户

00:27:16.696 --> 00:27:19.726 A:middle
同时显示出这个

00:27:19.726 --> 00:27:21.546 A:middle
不必要的细节

00:27:21.546 --> 00:27:24.106 A:middle
会让 API 很难推出

00:27:25.626 --> 00:27:27.406 A:middle
但是 在这里使用一个

00:27:27.406 --> 00:27:29.216 A:middle
协议类型 Shape 也不太好

00:27:29.606 --> 00:27:30.236 A:middle
让我们看看这是为什么

00:27:31.706 --> 00:27:33.226 A:middle
当协议类型被返回时

00:27:33.226 --> 00:27:34.856 A:middle
这里并不能保证

00:27:34.856 --> 00:27:36.516 A:middle
从每个调用中

00:27:36.516 --> 00:27:38.046 A:middle
返回相同的类型给 API

00:27:38.046 --> 00:27:40.606 A:middle
除 Swift 的泛型外

00:27:40.606 --> 00:27:42.486 A:middle
它也给我们带来了

00:27:42.486 --> 00:27:44.086 A:middle
这些基础的限制

00:27:44.806 --> 00:27:46.906 A:middle
如果八角星有两个值

00:27:46.906 --> 00:27:49.046 A:middle
从相同的 API 

00:27:49.046 --> 00:27:51.336 A:middle
但不同的两个调用中

00:27:51.336 --> 00:27:53.526 A:middle
返回到这个 API

00:27:53.526 --> 00:27:54.976 A:middle
它们可能就没有相同的类型

00:27:54.976 --> 00:27:56.766 A:middle
这样你就不能进行比较相等

00:27:57.636 --> 00:27:59.296 A:middle
返回的类型不能

00:27:59.296 --> 00:28:01.766 A:middle
有任何的关联类型

00:28:01.766 --> 00:28:03.486 A:middle
也不能有涉及到自身的需求

00:28:04.526 --> 00:28:06.606 A:middle
此外 丢失此类型标识

00:28:06.606 --> 00:28:07.926 A:middle
也可能让

00:28:07.926 --> 00:28:08.976 A:middle
某些编译器无法进行优化

00:28:11.496 --> 00:28:14.216 A:middle
Swift 5.1 引入了另外一个

00:28:14.216 --> 00:28:17.126 A:middle
叫做不透明结果类型的概念

00:28:17.706 --> 00:28:19.476 A:middle
这是一个伟大的进步

00:28:19.476 --> 00:28:21.476 A:middle
适用于已知返回相同具体类型的 API

00:28:21.476 --> 00:28:24.406 A:middle
但是有可能想要将这种类型

00:28:24.406 --> 00:28:26.816 A:middle
对用户隐藏起来

00:28:27.876 --> 00:28:29.126 A:middle
不透明结果类型

00:28:29.126 --> 00:28:31.576 A:middle
在这里写作 some Shape

00:28:31.576 --> 00:28:33.736 A:middle
它代表一个特定的

00:28:33.736 --> 00:28:35.266 A:middle
Shape 类型从这个 API 中返回

00:28:36.936 --> 00:28:38.996 A:middle
这种类型标识的保证

00:28:39.316 --> 00:28:40.536 A:middle
也让我们能够

00:28:40.536 --> 00:28:42.326 A:middle
在 API 的主体里

00:28:42.326 --> 00:28:43.586 A:middle
执行更强的类型检查

00:28:44.516 --> 00:28:46.296 A:middle
因此 如果你有几个返回了

00:28:46.296 --> 00:28:48.046 A:middle
不同类型的返回语句

00:28:48.046 --> 00:28:50.946 A:middle
编译器就会将其缓存

00:28:51.256 --> 00:28:53.246 A:middle
并提醒你修复该问题

00:28:54.606 --> 00:28:55.996 A:middle
不透明结果类型能够

00:28:55.996 --> 00:28:58.476 A:middle
在 Swift 5.1 中使用

00:28:58.476 --> 00:29:00.626 A:middle
你可以从文档中了解更多

00:29:01.806 --> 00:29:03.296 A:middle
注意 这个特性需要

00:29:03.296 --> 00:29:04.336 A:middle
新的 Swift Runtime

00:29:05.086 --> 00:29:07.366 A:middle
因此它只能在更新的 Swift 操作系统里工作

00:29:08.356 --> 00:29:09.796 A:middle
如果你要进行向后部署

00:29:09.796 --> 00:29:11.636 A:middle
你就可以使用这个特性

00:29:11.636 --> 00:29:13.686 A:middle
但你需要进行静态可用性检查

00:29:13.986 --> 00:29:15.656 A:middle
来保证它们的使用

00:29:17.816 --> 00:29:19.766 A:middle
现在我们来说说代码重用

00:29:19.866 --> 00:29:22.306 A:middle
及叫做属性包装器的新功能

00:29:23.636 --> 00:29:26.306 A:middle
访问属性的自定模式很常见

00:29:26.856 --> 00:29:28.816 A:middle
其中的一些模式

00:29:28.816 --> 00:29:30.246 A:middle
具有一流的语言支持

00:29:30.246 --> 00:29:32.426 A:middle
比如懒惰模式

00:29:32.866 --> 00:29:34.206 A:middle
但你也可能正在编写

00:29:34.206 --> 00:29:35.826 A:middle
你自己的自定包装器

00:29:36.716 --> 00:29:39.066 A:middle
也许你有一些

00:29:39.106 --> 00:29:42.396 A:middle
访问访问本地线程存储或写时拷贝

00:29:42.396 --> 00:29:43.686 A:middle
也许你使用计算属性

00:29:43.686 --> 00:29:45.536 A:middle
来储存用户默认值

00:29:46.956 --> 00:29:48.666 A:middle
我们一直编写自定的

00:29:48.666 --> 00:29:50.476 A:middle
get 和 set

00:29:50.476 --> 00:29:52.146 A:middle
但有时这个代码是重复的

00:29:53.106 --> 00:29:54.636 A:middle
例如在这里我有两个

00:29:54.636 --> 00:29:57.506 A:middle
指定用户默认值的属性

00:29:58.436 --> 00:29:59.696 A:middle
但这个代码的大多数

00:29:59.696 --> 00:30:02.206 A:middle
只是在复制粘贴

00:30:02.336 --> 00:30:03.856 A:middle
有了属性包装器

00:30:03.856 --> 00:30:06.756 A:middle
我们可以声明一种

00:30:06.756 --> 00:30:07.896 A:middle
指定访问模式的类型

00:30:09.446 --> 00:30:10.816 A:middle
我们将它命名为 UserDefaults

00:30:12.186 --> 00:30:13.846 A:middle
接着 我们告诉编译器

00:30:13.846 --> 00:30:15.416 A:middle
这个类型是特殊的

00:30:16.256 --> 00:30:18.246 A:middle
它的首要目的就是

00:30:18.246 --> 00:30:21.236 A:middle
包裹一个属性并指定其访问模式

00:30:22.486 --> 00:30:24.646 A:middle
这样做我们得到的就是

00:30:24.646 --> 00:30:26.056 A:middle
这个类型会允许我们

00:30:26.106 --> 00:30:28.796 A:middle
使用一个自定属性来声明

00:30:28.796 --> 00:30:31.126 A:middle
用户默认访问模式的属性

00:30:32.486 --> 00:30:33.556 A:middle
我们来仔细看看

00:30:33.806 --> 00:30:35.326 A:middle
有了这里的属性包装器

00:30:35.326 --> 00:30:38.746 A:middle
我们可以重写

00:30:38.746 --> 00:30:40.116 A:middle
之前那两个用户默认属性 

00:30:40.116 --> 00:30:41.096 A:middle
写成这样

00:30:41.216 --> 00:30:43.626 A:middle
这样就没有重复了

00:30:43.626 --> 00:30:44.886 A:middle
非常干净明了

00:30:45.386 --> 00:30:47.196 A:middle
我需要做的就只是

00:30:47.196 --> 00:30:50.546 A:middle
添加自定属性

00:30:50.546 --> 00:30:52.236 A:middle
同时知道这些属性

00:30:52.236 --> 00:30:53.436 A:middle
仍被声明为布尔类型

00:30:53.716 --> 00:30:55.296 A:middle
因此你可以使用它们

00:30:55.296 --> 00:30:56.826 A:middle
像使用简单的布尔值一样

00:30:58.516 --> 00:31:04.276 A:middle
[掌声]

00:31:04.776 --> 00:31:06.236 A:middle
属性包装器使得我们可以

00:31:06.236 --> 00:31:08.096 A:middle
定义自定访问模式

00:31:08.486 --> 00:31:09.856 A:middle
而属性可以选择使用它们

00:31:09.856 --> 00:31:11.776 A:middle
只需要在其声明中

00:31:11.776 --> 00:31:13.726 A:middle
添加一个自定属性

00:31:16.136 --> 00:31:18.046 A:middle
我们寻求特定的工具

00:31:18.046 --> 00:31:19.396 A:middle
来解决特定的问题

00:31:19.926 --> 00:31:22.486 A:middle
它们在各自的领域都十分有用

00:31:23.526 --> 00:31:25.776 A:middle
同样 DSL 在程序员的生活中

00:31:25.776 --> 00:31:27.256 A:middle
也有着重要的作用

00:31:27.936 --> 00:31:29.536 A:middle
我们用它们来

00:31:30.006 --> 00:31:31.646 A:middle
查询数据库并构建图表

00:31:31.646 --> 00:31:33.256 A:middle
我们喜欢这种声明风格

00:31:33.546 --> 00:31:35.116 A:middle
我们可以简洁明了地

00:31:35.116 --> 00:31:39.126 A:middle
声明我们网页的布局

00:31:40.016 --> 00:31:42.146 A:middle
但是 它们也有不同

00:31:43.176 --> 00:31:44.626 A:middle
当我们每次使用其中一种时

00:31:44.626 --> 00:31:46.806 A:middle
都需要进行上下文切换

00:31:46.806 --> 00:31:48.966 A:middle
每种语言都有自己的语法和语义

00:31:50.166 --> 00:31:51.546 A:middle
它们都有各自独特的

00:31:51.546 --> 00:31:52.746 A:middle
强大的工具来支持它们

00:31:53.456 --> 00:31:55.576 A:middle
如果你缺失了一个 HTML 标记

00:31:55.576 --> 00:31:57.496 A:middle
如果你在一个 HTML 编辑器里 

00:31:57.496 --> 00:31:58.806 A:middle
这是很容易解决的

00:31:59.916 --> 00:32:01.426 A:middle
但是 因为语法和语义

00:32:01.456 --> 00:32:03.436 A:middle
都被调整为特定的目的

00:32:03.506 --> 00:32:05.986 A:middle
支持它们的工具

00:32:05.986 --> 00:32:08.036 A:middle
也常常有特定的领域

00:32:09.196 --> 00:32:10.946 A:middle
因此当我们需要将

00:32:10.946 --> 00:32:12.636 A:middle
这些 DSL 整合进我们的项目时

00:32:13.496 --> 00:32:14.776 A:middle
通常没有什么好办法

00:32:16.066 --> 00:32:17.586 A:middle
在一些情况里 我们会

00:32:17.586 --> 00:32:20.336 A:middle
添加自定构建阶段

00:32:20.336 --> 00:32:21.336 A:middle
但通常我们会用这个解决方案

00:32:22.456 --> 00:32:23.826 A:middle
它看起来十分眼熟

00:32:23.826 --> 00:32:25.296 A:middle
这是一个表示 HTML 的

00:32:25.296 --> 00:32:26.376 A:middle
字符串字面值

00:32:27.666 --> 00:32:29.936 A:middle
我们完成了整合 却失去了工具的支持

00:32:30.566 --> 00:32:32.726 A:middle
编译器代码补全将这个

00:32:32.726 --> 00:32:33.606 A:middle
看作一个字符串

00:32:34.476 --> 00:32:35.866 A:middle
这里没有类型检查

00:32:36.186 --> 00:32:38.176 A:middle
对 Swift 编译器来说只是一堆文本

00:32:39.046 --> 00:32:40.526 A:middle
因此像忘记结束标记

00:32:40.526 --> 00:32:42.836 A:middle
这样的低级错误

00:32:42.836 --> 00:32:44.286 A:middle
直到运行时才会被注意到

00:32:45.306 --> 00:32:47.316 A:middle
我们想要使用这些 DSL

00:32:47.736 --> 00:32:49.146 A:middle
但我们也想要将它们

00:32:49.276 --> 00:32:51.526 A:middle
整合到我们的语言和工具中

00:32:53.316 --> 00:32:55.466 A:middle
在 Swift 5.1 中 我们

00:32:55.466 --> 00:32:57.626 A:middle
引入了在 Swift 中定义

00:32:57.626 --> 00:32:58.766 A:middle
嵌入式 DSL 的功能

00:32:59.516 --> 00:33:06.516 A:middle
[掌声]

00:33:07.016 --> 00:33:08.256 A:middle
我们来看看这个代码

00:33:08.256 --> 00:33:10.116 A:middle
它定义了一个 HTML 对象

00:33:10.656 --> 00:33:12.476 A:middle
我的一位同事只是为了娱乐

00:33:12.476 --> 00:33:15.636 A:middle
用这个新的 Swift 特性

00:33:15.636 --> 00:33:17.906 A:middle
在几个小时内 为 HTML DSL

00:33:17.906 --> 00:33:19.236 A:middle
提供了原型支持

00:33:20.056 --> 00:33:21.706 A:middle
在这里你可以看到

00:33:21.706 --> 00:33:23.796 A:middle
这个代码看起来像 Swift

00:33:23.796 --> 00:33:26.276 A:middle
但你又被 HTML 元素的定义所吸引

00:33:26.536 --> 00:33:29.886 A:middle
而你在这里可以看到

00:33:29.886 --> 00:33:32.646 A:middle
熟悉的 Swift 概念 比如闭包和方法调用

00:33:33.076 --> 00:33:34.596 A:middle
我们这里使用的是

00:33:34.596 --> 00:33:35.956 A:middle
Swift 程序中的变量

00:33:36.756 --> 00:33:38.496 A:middle
该工具将会确保

00:33:38.496 --> 00:33:40.366 A:middle
没有标签的缺失

00:33:40.366 --> 00:33:42.816 A:middle
同时提供语法的高亮显示和重构操作

00:33:43.946 --> 00:33:45.666 A:middle
我们的设想是

00:33:45.666 --> 00:33:47.126 A:middle
你不仅可以声明一个

00:33:47.126 --> 00:33:49.366 A:middle
元素列表 还可以使用

00:33:49.426 --> 00:33:51.506 A:middle
这样的 Swift 控制语句

00:33:51.506 --> 00:33:54.116 A:middle
就在这个 DSL 当中

00:33:56.306 --> 00:33:56.456 A:middle
好了

00:33:58.516 --> 00:34:02.316 A:middle
[掌声]

00:34:02.816 --> 00:34:04.386 A:middle
让我们来看看在后台

00:34:04.386 --> 00:34:05.706 A:middle
这是如何实现的

00:34:06.256 --> 00:34:07.926 A:middle
DSL 实现者添加了一个函数

00:34:07.986 --> 00:34:10.565 A:middle
来构建每一个 HTML 元素

00:34:11.545 --> 00:34:13.356 A:middle
而这些函数都是闭包函数

00:34:14.216 --> 00:34:16.626 A:middle
而这里有趣的部分是

00:34:16.626 --> 00:34:18.216 A:middle
这些闭包是特殊的

00:34:18.815 --> 00:34:20.106 A:middle
它们都有这个自定特性

00:34:20.106 --> 00:34:22.806 A:middle
即 @HTMLBuilder

00:34:22.806 --> 00:34:24.656 A:middle
这告诉了编译器

00:34:24.656 --> 00:34:27.025 A:middle
要使用 HTMLBuilder 类型

00:34:27.096 --> 00:34:27.896 A:middle
来处理这些闭包

00:34:29.576 --> 00:34:30.826 A:middle
我们来看看包含 DSL 代码的

00:34:30.826 --> 00:34:32.706 A:middle
闭包函数是如何转换为

00:34:32.706 --> 00:34:34.716 A:middle
一个正常的 Swift 闭包函数的

00:34:36.056 --> 00:34:37.896 A:middle
这个 DSL 闭包在做什么呢

00:34:38.386 --> 00:34:40.446 A:middle
它正在生成一批值

00:34:41.386 --> 00:34:42.806 A:middle
然而 这些值是未使用的

00:34:42.806 --> 00:34:43.976 A:middle
同时这里也没有

00:34:43.976 --> 00:34:45.716 A:middle
返回语句

00:34:46.456 --> 00:34:48.126 A:middle
那么为了让它工作

00:34:48.126 --> 00:34:51.286 A:middle
编译器将这个代码进行转换

00:34:51.896 --> 00:34:53.646 A:middle
通过先收集这些未使用的值

00:34:54.266 --> 00:34:57.196 A:middle
然后调用构建函数

00:34:57.196 --> 00:34:59.226 A:middle
将它们组合起来

00:35:02.196 --> 00:35:05.046 A:middle
HTMLBuilder 类型提供的

00:35:05.046 --> 00:35:08.076 A:middle
它是由你这个 DSL 作者编写的

00:35:08.146 --> 00:35:10.396 A:middle
同时它可以构建任何

00:35:10.396 --> 00:35:11.576 A:middle
适合你的 DSL 的对象

00:35:12.236 --> 00:35:14.196 A:middle
这里我们正在构建 HTML

00:35:14.196 --> 00:35:15.676 A:middle
因此它就会构建 HTML 对象

00:35:17.976 --> 00:35:19.756 A:middle
我们很高兴使用这个功能

00:35:19.756 --> 00:35:21.336 A:middle
我们用它来驱动

00:35:21.566 --> 00:35:23.796 A:middle
你会在新的 SwiftUI 中

00:35:23.796 --> 00:35:26.286 A:middle
用到的声明语法

00:35:27.516 --> 00:35:33.266 A:middle
[掌声]

00:35:33.766 --> 00:35:35.366 A:middle
这里有一个相关的例子

00:35:35.366 --> 00:35:37.616 A:middle
在 Swift UI 中使用

00:35:37.616 --> 00:35:39.896 A:middle
其自定 Swift DSL

00:35:41.196 --> 00:35:42.706 A:middle
这个特性可在 beta 1 中使用

00:35:42.706 --> 00:35:44.596 A:middle
我们很想看到

00:35:44.596 --> 00:35:46.146 A:middle
它将怎样让你从中受益

00:35:46.146 --> 00:35:47.846 A:middle
而你又会用它构建出怎样的 DSL

00:35:48.886 --> 00:35:50.226 A:middle
我们会马上在 Swift 论坛上

00:35:50.226 --> 00:35:52.526 A:middle
讨论该特性背后的这些细节

00:35:53.336 --> 00:35:54.356 A:middle
如果你有兴趣来

00:35:54.356 --> 00:35:55.776 A:middle
塑造这个特性的未来

00:35:55.776 --> 00:35:57.416 A:middle
或者其他的 Swift 特性

00:35:57.886 --> 00:35:59.306 A:middle
那么十分欢迎你的加入

00:36:03.216 --> 00:36:05.106 A:middle
我所说谈到的许多改进

00:36:05.106 --> 00:36:06.996 A:middle
都会在我们今年

00:36:06.996 --> 00:36:08.436 A:middle
新发布的 Swift 框架之中

00:36:09.276 --> 00:36:11.186 A:middle
我们非常期待看到

00:36:11.186 --> 00:36:13.286 A:middle
你们将如何从中获益

00:36:13.286 --> 00:36:15.276 A:middle
让你们的 API 更有表现力

00:36:15.276 --> 00:36:15.946 A:middle
干净且易于使用

00:36:16.776 --> 00:36:18.626 A:middle
我们的同事将会做一个

00:36:18.626 --> 00:36:20.906 A:middle
关于现代 Swift API 设计的演讲

00:36:20.906 --> 00:36:22.466 A:middle
届时他们会与你们分享

00:36:22.466 --> 00:36:24.206 A:middle
在用这些特性构建 Apple 框架时

00:36:24.206 --> 00:36:26.646 A:middle
所学到的一些经验教训

00:36:27.446 --> 00:36:29.356 A:middle
那么今天就到这里了

00:36:29.356 --> 00:36:30.816 A:middle
参会愉快 谢谢大家

00:36:31.516 --> 00:36:36.500 A:middle
[掌声]

