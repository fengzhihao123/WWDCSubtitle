WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:06.406 --> 00:00:10.777 align:middle line:0
（开发优秀的分析体验
通过自定义Instruments讲述你的故事）

00:00:14.982 --> 00:00:16.850 align:middle line:-1
下午好 欢迎参加我们的演讲

00:00:16.917 --> 00:00:18.952 align:middle line:-1
开发优秀的分析体验

00:00:19.319 --> 00:00:21.688 align:middle line:-2
我是Daniel Delwood 稍后同事
Kacper Harasim会加入我

00:00:22.122 --> 00:00:25.292 align:middle line:-2
今天我们在此要讲开发优秀的自定义
Instruments程序包

00:00:26.527 --> 00:00:29.429 align:middle line:-2
作为开发人员
我们都致力于创建卓越的、

00:00:29.496 --> 00:00:31.732 align:middle line:-2
可维护的、模块化的
并且可重复利用的代码

00:00:32.165 --> 00:00:34.134 align:middle line:-1
我们都使用其它人设计的框架

00:00:34.201 --> 00:00:36.837 align:middle line:-2
我们希望其它人也能使用
我们所创建的代码

00:00:37.971 --> 00:00:40.841 align:middle line:-1
良好的API设计和文档

00:00:40.908 --> 00:00:43.210 align:middle line:-2
对于用户使用你的框架的体验来说
至关重要

00:00:43.577 --> 00:00:47.147 align:middle line:-2
但我希望你们也考虑一下开发
Instruments程序包

00:00:48.515 --> 00:00:50.784 align:middle line:-2
要了解为什么
让我们以Metal为例

00:00:51.318 --> 00:00:53.820 align:middle line:-1
API设计是中枢 API的调用

00:00:53.887 --> 00:00:55.455 align:middle line:-1
围绕一组核心概念、

00:00:55.756 --> 00:00:58.125 align:middle line:-1
设备、命令缓冲区、纹理等等

00:00:59.126 --> 00:01:00.360 align:middle line:-1
但这并不是全部

00:01:00.861 --> 00:01:02.963 align:middle line:-1
API界面表达了什么是可能的

00:01:03.363 --> 00:01:05.032 align:middle line:-1
但文档和示例代码

00:01:05.098 --> 00:01:08.902 align:middle line:-2
是其他人了解如何用这些概念
构造一个优秀的app的方式

00:01:09.937 --> 00:01:11.305 align:middle line:-1
但这也不是全部

00:01:11.972 --> 00:01:14.374 align:middle line:-1
这两者结合可以帮助开发人员

00:01:14.441 --> 00:01:15.943 align:middle line:-1
使用你的类或框架编写代码

00:01:16.476 --> 00:01:18.011 align:middle line:-1
但如果出现错误怎么办？

00:01:18.712 --> 00:01:21.849 align:middle line:-2
嗯 自定义Instruments
对于你作为作者来说是一种

00:01:22.115 --> 00:01:26.353 align:middle line:-2
教会其他人如何调试、优化
并真正充分利用你的APIs的方式

00:01:26.820 --> 00:01:29.323 align:middle line:-2
若你用过Instruments中
的Metal系统追踪模板

00:01:29.623 --> 00:01:31.191 align:middle line:-1
你肯定了解了其中一些可能的情况

00:01:31.391 --> 00:01:33.994 align:middle line:-1
创建可视化工具

00:01:34.061 --> 00:01:36.463 align:middle line:-2
并针对你所定义的概念和API
进行特别设计

00:01:37.698 --> 00:01:40.801 align:middle line:-2
Instruments程序包
是建立透明性的一种方式

00:01:41.134 --> 00:01:43.504 align:middle line:-2
在底层 你的框架可以对
Instruments程序包进行测试、

00:01:43.570 --> 00:01:45.172 align:middle line:-1
可理解并且支持良好

00:01:45.506 --> 00:01:47.641 align:middle line:-2
花时间来创建一个
自定义Instrument

00:01:47.708 --> 00:01:49.676 align:middle line:-1
可以帮助你建立自信和信任

00:01:50.143 --> 00:01:52.346 align:middle line:-1
坚信代码正在执行你所期待的操作

00:01:53.347 --> 00:01:55.916 align:middle line:-1
工具也是开发成本模型的一个好方式

00:01:56.250 --> 00:01:58.952 align:middle line:-2
你可以了解哪个调用消耗较大
哪个调用消耗很小

00:01:59.419 --> 00:02:00.988 align:middle line:-1
当出现性能问题时

00:02:01.054 --> 00:02:03.824 align:middle line:-1
它们是区分框架错误

00:02:03.991 --> 00:02:05.292 align:middle line:-1
或客户代码错误的最佳方式

00:02:06.627 --> 00:02:11.598 align:middle line:-2
最重要的是Instrument
可以让你讲述你的故事

00:02:12.366 --> 00:02:15.569 align:middle line:-2
Instruments程序包
可以让你有机会解释正在发生什么

00:02:15.636 --> 00:02:17.671 align:middle line:-1
从而帮助可视化重要的指标

00:02:17.738 --> 00:02:20.207 align:middle line:-2
并在用户遇到问题时
帮助他们快速查找问题

00:02:21.074 --> 00:02:22.876 align:middle line:-1
今天我们要讲

00:02:22.943 --> 00:02:25.245 align:middle line:-1
如何创建优秀的检测 从里到外

00:02:25.512 --> 00:02:28.982 align:middle line:-2
从核心开始讲
即在框架中开发跟踪点

00:02:29.316 --> 00:02:33.687 align:middle line:-1
然后在跟踪点上创建架构

00:02:34.054 --> 00:02:37.658 align:middle line:-2
最后在讲可视化和Instrument UI前
讲一下在Instruments内建模和构造

00:02:38.625 --> 00:02:42.329 align:middle line:-2
我们今天要按顺序讲追踪、建模
和可视化

00:02:42.796 --> 00:02:46.266 align:middle line:-2
让我们现在开始吧
讲一下OSSignpost

00:02:47.835 --> 00:02:52.072 align:middle line:-2
OSSignpost是2018年
引入的一个低消耗的追踪基元

00:02:52.472 --> 00:02:56.076 align:middle line:-1
路标分为两种：点事件和区间

00:02:56.743 --> 00:02:58.912 align:middle line:-2
现在它们支持在参数中
记录任意一种数据

00:02:59.079 --> 00:03:01.882 align:middle line:-2
通过像printf一样的
formatString

00:03:02.349 --> 00:03:06.220 align:middle line:-2
与printf不同
所有路标都以静态字符串命名

00:03:07.921 --> 00:03:10.657 align:middle line:-2
现在在Swift中
OSSignpost只是其中一个核心API

00:03:10.724 --> 00:03:13.760 align:middle line:-1
它有三种类型：开始、结束和事件

00:03:14.294 --> 00:03:17.965 align:middle line:-2
在C语言中 它们的界面
通过三个有用的宏命令表达

00:03:19.333 --> 00:03:22.870 align:middle line:-2
现在重点是要注意
OSSignpost建立在OSLog上

00:03:23.303 --> 00:03:26.006 align:middle line:-1
意思是许多追踪行为和可配置性

00:03:26.340 --> 00:03:28.542 align:middle line:-1
都由所提供的日志句柄决定

00:03:29.409 --> 00:03:32.145 align:middle line:-2
日志句柄实际上是用于
跟踪的命名空间

00:03:32.679 --> 00:03:35.682 align:middle line:-1
可以让你指定子系统和类别

00:03:36.350 --> 00:03:40.087 align:middle line:-1
以及每个路标的静态名称

00:03:40.420 --> 00:03:43.891 align:middle line:-1
这就给追踪点提供了逻辑结构和等级

00:03:45.692 --> 00:03:49.062 align:middle line:-2
自定义Instruments创建在
OSSignpost上主要有两个原因

00:03:49.596 --> 00:03:50.964 align:middle line:-1
第一 它们是暂时的

00:03:52.032 --> 00:03:54.701 align:middle line:-1
所有路标 无论是点事件或区间

00:03:55.002 --> 00:03:57.838 align:middle line:-1
都隐含地记录高精度的时间戳

00:03:59.773 --> 00:04:00.807 align:middle line:-1
在我们高度并行的世界中

00:04:00.874 --> 00:04:03.010 align:middle line:-1
拥有对重叠区间的良好支持

00:04:03.076 --> 00:04:04.611 align:middle line:-1
也非常重要

00:04:04.778 --> 00:04:07.614 align:middle line:-2
OSSignpost通过路标ID
来实现这个

00:04:08.215 --> 00:04:12.186 align:middle line:-1
这为匹配相关事件记录了足够的情境

00:04:12.419 --> 00:04:14.021 align:middle line:-1
甚至当开端或结束事件

00:04:14.087 --> 00:04:16.890 align:middle line:-2
发生在不同的线程上
或不同的分派队列上时也可以

00:04:18.392 --> 00:04:21.595 align:middle line:-2
OSSignpost的
第二个原因是它们消耗低

00:04:22.196 --> 00:04:25.165 align:middle line:-1
日志记录机制在设计时考虑到了效率

00:04:25.532 --> 00:04:29.503 align:middle line:-2
无论何时当你提交OSSignpost
它都记录最小量的数据

00:04:30.470 --> 00:04:33.040 align:middle line:-1
围绕静态字符串有一些优化

00:04:33.207 --> 00:04:35.943 align:middle line:-1
比如格式字符串和路标名称

00:04:36.143 --> 00:04:40.080 align:middle line:-2
实际上只是作为
二进制文本段的偏移量提交

00:04:40.747 --> 00:04:43.851 align:middle line:-2
事实上OSSignpost的
消耗足够低

00:04:44.418 --> 00:04:47.321 align:middle line:-2
在绝大多数情况下
你可以把它们留在生产代码中

00:04:47.821 --> 00:04:50.724 align:middle line:-1
这就是它们对创建工具有用的原因

00:04:50.791 --> 00:04:54.528 align:middle line:-2
这些工具除了帮助你解决问题之外
还可以帮助你调试优化的代码

00:04:56.096 --> 00:04:57.865 align:middle line:-2
当Instruments
记录路标数据时

00:04:57.931 --> 00:05:01.368 align:middle line:-1
你将获得所有明确的字段

00:05:01.802 --> 00:05:04.438 align:middle line:-2
包括那个格式字符串以及
你要提供的参数

00:05:05.172 --> 00:05:07.140 align:middle line:-2
但在Instruments中
你还会获得

00:05:07.207 --> 00:05:09.376 align:middle line:-1
所有隐含的字段

00:05:09.743 --> 00:05:12.446 align:middle line:-1
比如时间戳或调用线程

00:05:12.513 --> 00:05:13.547 align:middle line:-1
这些非常有用

00:05:14.548 --> 00:05:17.618 align:middle line:-1
如果你使用启用了回溯的日志句柄

00:05:17.985 --> 00:05:22.489 align:middle line:-2
那么还会记录调用栈
并在Instruments中显示

00:05:24.124 --> 00:05:26.293 align:middle line:-2
当向代码找那个添加追踪时
重要的是要注意

00:05:26.360 --> 00:05:30.430 align:middle line:-2
OSLog和OSSignpost
有三种不同的行为模式

00:05:31.331 --> 00:05:36.870 align:middle line:-2
默认情况下OSLog是…
每个OSLog句柄都启用路标

00:05:37.371 --> 00:05:40.674 align:middle line:-2
因此它们仍然是低消耗
并且只记录到一个环形缓冲区

00:05:41.875 --> 00:05:46.413 align:middle line:-2
当Instruments或
另一个客户请求显示这个数据时

00:05:47.848 --> 00:05:50.050 align:middle line:-1
OSLog系统会立即进入流模式

00:05:50.117 --> 00:05:51.552 align:middle line:-1
那将会增加一些消耗

00:05:53.086 --> 00:05:56.156 align:middle line:-1
然而今年有两个新的动态类别

00:05:56.456 --> 00:05:58.458 align:middle line:-2
只有当Instruments
记录时才能启用

00:05:59.493 --> 00:06:01.228 align:middle line:-1
这些动态类别

00:06:01.695 --> 00:06:05.199 align:middle line:-1
用于记录第二个栈追踪

00:06:05.365 --> 00:06:07.534 align:middle line:-1
这增加了少许额外的消耗

00:06:08.268 --> 00:06:11.438 align:middle line:-2
考虑到这点 OSSignpost
的实际消耗是多少？

00:06:13.006 --> 00:06:16.343 align:middle line:-1
嗯 许多因素都会影响真实的性能

00:06:16.610 --> 00:06:18.879 align:middle line:-1
比如设备类型、硬件型号、

00:06:19.146 --> 00:06:22.216 align:middle line:-1
OS版本号、系统加载、热处理等等

00:06:22.716 --> 00:06:24.318 align:middle line:-1
因此很难给出一个具体的数字

00:06:24.852 --> 00:06:27.221 align:middle line:-1
但我想给出一些对数尺度的

00:06:27.287 --> 00:06:28.388 align:middle line:-1
数量级近似值

00:06:28.689 --> 00:06:31.458 align:middle line:-1
因为我认为理解相对消耗很有用

00:06:32.292 --> 00:06:34.361 align:middle line:-1
如果我们在发布版本中看一下路标

00:06:35.028 --> 00:06:37.197 align:middle line:-1
所有路标都以不到一微妙的速度记录

00:06:37.397 --> 00:06:42.135 align:middle line:-2
新的默认关闭的动态类别实际上处于
很低的纳秒范围内

00:06:43.537 --> 00:06:47.875 align:middle line:-2
当Instruments在延迟
或最后几秒模式记录时

00:06:48.609 --> 00:06:50.310 align:middle line:-1
这些动态类别将会开启

00:06:50.377 --> 00:06:52.946 align:middle line:-1
以匹配默认为开的类别的行为

00:06:53.514 --> 00:06:55.315 align:middle line:-1
并且它们的消耗相同

00:06:55.382 --> 00:06:58.051 align:middle line:-1
除动态堆栈类别外

00:06:58.218 --> 00:07:00.988 align:middle line:-2
由于动态堆栈记录调用栈
所以它消耗稍微大一些

00:07:01.288 --> 00:07:02.856 align:middle line:-1
处于毫秒范围内

00:07:04.525 --> 00:07:06.260 align:middle line:-1
然而当请求流模式时

00:07:06.426 --> 00:07:08.996 align:middle line:-1
所有这些的消耗将明显增加

00:07:09.730 --> 00:07:11.532 align:middle line:-1
并进入几十微妙的范围

00:07:13.000 --> 00:07:14.101 align:middle line:-1
考虑到这一点

00:07:15.702 --> 00:07:19.806 align:middle line:-2
你可以采取什么措施来最小化
OSSignpost在记录时的消耗？

00:07:20.040 --> 00:07:22.209 align:middle line:-1
如果你担心那个运行时间消耗

00:07:22.276 --> 00:07:24.178 align:middle line:-1
或它们开始在配置文件中显示的话

00:07:25.479 --> 00:07:27.014 align:middle line:-1
嗯 你可以采取两个很容易的措施

00:07:27.447 --> 00:07:31.051 align:middle line:-2
首先你使用Instruments
的延迟或最后几秒模式

00:07:31.118 --> 00:07:32.152 align:middle line:-1
替换立即模式

00:07:32.519 --> 00:07:34.788 align:middle line:-2
这可以避免OSSignpost
进入流模式

00:07:35.255 --> 00:07:36.456 align:middle line:-1
并减少消耗

00:07:36.623 --> 00:07:38.325 align:middle line:-1
配置模板 当你打开模板时

00:07:38.525 --> 00:07:40.861 align:middle line:-2
以其中一种模式进行记录
是一件很容易的事

00:07:43.463 --> 00:07:46.633 align:middle line:-1
同时如果你使用新的动态追踪类别

00:07:46.867 --> 00:07:49.803 align:middle line:-2
这是一种在不记录时
最小化消耗的好方法

00:07:50.070 --> 00:07:53.974 align:middle line:-1
因为路标默认为关闭

00:07:54.708 --> 00:07:56.810 align:middle line:-2
只有自定义Instruments
才可以启用它们

00:07:56.877 --> 00:08:00.180 align:middle line:-2
因此这个数据也不会在内置的
OSSignpost工具中与追踪挤在一起

00:08:02.416 --> 00:08:05.085 align:middle line:-1
那么作为框架或子系统的作者

00:08:05.152 --> 00:08:08.555 align:middle line:-2
当你分析时到底提交多少路标
才是合理的？

00:08:09.122 --> 00:08:10.090 align:middle line:-1
嗯 你可以提交许多

00:08:10.157 --> 00:08:14.127 align:middle line:-1
但让我们假定一个非常保守的目标

00:08:14.361 --> 00:08:16.797 align:middle line:-2
当你分析时
即使单核的CPU也低于1%

00:08:17.531 --> 00:08:19.800 align:middle line:-1
然后让我们假定

00:08:20.267 --> 00:08:22.202 align:middle line:-1
路标的大概消耗是

00:08:22.269 --> 00:08:25.372 align:middle line:-1
每启用一个路标需要大约半微妙

00:08:26.440 --> 00:08:29.443 align:middle line:-1
那等同于每秒启用20000个路标

00:08:30.244 --> 00:08:32.446 align:middle line:-2
即使是在iPad Pro上的
显示链接情境中

00:08:32.513 --> 00:08:35.448 align:middle line:-1
以每秒120帧的速度运行

00:08:36.015 --> 00:08:39.119 align:middle line:-1
这仍然足够使帧之间有83个区间

00:08:40.587 --> 00:08:46.693 align:middle line:-2
再一次 真实性能会发生改变
这些只是估算

00:08:47.094 --> 00:08:50.564 align:middle line:-1
重点是要记住路标是一个共享资源

00:08:51.865 --> 00:08:54.234 align:middle line:-2
你用得越多
对日志记录系统的影响越大

00:08:54.635 --> 00:08:58.105 align:middle line:-2
那就是说它们可以执行这种
高速率追踪

00:08:58.172 --> 00:09:00.474 align:middle line:-1
并且有时候非常有用

00:09:00.941 --> 00:09:03.911 align:middle line:-2
有时候它们对于查找你代码中的
管道停滞

00:09:04.244 --> 00:09:06.213 align:middle line:-1
或排序问题非常关键

00:09:07.281 --> 00:09:10.150 align:middle line:-1
然而请记住 你可能想根据不同用户

00:09:10.450 --> 00:09:12.819 align:middle line:-1
把路标分离到不同类别中

00:09:13.353 --> 00:09:15.889 align:middle line:-1
很可能你框架的客户

00:09:15.956 --> 00:09:18.458 align:middle line:-2
不像框架的贡献者那样
需要那么多细节

00:09:18.792 --> 00:09:21.161 align:middle line:-1
客户可能需要追踪更多的实施细节

00:09:22.296 --> 00:09:25.399 align:middle line:-2
如果你把追踪点分到
不同的日志句柄中

00:09:25.766 --> 00:09:28.535 align:middle line:-1
这将使你的工具只能启用必要的子集

00:09:30.270 --> 00:09:32.239 align:middle line:-1
因为追踪是检测的基础

00:09:32.306 --> 00:09:34.308 align:middle line:-1
我想快速讲四个最佳实践

00:09:36.243 --> 00:09:40.647 align:middle line:-2
第一个也是最重要的一个
总是终止你开始的任意区间

00:09:41.281 --> 00:09:42.783 align:middle line:-1
这对于正确性来说至关重要

00:09:43.450 --> 00:09:45.319 align:middle line:-1
永久开启的区间

00:09:45.385 --> 00:09:47.454 align:middle line:-2
真会降低Instruments的
分析速度

00:09:48.388 --> 00:09:51.258 align:middle line:-2
在这个例子中
我们有OSSignpost调用

00:09:51.325 --> 00:09:55.662 align:middle line:-2
包装了一段消耗大
并且有潜在报错风险的代码

00:09:56.396 --> 00:09:58.832 align:middle line:-1
问题是如果出现报错

00:09:58.999 --> 00:10:03.670 align:middle line:-2
控制流将跳到捕捉范围
并完全跳过终止路标

00:10:05.038 --> 00:10:07.841 align:middle line:-2
现在Swift的延迟状态
确实是处理这个问题的好方法

00:10:07.908 --> 00:10:11.845 align:middle line:-1
确保无论提前返回或出现报错

00:10:13.547 --> 00:10:16.183 align:middle line:-1
当我们提交当前范围时

00:10:16.250 --> 00:10:17.484 align:middle line:-2
仍会调用那个
OSSignpost终止调用

00:10:19.186 --> 00:10:20.521 align:middle line:-1
第二 为了效率

00:10:20.854 --> 00:10:25.125 align:middle line:-2
请避免在开始和结束追踪点中
记录相同的数据

00:10:25.292 --> 00:10:27.194 align:middle line:-2
当数据可用时
只在第一个追踪点中记录它

00:10:27.895 --> 00:10:29.396 align:middle line:-1
这就避免了重复工作

00:10:29.796 --> 00:10:32.132 align:middle line:-2
并尽快给
Instruments提供值

00:10:32.766 --> 00:10:38.071 align:middle line:-2
在这个例子中 我们不需要重复
请求编号或原生尺寸

00:10:39.206 --> 00:10:43.877 align:middle line:-2
我们不使用请求编号来匹配
重叠情况下的区间

00:10:44.845 --> 00:10:47.181 align:middle line:-1
这些追踪点实际上可以用来

00:10:47.748 --> 00:10:51.952 align:middle line:-2
给每个区间对的日志句柄
生成唯一的路标ID

00:10:53.420 --> 00:10:58.492 align:middle line:-2
第三 当没启用路标时避免做
不必要的工作

00:10:59.359 --> 00:11:02.696 align:middle line:-2
如果你的日志句柄需要使用其中一个
动态追踪类别

00:11:02.996 --> 00:11:05.032 align:middle line:-1
那么路标启用属性将表明

00:11:05.098 --> 00:11:06.934 align:middle line:-2
无论Instruments
当时是否正在记录

00:11:07.267 --> 00:11:08.902 align:middle line:-1
意思是

00:11:09.102 --> 00:11:14.975 align:middle line:-2
把消耗大的数据的计算放在那个
OSSignpost检查之后是个不错的方式

00:11:17.211 --> 00:11:20.647 align:middle line:-2
第四 其实对于你的工具而言
你需要的只是追踪数据

00:11:21.448 --> 00:11:23.550 align:middle line:-2
思考一下你的Guard
语句和预处理

00:11:23.951 --> 00:11:25.686 align:middle line:-1
因为有时你想追踪这些

00:11:25.752 --> 00:11:27.120 align:middle line:-1
以包含短区间

00:11:27.754 --> 00:11:29.456 align:middle line:-1
比如 如果你有一个方法

00:11:29.756 --> 00:11:32.893 align:middle line:-2
你想了解缓存命中和缓存缺失
之间的区别

00:11:33.660 --> 00:11:36.496 align:middle line:-2
但其它时候
这些提早的返回可能意义不大

00:11:36.864 --> 00:11:38.332 align:middle line:-1
对于这些情况而言

00:11:38.732 --> 00:11:41.969 align:middle line:-1
请考虑把路标移到预处理之后

00:11:42.236 --> 00:11:45.806 align:middle line:-2
从而减少
你要发送给路标系统的数据量

00:11:46.840 --> 00:11:49.376 align:middle line:-2
现在了解了这些技巧
重要的是要记住

00:11:49.643 --> 00:11:51.445 align:middle line:-1
追踪点确实是你在追踪点上

00:11:51.678 --> 00:11:53.347 align:middle line:-1
创建的所有工具的基础

00:11:53.747 --> 00:11:56.550 align:middle line:-2
并且绝大多数时候
它们将出现在你的生产代码中

00:11:56.917 --> 00:11:58.685 align:middle line:-2
因此这也是为什么考虑追踪点的
性能和可维护性

00:11:58.886 --> 00:12:01.188 align:middle line:-1
非常重要的原因

00:12:01.889 --> 00:12:03.190 align:middle line:-1
因为它们处于核心中

00:12:03.557 --> 00:12:04.992 align:middle line:-1
路标调用的变更

00:12:05.058 --> 00:12:07.828 align:middle line:-2
可能会导致需要修改
你在追踪点上所创建的工具

00:12:09.429 --> 00:12:10.998 align:middle line:-1
因此请保持追踪点的稳定

00:12:11.498 --> 00:12:13.400 align:middle line:-1
避免追踪实施细节

00:12:13.734 --> 00:12:18.038 align:middle line:-2
如果可能 请尽可能接近API层
添加OSSignpost调用

00:12:19.039 --> 00:12:21.708 align:middle line:-2
现在在代码基中四处移动追踪点
已经不成问题了

00:12:22.042 --> 00:12:24.144 align:middle line:-2
你不必担心诸如内联之类的
编译器优化

00:12:24.211 --> 00:12:25.779 align:middle line:-1
那可能会替你进行此类优化

00:12:26.813 --> 00:12:30.284 align:middle line:-1
你需要确保不要修改

00:12:30.651 --> 00:12:32.085 align:middle line:-1
静态字符串

00:12:32.352 --> 00:12:36.456 align:middle line:-1
我的意思是特别是子系统、类别、

00:12:37.090 --> 00:12:39.626 align:middle line:-1
路标名称或格式字符串

00:12:40.027 --> 00:12:41.161 align:middle line:-1
如果你修改了其中任意一个

00:12:41.228 --> 00:12:43.597 align:middle line:-2
你要记得更新
Instruments程序包

00:12:45.132 --> 00:12:47.801 align:middle line:-1
接下来让我们讲一下建模

00:12:48.168 --> 00:12:51.171 align:middle line:-2
以及向Instruments内的
数据中添加结构

00:12:53.106 --> 00:12:56.443 align:middle line:-2
Instruments的架构基于
表中所存储的一切

00:12:56.877 --> 00:12:59.179 align:middle line:-1
模式决定那些表的结构

00:12:59.246 --> 00:13:01.381 align:middle line:-2
这些都是由Instruments
分析内核管理的

00:13:02.249 --> 00:13:04.952 align:middle line:-2
要更深入地了解
Instruments架构的信息

00:13:05.252 --> 00:13:08.555 align:middle line:-2
我推荐你参看2018年的创建
自定义Instruments演讲

00:13:08.889 --> 00:13:11.024 align:middle line:-1
然而现在让我们看一下

00:13:11.091 --> 00:13:13.026 align:middle line:-1
建模在哪里创建分析体验

00:13:14.328 --> 00:13:16.496 align:middle line:-1
在左侧我们有OSSignpost

00:13:16.563 --> 00:13:19.399 align:middle line:-2
它是Instruments记录的
主要数据源之一

00:13:20.033 --> 00:13:21.635 align:middle line:-1
表中所填充的数据

00:13:21.835 --> 00:13:24.571 align:middle line:-2
有预定义的模式可以在自定义
Instruments中使用

00:13:26.073 --> 00:13:27.908 align:middle line:-1
建模在中间 是下一个阶段

00:13:27.975 --> 00:13:31.078 align:middle line:-2
建模器从一个或多个输入表中
观察数据

00:13:31.378 --> 00:13:34.381 align:middle line:-1
对数据进行推理 然后把数据提交给

00:13:34.448 --> 00:13:37.050 align:middle line:-1
你指定的一个或多个输出表

00:13:38.085 --> 00:13:40.754 align:middle line:-1
建模器是特定域逻辑所在的地方

00:13:41.121 --> 00:13:43.056 align:middle line:-1
输出表的模式

00:13:43.423 --> 00:13:47.694 align:middle line:-2
用于指定在数据中应用哪种
类型和格式

00:13:49.363 --> 00:13:51.298 align:middle line:-1
右侧是最后一步即可视化

00:13:51.798 --> 00:13:55.035 align:middle line:-2
可视化用于在XML中描述
Instruments中标准UI

00:13:55.435 --> 00:13:58.005 align:middle line:-2
你可以在这里指定
如何在建模器的输出表中

00:13:58.071 --> 00:13:59.406 align:middle line:-1
显示数据和如何用图表显示数据

00:13:59.840 --> 00:14:02.509 align:middle line:-1
比如给哪一栏绘图并用作值

00:14:02.743 --> 00:14:04.611 align:middle line:-1
或哪一栏用作彩色标签

00:14:05.779 --> 00:14:07.814 align:middle line:-2
因为所有的自定义
Instruments的可视化

00:14:07.881 --> 00:14:10.884 align:middle line:-2
都基于你的模式
以及你的建模器的输出

00:14:11.451 --> 00:14:13.353 align:middle line:-1
因此下边这个过程非常重要

00:14:13.420 --> 00:14:16.423 align:middle line:-2
检查OSSignpost
追踪点是否良好

00:14:16.924 --> 00:14:20.394 align:middle line:-2
然后了解如何把这个数据
放到自定义的模式中

00:14:22.996 --> 00:14:25.766 align:middle line:-2
因此自定义Instrument中
的所有数据必须存储在表中

00:14:25.832 --> 00:14:28.168 align:middle line:-1
表以一种或两种方式处理数据

00:14:28.769 --> 00:14:30.704 align:middle line:-1
点模式有一个时间戳栏

00:14:31.471 --> 00:14:34.942 align:middle line:-2
而区间模式既有时间戳栏
又有持续时间栏

00:14:35.642 --> 00:14:39.146 align:middle line:-2
这意味着你需要定义至少一个
点或区间模式

00:14:39.546 --> 00:14:41.682 align:middle line:-1
然后把命名和类型提供给其余的栏

00:14:42.850 --> 00:14:45.619 align:middle line:-1
现在通过建模规则填充数据

00:14:46.186 --> 00:14:47.588 align:middle line:-1
建模规则操纵的是输入数据

00:14:47.654 --> 00:14:49.857 align:middle line:-2
这些规则在CLIPS
语言中进行表达

00:14:50.390 --> 00:14:54.194 align:middle line:-2
好消息是Instruments
提供一些模式

00:14:54.628 --> 00:14:56.096 align:middle line:-1
可以自动生成建模器

00:14:56.430 --> 00:14:59.399 align:middle line:-2
因此你不需要编写CLIPS代码
除非你希望这么做

00:15:02.536 --> 00:15:04.171 align:middle line:-1
并且你想确保数据的准确性

00:15:04.505 --> 00:15:07.608 align:middle line:-2
Instruments在库中提供一个内置
OSSignpost工具

00:15:08.008 --> 00:15:09.877 align:middle line:-1
对于记录和检查

00:15:09.943 --> 00:15:12.646 align:middle line:-2
OSSignpost区间看起来
是否合理非常有效

00:15:13.247 --> 00:15:16.650 align:middle line:-2
检查器可以帮助你验证原生数据
是否就是你所预期的数据

00:15:18.085 --> 00:15:19.219 align:middle line:-1
一旦你检查了数据

00:15:19.586 --> 00:15:21.021 align:middle line:-2
一个新的
Instruments目标

00:15:21.522 --> 00:15:23.457 align:middle line:-1
是开始创建你自己的工具的好方法

00:15:24.024 --> 00:15:27.594 align:middle line:-2
通过Xcode针对自定义
Instruments的内置XML片段

00:15:27.828 --> 00:15:29.630 align:middle line:-1
你距离在库中拥有

00:15:29.963 --> 00:15:32.566 align:middle line:-2
自动建模器和Instrument
只差几个元素了

00:15:33.133 --> 00:15:35.536 align:middle line:-1
要了解这一切的最佳方式是通过演示

00:15:35.602 --> 00:15:37.838 align:middle line:-2
为此 我要邀请我同事
Kacper上台来

00:15:44.611 --> 00:15:46.380 align:middle line:-1
谢谢Daniel 大家好

00:15:48.749 --> 00:15:50.784 align:middle line:-2
我们在Mac上的
Solar System app

00:15:50.851 --> 00:15:53.887 align:middle line:-1
用于处理大量关于星球、

00:15:54.288 --> 00:15:56.523 align:middle line:-1
图片、视频和二进制的数据

00:15:57.057 --> 00:15:58.926 align:middle line:-1
为了优化它的磁盘使用情况

00:15:59.092 --> 00:16:01.228 align:middle line:-2
我创建了一个框架叫做
Solar Compression

00:16:01.461 --> 00:16:03.163 align:middle line:-1
使用路标的压缩库

00:16:03.363 --> 00:16:06.233 align:middle line:-1
有效地从磁盘中编码和解码数据

00:16:07.100 --> 00:16:09.670 align:middle line:-1
现在我想给我的框架创建检查

00:16:09.870 --> 00:16:11.972 align:middle line:-1
给未来用户提供一些数据

00:16:12.973 --> 00:16:16.143 align:middle line:-2
我们有两个概念值得追踪
和进行可视化呈现

00:16:16.777 --> 00:16:20.848 align:middle line:-2
首先CompressionManager
是个用于协调压缩任务的对象

00:16:21.415 --> 00:16:23.183 align:middle line:-1
可以通过许多通道创建它

00:16:23.350 --> 00:16:26.453 align:middle line:-1
指定可以同时执行多少任务

00:16:27.554 --> 00:16:29.223 align:middle line:-1
第二 我想通过捕捉压缩速率

00:16:29.289 --> 00:16:32.793 align:middle line:-1
衡量对特定文件类型和算法的

00:16:33.026 --> 00:16:34.528 align:middle line:-1
压缩性能

00:16:35.229 --> 00:16:36.430 align:middle line:-1
通过检查这些

00:16:36.496 --> 00:16:39.299 align:middle line:-1
用户可以决定是否值得压缩数据

00:16:40.434 --> 00:16:43.303 align:middle line:-2
我编写了区间
在OSSignpost API中

00:16:43.370 --> 00:16:44.738 align:middle line:-1
表达框架的这个概念

00:16:45.005 --> 00:16:47.875 align:middle line:-2
让我们进入CompressionManager
Swift文件看一下

00:16:49.610 --> 00:16:51.311 align:middle line:-1
首先让我们看一下日志句柄

00:16:51.712 --> 00:16:55.582 align:middle line:-2
我的日志句柄把我框架的
捆绑包标识符指定为子系统

00:16:55.883 --> 00:16:57.551 align:middle line:-1
并把我的类名称指定为类别

00:16:59.520 --> 00:17:00.721 align:middle line:-1
压缩和解压

00:17:00.787 --> 00:17:03.557 align:middle line:-1
是压缩管理器的公共界面的一部分

00:17:04.558 --> 00:17:07.560 align:middle line:-1
它们一开始都创建压缩工作项实例

00:17:07.627 --> 00:17:10.497 align:middle line:-1
压缩有关特定压缩任务的信息

00:17:11.164 --> 00:17:14.201 align:middle line:-2
接下来它们调用私有的
SubmitWorkItemMethod

00:17:15.736 --> 00:17:18.105 align:middle line:-1
因为压缩通道可能非常繁忙

00:17:18.305 --> 00:17:21.775 align:middle line:-2
在通道上创建压缩项
和执行压缩项之间

00:17:21.942 --> 00:17:23.343 align:middle line:-1
可能有很长的时间间隔

00:17:23.777 --> 00:17:26.246 align:middle line:-1
这是开始测量这种延迟的完美场所

00:17:27.181 --> 00:17:29.783 align:middle line:-1
我们要通过调用

00:17:30.083 --> 00:17:31.685 align:middle line:-2
以CompressionItemWait
名称开始命名的路标类型

00:17:32.986 --> 00:17:35.222 align:middle line:-2
接下来我们在这里使用
Guard条件语句

00:17:35.389 --> 00:17:39.026 align:middle line:-2
在我们继续进一步之前
要确保源文件存在

00:17:39.860 --> 00:17:42.930 align:middle line:-2
根据Daniel的建议
我要把它移到函数顶部

00:17:43.096 --> 00:17:45.365 align:middle line:-1
从而确保我的区间总是处于关闭状态

00:17:47.367 --> 00:17:49.670 align:middle line:-2
接下来我们有
ExecuteWorkItemMethod

00:17:49.937 --> 00:17:53.507 align:middle line:-2
当压缩任务已经准备好在通道上
执行时调用它

00:17:54.641 --> 00:17:57.811 align:middle line:-2
起初 我们需要给那个项指出
等待结束的时间

00:17:58.078 --> 00:18:01.548 align:middle line:-2
通过调用以与之前名称相同的名称
为命名结尾的路标类型实现

00:18:03.150 --> 00:18:05.485 align:middle line:-2
接下来我们用
CompressionExecution路标

00:18:05.686 --> 00:18:07.454 align:middle line:-1
表明压缩的开端

00:18:08.188 --> 00:18:10.891 align:middle line:-2
在元数据中 我们有诸如此类的东西
比如算法、

00:18:10.958 --> 00:18:14.528 align:middle line:-1
某种操作、关于源目的地的信息、

00:18:14.595 --> 00:18:17.297 align:middle line:-1
通道和调用线程

00:18:18.398 --> 00:18:22.836 align:middle line:-2
正如我们之前所了解的
OSSignpost隐含记录参数

00:18:23.003 --> 00:18:26.240 align:middle line:-2
包括线程 因此你现在移除线程
没有任何问题

00:18:31.378 --> 00:18:33.213 align:middle line:-1
接下来我们创建目的地文件

00:18:33.714 --> 00:18:37.384 align:middle line:-1
并同步执行压缩操作

00:18:37.951 --> 00:18:41.889 align:middle line:-2
完成后 我们把它记录下来
并附加目的地文件尺寸

00:18:42.556 --> 00:18:45.592 align:middle line:-2
这是我可以改善路标调用的
另一个地方

00:18:45.959 --> 00:18:49.763 align:middle line:-2
这里的StartCompressionMethod
是一个会产生报错的方法

00:18:50.264 --> 00:18:51.698 align:middle line:-1
如果它确实产生了报错

00:18:52.065 --> 00:18:54.168 align:middle line:-1
将不会调用这里的路标调用

00:18:55.002 --> 00:18:56.336 align:middle line:-1
为了防止这种情况发生

00:18:56.403 --> 00:18:58.639 align:middle line:-1
我可以在这里引入延迟代码块

00:19:07.581 --> 00:19:12.286 align:middle line:-2
让我们使用Xcode的Profile动作
来看一下Instruments中的路标

00:19:19.359 --> 00:19:20.894 align:middle line:-1
让我们从一个空的模板开始

00:19:22.729 --> 00:19:24.965 align:middle line:-2
给它添加我们的
路标工具

00:19:26.800 --> 00:19:28.769 align:middle line:-1
并只做几秒钟的记录

00:19:32.306 --> 00:19:33.574 align:middle line:-1
我们现在可以检验数据

00:19:33.974 --> 00:19:38.545 align:middle line:-2
我展开路标instrument查看
所有记录下来的子系统

00:19:40.247 --> 00:19:41.882 align:middle line:-2
这是我们的那个
Solar Compression

00:19:42.249 --> 00:19:45.853 align:middle line:-2
我可以进一步展开它
查看压缩管理器类别

00:19:46.987 --> 00:19:51.558 align:middle line:-2
我可用Control-Z重新调整
追踪的尺寸以适应全部所包含的图表

00:19:52.860 --> 00:19:55.495 align:middle line:-2
让我们捏合以放大
更具体地检验数据

00:19:57.397 --> 00:20:00.567 align:middle line:-1
顶部有全部的压缩执行路标

00:20:01.368 --> 00:20:03.170 align:middle line:-1
底部有等待执行的任务的

00:20:03.237 --> 00:20:04.471 align:middle line:-1
全部区间

00:20:04.972 --> 00:20:07.174 align:middle line:-1
在这里我们可以注意到一些模式

00:20:08.475 --> 00:20:11.678 align:middle line:-1
比如一次最多执行两个任务

00:20:12.379 --> 00:20:15.616 align:middle line:-2
因此很可能app代码使用了两个
压缩通道

00:20:16.850 --> 00:20:19.553 align:middle line:-1
同时我们可以看到一些尖峰

00:20:19.920 --> 00:20:23.123 align:middle line:-1
那表明有许多任务等待被压缩

00:20:25.392 --> 00:20:29.296 align:middle line:-2
OSSignpost是用于分析
你自己的路标的好工具

00:20:29.496 --> 00:20:31.498 align:middle line:-1
但通常不能给框架的用户

00:20:31.899 --> 00:20:34.067 align:middle line:-1
提供足够的分析情境

00:20:35.002 --> 00:20:36.170 align:middle line:-2
为了改善这个功能
我创建了另一个…

00:20:36.236 --> 00:20:41.441 align:middle line:-2
我创建了使用自定义Instruments的
Solar Compression工具

00:20:42.376 --> 00:20:45.679 align:middle line:-2
通过把这两个路标放到
两个独立的表中

00:20:45.746 --> 00:20:49.850 align:middle line:-2
并调整符合工具标准的UI
我努力改善我们的可视化功能

00:20:50.250 --> 00:20:52.953 align:middle line:-2
现在让我们打开包含这个
工具的追踪文档

00:20:58.825 --> 00:21:01.562 align:middle line:-1
在底部我们看到全部等待执行的任务

00:21:01.628 --> 00:21:04.364 align:middle line:-2
它们的呈现方式与OSSignpost
工具中的呈现方式一样

00:21:07.234 --> 00:21:10.003 align:middle line:-1
在顶部我们看到全部执行区间

00:21:10.204 --> 00:21:11.638 align:middle line:-1
现在由通道分离开

00:21:11.805 --> 00:21:14.708 align:middle line:-2
因此我们确实可以看到
有两个可用的通道

00:21:16.176 --> 00:21:19.313 align:middle line:-1
在这底部 我看到全部的压缩任务

00:21:19.479 --> 00:21:21.982 align:middle line:-1
附带区间信息、源路径、

00:21:22.249 --> 00:21:24.785 align:middle line:-1
文件尺寸、压缩速率等等

00:21:25.752 --> 00:21:27.588 align:middle line:-1
有一个任务引起了我的注意

00:21:27.855 --> 00:21:30.190 align:middle line:-1
这个任务很长 并且以红色显示

00:21:30.591 --> 00:21:33.126 align:middle line:-1
那意味着这个任务的压缩速率很慢

00:21:34.628 --> 00:21:36.196 align:middle line:-1
为了方便地了解它是哪种任务

00:21:36.430 --> 00:21:38.298 align:middle line:-1
我可以切换到活跃的任务详情

00:21:38.966 --> 00:21:43.470 align:middle line:-2
它只用于显示与我的检查头
相交叉的区间

00:21:44.204 --> 00:21:47.274 align:middle line:-2
我可以移动我的检查头
并分析一个任务

00:21:48.709 --> 00:21:51.178 align:middle line:-1
看起来我们正在尝试压缩zip存档

00:21:51.778 --> 00:21:55.048 align:middle line:-1
文件尺寸缩减了百分之一点多

00:21:55.549 --> 00:21:58.385 align:middle line:-2
这并没有缩减很多
也许你根本不应该压缩它

00:22:02.756 --> 00:22:04.825 align:middle line:-1
这里汇总了全部压缩任务

00:22:05.225 --> 00:22:07.427 align:middle line:-1
它提供三种汇总等级

00:22:07.661 --> 00:22:11.098 align:middle line:-1
压缩、源扩展和算法

00:22:12.266 --> 00:22:14.835 align:middle line:-1
在右侧我们看到不同的统计信息

00:22:14.902 --> 00:22:19.640 align:middle line:-2
比如平均压缩速率、持续时间
或节约的空间总量

00:22:20.507 --> 00:22:24.111 align:middle line:-1
这些详情对于比较不同的算法

00:22:24.278 --> 00:22:27.848 align:middle line:-2
或查看不同文件类型的压缩速率
有什么不同非常有用

00:22:28.682 --> 00:22:31.652 align:middle line:-2
比如我们可以看到我们的JPEG
文件尺寸

00:22:31.985 --> 00:22:35.455 align:middle line:-1
平均缩减了34%

00:22:35.522 --> 00:22:38.058 align:middle line:-2
这对于已经严重压缩的文件来说
很不错

00:22:39.660 --> 00:22:43.363 align:middle line:-2
现在让我们看一下
Instrument Inspector怎么样

00:22:47.167 --> 00:22:51.538 align:middle line:-2
我们在这边有
OSSignpost表是点模式

00:22:51.905 --> 00:22:54.975 align:middle line:-1
它查看…所有的开始和结束事件

00:22:56.276 --> 00:22:58.912 align:middle line:-1
我们还有两个路标的表

00:23:02.549 --> 00:23:05.118 align:middle line:-2
它包含我们所记录的与任务有关的
所有数据

00:23:05.552 --> 00:23:09.189 align:middle line:-2
但现在它是根据我们所分配的
编程类型进行格式化的

00:23:11.358 --> 00:23:15.863 align:middle line:-2
在右侧我们可以看到
这个表由UI直接使用

00:23:19.333 --> 00:23:21.301 align:middle line:-1
目前我对我的工具非常满意

00:23:21.935 --> 00:23:25.706 align:middle line:-2
我要改善一件事
即等待执行的任务的呈现方式

00:23:26.440 --> 00:23:28.275 align:middle line:-1
我不想查看特定区间

00:23:28.542 --> 00:23:30.844 align:middle line:-1
我想通过某种方式把它们汇总起来

00:23:31.211 --> 00:23:33.614 align:middle line:-1
清晰地指出负载较高的区域

00:23:34.348 --> 00:23:36.750 align:middle line:-2
我认为Daniel
可能有办法能实现

00:23:37.384 --> 00:23:38.218 align:middle line:-1
Daniel？

00:23:46.260 --> 00:23:47.094 align:middle line:-1
谢谢Kacper

00:23:47.427 --> 00:23:50.063 align:middle line:-2
正如Kacper所展示的那样
库中的OSSignpost工具

00:23:50.430 --> 00:23:53.433 align:middle line:-2
和Inspector
是用于可视化原生数据

00:23:53.800 --> 00:23:56.103 align:middle line:-2
检查Instrument确实
看到了你所预期的数据的不错的方式

00:23:57.104 --> 00:23:59.973 align:middle line:-2
甚至不需要编写自定义
CLIPS建模器

00:24:01.975 --> 00:24:04.111 align:middle line:-1
从而以更有意义的方式呈现他的数据

00:24:04.344 --> 00:24:06.680 align:middle line:-1
通过使用他的框架的压缩概念实现

00:24:07.014 --> 00:24:11.485 align:middle line:-2
只使用了四个追踪点和两个
OSSignpost区间模式

00:24:12.286 --> 00:24:14.821 align:middle line:-1
意思是那并不完全是

00:24:14.888 --> 00:24:15.923 align:middle line:-1
他想要创建的分析体验

00:24:17.024 --> 00:24:20.394 align:middle line:-2
现在自定义建模器
是调整那个体验的不错的工具

00:24:20.761 --> 00:24:23.530 align:middle line:-2
它们可以让你融合
多个日志句柄的数据

00:24:23.597 --> 00:24:25.365 align:middle line:-1
甚至可以使用来自内嵌表的数据

00:24:25.899 --> 00:24:28.335 align:middle line:-1
它们可以让你嵌入更复杂的逻辑

00:24:28.702 --> 00:24:32.005 align:middle line:-1
以维持状态 并对事件顺序进行推理

00:24:32.840 --> 00:24:34.908 align:middle line:-1
编写你自己的自定义建模器

00:24:34.975 --> 00:24:38.645 align:middle line:-2
对于某些自定义程度较高的绘图
和详情使用模式也很有用

00:24:39.146 --> 00:24:42.115 align:middle line:-1
点模式、区间模式和建模器标签

00:24:42.182 --> 00:24:43.483 align:middle line:-1
是开始自定义建模器的好方式

00:24:43.917 --> 00:24:46.286 align:middle line:-2
但这是一个很深的话题
我们在这场演讲中没有时间细讲

00:24:46.787 --> 00:24:48.322 align:middle line:-1
要获取更多关于自定义建模的信息

00:24:48.589 --> 00:24:51.158 align:middle line:-2
请参看2019年的建模和
自定义Instruments演讲

00:24:51.425 --> 00:24:53.894 align:middle line:-2
更深入地讲了具体信息
并附带示例代码

00:24:54.995 --> 00:24:57.698 align:middle line:-1
让我们继续讲分析体验的UI部分

00:24:58.131 --> 00:25:01.134 align:middle line:-1
可视化

00:25:02.402 --> 00:25:05.606 align:middle line:-1
可视化是关于你作为作者

00:25:05.973 --> 00:25:08.408 align:middle line:-2
向使用你代码的开发人员
讲述自己的故事的机会

00:25:09.209 --> 00:25:10.944 align:middle line:-1
最重要的准则是要记住

00:25:11.578 --> 00:25:14.381 align:middle line:-1
数据与故事不一样

00:25:15.148 --> 00:25:19.152 align:middle line:-2
如Kacper所展示的 通过查看
内嵌OSSignpost图表

00:25:19.686 --> 00:25:22.489 align:middle line:-2
原生区间只擅长向它们的作者
传达意义

00:25:23.290 --> 00:25:26.093 align:middle line:-1
使用你的工具的用户不会直观地了解

00:25:26.159 --> 00:25:29.363 align:middle line:-1
时间线中的某个空缺是好还是坏

00:25:29.796 --> 00:25:32.666 align:middle line:-2
或下一个处理阶段是什么
但不应该这样

00:25:33.567 --> 00:25:35.269 align:middle line:-2
作为Instruments
程序包的开发人员

00:25:35.569 --> 00:25:36.703 align:middle line:-1
你应该不只是

00:25:36.904 --> 00:25:39.473 align:middle line:-1
创建显示发生了什么的可视化信息

00:25:39.873 --> 00:25:41.408 align:middle line:-1
你要教学和诊断

00:25:41.842 --> 00:25:44.478 align:middle line:-2
你要帮助用户查找问题
即使你不在那儿

00:25:46.013 --> 00:25:48.048 align:middle line:-1
并且可视化也不只是与图表有关

00:25:48.448 --> 00:25:50.584 align:middle line:-1
有时候沟通问题的最好方式是

00:25:51.018 --> 00:25:52.886 align:middle line:-1
使用正确的统计数据集

00:25:52.953 --> 00:25:57.124 align:middle line:-2
或使用精心编写的文本叙述
准确描述出问题所在

00:25:58.725 --> 00:26:00.894 align:middle line:-1
然而图表如此重要的原因是

00:26:01.161 --> 00:26:03.497 align:middle line:-1
绝大部分情况下 图表是用户的起点

00:26:03.830 --> 00:26:05.566 align:middle line:-1
这是你的故事书的第一页

00:26:06.867 --> 00:26:09.837 align:middle line:-2
可视化应该帮助其他人学习、
了解和调试

00:26:10.137 --> 00:26:13.707 align:middle line:-2
而自私的动机是
优秀的工具也会加速分诊

00:26:14.241 --> 00:26:17.344 align:middle line:-1
这是可视化的目标 让问题变得明显

00:26:17.945 --> 00:26:20.047 align:middle line:-1
图表是你将看到的第一个汇总

00:26:20.113 --> 00:26:22.182 align:middle line:-2
它们应该把你的目光吸引到
重要的区域

00:26:22.583 --> 00:26:24.251 align:middle line:-1
一旦你开始深入了解

00:26:24.418 --> 00:26:26.153 align:middle line:-1
你的代码应该围绕

00:26:26.587 --> 00:26:29.056 align:middle line:-1
详情视图和指标那些核心概念

00:26:29.923 --> 00:26:33.193 align:middle line:-2
因为Instruments
处理两种类型的时序数据

00:26:33.260 --> 00:26:36.396 align:middle line:-2
点和区间 我想讲一下
这两者的显示方式

00:26:38.398 --> 00:26:41.568 align:middle line:-1
汇总点事件有助于评估它们的重要性

00:26:42.035 --> 00:26:43.704 align:middle line:-1
如果它们全都相对相等

00:26:43.971 --> 00:26:46.039 align:middle line:-1
那么在时间线上

00:26:46.106 --> 00:26:48.275 align:middle line:-2
显示事件密度的一个不错的方式是
通过柱形图

00:26:49.009 --> 00:26:51.378 align:middle line:-1
快速扫一眼就能立即看到较高的柱子

00:26:51.445 --> 00:26:53.013 align:middle line:-2
你就知道从哪里开始看
以及要放大哪里

00:26:53.380 --> 00:26:54.515 align:middle line:-1
对于自定义Instruments

00:26:54.581 --> 00:26:56.416 align:middle line:-1
自定义图表行为非常容易

00:26:57.017 --> 00:27:00.354 align:middle line:-2
柱形图元素可以让你指定
每个时间桶的宽度

00:27:00.954 --> 00:27:02.589 align:middle line:-1
有一个最适合分辨率元素

00:27:02.923 --> 00:27:05.192 align:middle line:-1
可以让你在用户缩小时使用柱形图

00:27:05.592 --> 00:27:08.362 align:middle line:-1
然后当用户放大时

00:27:08.428 --> 00:27:09.463 align:middle line:-1
交换单一事件的细节

00:27:11.999 --> 00:27:14.902 align:middle line:-1
当点事件的重要性发生变化时

00:27:15.202 --> 00:27:18.272 align:middle line:-2
有时候对为重大事件开辟一条道路
很有帮助

00:27:19.907 --> 00:27:23.310 align:middle line:-2
多个图表和详情视图
可以从同一个表中引用数据

00:27:23.777 --> 00:27:25.279 align:middle line:-1
从而指定最顶级的

00:27:25.579 --> 00:27:28.615 align:middle line:-2
意思就是给
Instruments描述

00:27:28.682 --> 00:27:30.384 align:middle line:-1
如何从表中选择要显示哪些值

00:27:31.084 --> 00:27:33.654 align:middle line:-2
现在这两个功能都能完全
在XML中实现

00:27:33.887 --> 00:27:35.088 align:middle line:-1
而不需要自定义建模器

00:27:37.491 --> 00:27:39.760 align:middle line:-1
表格式汇总点数据或区间数据

00:27:40.027 --> 00:27:42.763 align:middle line:-1
你可以定义哪些指标是重要指标

00:27:43.430 --> 00:27:45.132 align:middle line:-1
通过汇总的详情视图

00:27:45.199 --> 00:27:48.635 align:middle line:-1
有用于结合值的函数

00:27:49.002 --> 00:27:50.170 align:middle line:-2
如Min、Max、Average
和Standard Deviation

00:27:50.737 --> 00:27:52.940 align:middle line:-1
新用户可以查看你所提供的汇总

00:27:53.607 --> 00:27:56.009 align:middle line:-1
从而了解哪些重要

00:27:56.176 --> 00:27:57.377 align:middle line:-1
以及要对哪些进行优化

00:27:57.911 --> 00:27:59.346 align:middle line:-1
即使是显示属性也很重要

00:27:59.413 --> 00:28:01.782 align:middle line:-1
比如栏的标题是什么

00:28:01.849 --> 00:28:04.017 align:middle line:-1
或它们的显示顺序

00:28:05.819 --> 00:28:07.988 align:middle line:-1
现在当用户深入查看详情时

00:28:08.322 --> 00:28:11.959 align:middle line:-2
叙述类型是用于解释正在发生什么的
一种很棒的方式

00:28:12.526 --> 00:28:15.929 align:middle line:-2
它可以让你使用自然语言
和其它类型的格式

00:28:16.129 --> 00:28:19.132 align:middle line:-2
以一种易理解的方式解释
运行时间行为

00:28:20.000 --> 00:28:22.402 align:middle line:-1
这些视图可以很好地告诉用户

00:28:22.569 --> 00:28:24.538 align:middle line:-1
预期应该发生什么但却没有发生

00:28:25.072 --> 00:28:27.074 align:middle line:-1
或当某些有意思的事情发生时

00:28:27.140 --> 00:28:28.775 align:middle line:-1
他们可能想进一步调查

00:28:30.177 --> 00:28:32.546 align:middle line:-1
因此绘制区间数据可能有点棘手

00:28:33.680 --> 00:28:37.551 align:middle line:-1
跟点不一样 区间因为重叠的原因

00:28:37.618 --> 00:28:38.452 align:middle line:-1
并不总是位于单一垂直空间内

00:28:39.186 --> 00:28:43.223 align:middle line:-2
如果你可以规划固定的或有限制的
重复的区间的数量

00:28:43.524 --> 00:28:47.427 align:middle line:-2
有两种方式可以将一条垂直的栏
分为多个可视区域

00:28:48.295 --> 00:28:50.664 align:middle line:-1
限制绘制用于把栏分成

00:28:50.731 --> 00:28:52.499 align:middle line:-1
使用一个标题的多个空间

00:28:53.166 --> 00:28:57.037 align:middle line:-2
而实例绘制用于给每个空间
定义自己的标题

00:28:57.938 --> 00:28:59.339 align:middle line:-1
现在OSSignpost工具

00:28:59.740 --> 00:29:01.308 align:middle line:-1
结合使用这些技术

00:29:01.375 --> 00:29:03.977 align:middle line:-1
但只有当要显示的重叠区间的数量

00:29:04.044 --> 00:29:05.546 align:middle line:-1
为有限数量时才能用

00:29:06.346 --> 00:29:07.281 align:middle line:-1
当有许多等级时

00:29:08.081 --> 00:29:11.518 align:middle line:-2
你可能要采用Instruments 11
中的一个新功能

00:29:12.452 --> 00:29:15.355 align:middle line:-1
把追踪数据分离到嵌套的追踪中

00:29:15.422 --> 00:29:19.092 align:middle line:-2
使其易于过滤、查找
甚至是易于pin你正在查找的东西

00:29:19.726 --> 00:29:22.296 align:middle line:-1
特别是当图表情境的数量特别多时

00:29:23.163 --> 00:29:25.532 align:middle line:-1
但无论你是否提供追踪等级

00:29:25.599 --> 00:29:28.368 align:middle line:-1
规划汇总区间数据都很重要

00:29:28.802 --> 00:29:31.038 align:middle line:-1
要么是在每一个等级上都进行汇总

00:29:31.505 --> 00:29:33.307 align:middle line:-2
要么是作为你的
Instruments的主图表

00:29:35.542 --> 00:29:36.777 align:middle line:-1
对于简单的区间数据

00:29:36.844 --> 00:29:39.580 align:middle line:-1
可以尝试应用与点相同的方案

00:29:40.013 --> 00:29:41.315 align:middle line:-1
即使用柱形图元素

00:29:42.349 --> 00:29:44.518 align:middle line:-2
然而只有当你拥有短区间时
才能很好地发挥作用

00:29:44.585 --> 00:29:47.421 align:middle line:-1
因为柱形图元素按开始时间进行汇总

00:29:48.288 --> 00:29:51.225 align:middle line:-2
对于较长的区间
这可能会导致向左倾斜

00:29:51.658 --> 00:29:53.427 align:middle line:-1
并且它会产生非常大的值

00:29:54.795 --> 00:29:58.365 align:middle line:-2
更重要的是 当绘制拥有持续时间的
元素的图表时

00:29:58.765 --> 00:30:02.536 align:middle line:-2
请不要在Y轴绘制时间
因为X轴已经代表时间了

00:30:03.403 --> 00:30:05.506 align:middle line:-1
诸如利用率百分比这样的指标

00:30:05.572 --> 00:30:06.874 align:middle line:-1
对于显示这种数据较好

00:30:08.709 --> 00:30:10.644 align:middle line:-1
在更实际的使用中

00:30:10.711 --> 00:30:12.012 align:middle line:-1
区间总是发生更多的重叠

00:30:12.346 --> 00:30:15.782 align:middle line:-2
因此我想演示三个例子
关于汇总图表

00:30:15.949 --> 00:30:17.618 align:middle line:-1
以及在你的框架中所呈现的概念

00:30:17.684 --> 00:30:19.786 align:middle line:-1
和你想要的使用模式

00:30:20.354 --> 00:30:23.757 align:middle line:-2
如何影响你的表模式
以及如何帮助你确定呈现样式

00:30:25.459 --> 00:30:29.963 align:middle line:-2
对于某些情境
持续的重叠表明资源利用率高

00:30:30.597 --> 00:30:31.632 align:middle line:-1
对于这种数据

00:30:31.698 --> 00:30:34.101 align:middle line:-2
使用限定平均载荷
是可视化这种数据的好办法

00:30:34.701 --> 00:30:36.270 align:middle line:-1
甚至会突显某些极端值

00:30:37.304 --> 00:30:38.572 align:middle line:-1
CLIPS建模器

00:30:38.805 --> 00:30:41.241 align:middle line:-2
和Instruments
擅长维护状态注入数据

00:30:41.575 --> 00:30:44.178 align:middle line:-2
因此结合那个
OSSignpost事件流

00:30:44.244 --> 00:30:46.513 align:middle line:-1
通过来自区间计时器标签的输入

00:30:47.080 --> 00:30:48.982 align:middle line:-1
当计时器信号到达时

00:30:49.049 --> 00:30:52.052 align:middle line:-2
建模器可以计算并提交
平均限制利率用

00:30:52.920 --> 00:30:55.923 align:middle line:-1
建模器的输出表看起来可能像这样

00:30:55.989 --> 00:30:59.393 align:middle line:-2
只表达了四栏数据
并绘制了你所看到的图表

00:30:59.960 --> 00:31:03.297 align:middle line:-1
包括一个决定图表的值的利用率栏

00:31:03.830 --> 00:31:06.099 align:middle line:-1
以及决定显示颜色的严重性栏

00:31:08.335 --> 00:31:09.436 align:middle line:-1
对于其它情境

00:31:09.503 --> 00:31:11.872 align:middle line:-1
许多快速运行的区间可能更重要

00:31:11.939 --> 00:31:14.341 align:middle line:-2
因为它们可以表达
你的框架使用率低下的情况

00:31:15.242 --> 00:31:17.644 align:middle line:-1
查看与上一个示例中同样的数据

00:31:17.945 --> 00:31:21.081 align:middle line:-1
好的图表可能基于建模器计数

00:31:21.148 --> 00:31:24.251 align:middle line:-2
在特定时段内所看到的
唯一区间的数量

00:31:25.519 --> 00:31:28.355 align:middle line:-2
建模器的输出表与上一个
看起来非常类似

00:31:29.089 --> 00:31:33.460 align:middle line:-2
但用户的注意力立即就被吸引到
时间线上一个非常与众不同的区域上

00:31:33.827 --> 00:31:34.795 align:middle line:-1
有助于放大

00:31:34.862 --> 00:31:36.730 align:middle line:-1
并调查导致这些区间短的原因

00:31:38.532 --> 00:31:40.167 align:middle line:-1
前两个示例

00:31:40.367 --> 00:31:42.769 align:middle line:-1
都以10毫秒分组汇总数据

00:31:43.203 --> 00:31:46.273 align:middle line:-1
但如果某个重叠时段

00:31:46.340 --> 00:31:50.410 align:middle line:-2
对于区分一个、两个或更多并存区间
来说非常重要该怎么办呢？

00:31:51.445 --> 00:31:53.780 align:middle line:-1
嗯 我们不根据时间量化

00:31:54.214 --> 00:31:57.784 align:middle line:-1
按重叠度进行分类的图表会更有帮助

00:31:57.985 --> 00:32:01.221 align:middle line:-1
并显示具体的持续时间

00:32:03.190 --> 00:32:06.226 align:middle line:-2
建模器只追踪
OSSignpost事件

00:32:06.627 --> 00:32:09.329 align:middle line:-2
可以输出一个额外的表
包含自定义区间模式

00:32:10.397 --> 00:32:14.034 align:middle line:-2
这一次 可以通过可变的持续时间
来填写模式

00:32:14.201 --> 00:32:16.136 align:middle line:-1
还有一个描述栏作为标签使用

00:32:17.538 --> 00:32:19.640 align:middle line:-1
这三个只是示例

00:32:20.007 --> 00:32:21.475 align:middle line:-1
但它们可以帮助你了解

00:32:21.708 --> 00:32:23.777 align:middle line:-1
当呈现数据时

00:32:24.144 --> 00:32:26.813 align:middle line:-1
当你设计图标模式时 概念很重要

00:32:27.981 --> 00:32:30.551 align:middle line:-2
对于许多情况来说
自动生成的建模器

00:32:30.717 --> 00:32:32.519 align:middle line:-1
就可以满足你创建合适的体验

00:32:32.753 --> 00:32:34.021 align:middle line:-1
所需要的功能和灵活性

00:32:34.655 --> 00:32:36.190 align:middle line:-1
但一定在某些时候

00:32:36.256 --> 00:32:38.892 align:middle line:-1
你想拥有一个输入或输出

00:32:39.560 --> 00:32:42.529 align:middle line:-2
对于那些情况
在我所展示的某些示例表中

00:32:42.963 --> 00:32:46.466 align:middle line:-2
自定义建模器可以提供
额外控制和灵活性

00:32:46.867 --> 00:32:48.535 align:middle line:-1
从而可视化地表达它们的概念

00:32:49.169 --> 00:32:52.372 align:middle line:-1
或富文本的叙述、图表和详情视图

00:32:53.407 --> 00:32:55.175 align:middle line:-1
现在我要把舞台交给Kacper

00:32:55.242 --> 00:32:56.844 align:middle line:-1
看看他有什么样的可视化操作

00:33:04.852 --> 00:33:06.753 align:middle line:-1
我讲了自定义建模器

00:33:06.820 --> 00:33:09.523 align:middle line:-1
并努力改善我们现有的检查

00:33:09.957 --> 00:33:10.791 align:middle line:-1
让我们看一下

00:33:11.491 --> 00:33:14.494 align:middle line:-2
我要从我创建的那个
Solar Compression模板开始看

00:33:17.965 --> 00:33:20.934 align:middle line:-2
它现在包含一个
文件系统行动工具

00:33:21.101 --> 00:33:22.803 align:middle line:-1
当使用压缩库时

00:33:22.970 --> 00:33:26.139 align:middle line:-2
用于提供关于I/O操作的消耗的
额外信息

00:33:27.274 --> 00:33:28.108 align:middle line:-1
让我们记录一下

00:33:29.943 --> 00:33:34.982 align:middle line:-2
现在我在窗口模式中记录
从而减少记录所带来的消耗

00:33:36.550 --> 00:33:41.088 align:middle line:-2
Instrument会从主机传输
所有数据并运行建模器

00:33:45.993 --> 00:33:47.194 align:middle line:-1
现在让我们检验一下数据

00:33:48.695 --> 00:33:51.231 align:middle line:-1
我可以立即看到

00:33:51.298 --> 00:33:52.699 align:middle line:-1
在文件系统行动

00:33:53.033 --> 00:33:54.935 align:middle line:-1
和我的执行路标之间有一些相关性

00:33:56.203 --> 00:33:58.272 align:middle line:-1
我们主要看较长的zip压缩任务

00:33:58.338 --> 00:33:59.439 align:middle line:-1
我们之间曾分析过

00:34:02.543 --> 00:34:03.810 align:middle line:-1
可以很好地吸引用户的注意

00:34:04.011 --> 00:34:07.414 align:middle line:-1
但如果能使用叙述

00:34:07.681 --> 00:34:08.916 align:middle line:-1
来提供一些额外信息更好

00:34:09.949 --> 00:34:13.253 align:middle line:-2
我编写了建模器
用于检测压缩率低的情况

00:34:13.520 --> 00:34:15.289 align:middle line:-1
并呈现一些可能的方案

00:34:17.357 --> 00:34:19.126 align:middle line:-1
让我们具体看一下建议详情

00:34:19.193 --> 00:34:21.562 align:middle line:-1
看一下这个建模器的输出

00:34:25.866 --> 00:34:27.967 align:middle line:-1
这个建模器…我们得到了一个建议

00:34:28.302 --> 00:34:31.371 align:middle line:-1
建议说存档zip文件的尺寸

00:34:31.772 --> 00:34:33.841 align:middle line:-1
缩减了百分之一点多

00:34:34.308 --> 00:34:37.110 align:middle line:-1
可能没有必要压缩这个文件

00:34:38.011 --> 00:34:40.514 align:middle line:-1
它还暗示如果速度不是问题

00:34:40.781 --> 00:34:43.183 align:middle line:-1
我应该尝试使用LZMA算法

00:34:43.250 --> 00:34:45.585 align:middle line:-1
可能会提供较快的压缩速率

00:34:46.253 --> 00:34:49.322 align:middle line:-2
看起来很有用
我现在要尝试修改算法

00:34:49.857 --> 00:34:52.125 align:middle line:-1
再次记录 并重新验证结果

00:34:53.994 --> 00:34:56.530 align:middle line:-2
让我们看一下等待执行的任务
是如何进行汇总的

00:34:57.164 --> 00:35:00.033 align:middle line:-2
我计算了正在等待执行的任务的
平均载荷

00:35:00.501 --> 00:35:04.905 align:middle line:-2
这样 用户可以清晰地指出
载荷较高的区域

00:35:05.873 --> 00:35:08.976 align:middle line:-1
让我们看一下这个红色区域

00:35:10.143 --> 00:35:13.180 align:middle line:-1
看起来有许多任务正在等待执行

00:35:13.247 --> 00:35:15.449 align:middle line:-1
但随着任务在这个通道上的执行

00:35:15.716 --> 00:35:16.950 align:middle line:-1
数量正在减少

00:35:17.885 --> 00:35:20.020 align:middle line:-1
用户可以对那样的区域做出分析

00:35:20.287 --> 00:35:23.323 align:middle line:-2
如果有必要
可以增加压缩通道的数量

00:35:23.390 --> 00:35:25.125 align:middle line:-1
从而实现更高级别的并发性

00:35:26.527 --> 00:35:29.263 align:middle line:-1
实际上这个结论可以作为

00:35:29.329 --> 00:35:31.098 align:middle line:-1
对详情视图的另一个建议

00:35:32.799 --> 00:35:36.737 align:middle line:-2
现在让我们看一下它在
Instrument Inspector中表现如何

00:35:37.704 --> 00:35:41.175 align:middle line:-2
让我们搜索我们的
Solar Compression执行表

00:35:41.842 --> 00:35:43.677 align:middle line:-1
并看一下捆绑方案

00:35:45.812 --> 00:35:49.583 align:middle line:-2
OSSignpost
自动生成的建模器

00:35:49.783 --> 00:35:52.819 align:middle line:-2
把OSSignpost
点模式数据传输到

00:35:53.020 --> 00:35:55.455 align:middle line:-2
Solar Compression
执行表中

00:35:56.023 --> 00:35:58.926 align:middle line:-2
就在这里 正如我们之前所看到的
它由UI使用

00:35:59.560 --> 00:36:03.130 align:middle line:-2
我们这里还有这个新实体
即我们的建议建模器

00:36:03.597 --> 00:36:07.134 align:middle line:-1
它把压缩执行表中的区间

00:36:07.801 --> 00:36:10.838 align:middle line:-1
传输到点模式中的建议中

00:36:11.138 --> 00:36:13.440 align:middle line:-1
稍后用于驱动叙述详情

00:36:15.609 --> 00:36:19.746 align:middle line:-2
我对这个Instruments
传达我的库的概念的方式很满意

00:36:20.047 --> 00:36:22.316 align:middle line:-2
我感觉我们已经准备好
把它交给用户了

00:36:22.816 --> 00:36:24.151 align:middle line:-1
让我们返回到幻灯片中

00:36:33.227 --> 00:36:34.895 align:middle line:-1
创建优秀的分析体验

00:36:35.162 --> 00:36:37.531 align:middle line:-1
是要给用户提供一个探索路径

00:36:38.432 --> 00:36:40.400 align:middle line:-1
应该从一个有用的模板开始

00:36:40.667 --> 00:36:42.636 align:middle line:-1
这个模板用于提供

00:36:42.703 --> 00:36:43.904 align:middle line:-2
查看问题的必要的
Instruments

00:36:44.605 --> 00:36:47.407 align:middle line:-1
请记住 如果你的代码

00:36:47.474 --> 00:36:49.343 align:middle line:-1
对由其它检查所暴露的信息敏感

00:36:49.676 --> 00:36:53.380 align:middle line:-1
比如采样、系统追踪或优先级行动

00:36:53.647 --> 00:36:55.315 align:middle line:-1
你应该在你的模板中包含这些

00:36:56.316 --> 00:36:57.684 align:middle line:-1
当分析记录时

00:36:57.985 --> 00:37:00.554 align:middle line:-2
优秀的图表应该可以把用户的注意力
迅速吸引到

00:37:00.787 --> 00:37:03.457 align:middle line:-1
执行时间线中可能存在问题的地方

00:37:03.991 --> 00:37:07.094 align:middle line:-2
详情应该把他们带到
导致问题的主要原因上

00:37:07.461 --> 00:37:09.129 align:middle line:-1
并且通常还要提供有意义的暗示

00:37:10.697 --> 00:37:13.033 align:middle line:-1
为了帮助你开发更好的分析体验

00:37:13.333 --> 00:37:16.003 align:middle line:-2
今年在Instruments中
引入了两个新功能

00:37:16.336 --> 00:37:18.805 align:middle line:-1
第一个是分等级追踪的概念

00:37:19.606 --> 00:37:22.843 align:middle line:-2
其中一个例子是这里可见的
OSSignpost工具

00:37:23.076 --> 00:37:26.647 align:middle line:-1
通过等级

00:37:26.813 --> 00:37:27.748 align:middle line:-1
暴露了底层的子系统和类别名称空间

00:37:29.449 --> 00:37:31.652 align:middle line:-2
等级时自定义
Instruments的一部分

00:37:31.852 --> 00:37:35.556 align:middle line:-2
你今天看到的所有等级都可在自己
的Instrument中创建

00:37:37.558 --> 00:37:40.527 align:middle line:-2
我们还有一种自定义你的分析流程的
新方式

00:37:40.794 --> 00:37:42.696 align:middle line:-1
即通过创建自定义追踪范围

00:37:43.997 --> 00:37:46.967 align:middle line:-2
这些允许你从不同角度查看
在你的追踪文档中所收集的数据

00:37:47.267 --> 00:37:50.204 align:middle line:-1
通过应用追踪过滤器

00:37:50.571 --> 00:37:52.906 align:middle line:-2
或为每个范围选择不同的追踪分支
来实现

00:37:54.174 --> 00:37:56.476 align:middle line:-1
如果我只对查看系统调用

00:37:56.543 --> 00:37:58.412 align:middle line:-1
和压缩库的路标感兴趣

00:37:59.079 --> 00:38:02.883 align:middle line:-2
或只对分析虚拟内存对app的影响
感兴趣

00:38:03.116 --> 00:38:05.886 align:middle line:-1
我可以创建过滤掉其它追踪的范围

00:38:06.086 --> 00:38:07.521 align:middle line:-1
并一直给它们返回值

00:38:08.722 --> 00:38:10.958 align:middle line:-1
稍后我可以把它们保存在我的模板中

00:38:11.191 --> 00:38:13.694 align:middle line:-2
并与团队或Instruments
用户一起共享

00:38:15.863 --> 00:38:17.664 align:middle line:-1
检查形式的工具

00:38:17.731 --> 00:38:20.534 align:middle line:-1
会把用户与你的框架的交互体验

00:38:20.868 --> 00:38:23.804 align:middle line:-1
从良好变成优秀 从不了解变成信任

00:38:24.671 --> 00:38:28.709 align:middle line:-2
你可以通过它们来描述你框架中
所存在的概念

00:38:29.710 --> 00:38:33.013 align:middle line:-2
它们应该教育人们
并帮助他们捕捉容易犯的错误

00:38:34.047 --> 00:38:36.683 align:middle line:-1
无论何时当客户出现性能调试问题时

00:38:37.150 --> 00:38:39.152 align:middle line:-1
他们都可以返回到工具中寻找答案

00:38:39.386 --> 00:38:40.487 align:middle line:-1
这种交互

00:38:40.888 --> 00:38:43.724 align:middle line:-1
将增加他们对你的库的信心和信任

00:38:45.425 --> 00:38:49.196 align:middle line:-2
要获取更多关于自定义Instruments的
信息请访问Instruments开发人员帮助

00:38:49.930 --> 00:38:52.232 align:middle line:-1
我们还推荐你们观看这些演讲

00:38:52.799 --> 00:38:54.868 align:middle line:-2
谢谢 祝你们愉快地度过
余下的会议时光

