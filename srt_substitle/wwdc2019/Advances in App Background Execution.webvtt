WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:06.640 --> 00:00:11.512 align:middle line:0
（关于APP后台执行的改进）

00:00:13.280 --> 00:00:16.082 align:middle line:-1
我是Roberto

00:00:16.149 --> 00:00:17.017 align:middle line:-1
来自Apple的软件电量团队

00:00:17.084 --> 00:00:18.886 align:middle line:-1
今天能来到这里 我感到万分激动

00:00:19.186 --> 00:00:21.355 align:middle line:-2
我要与大家分享
关于App后台执行的改进

00:00:21.421 --> 00:00:22.890 align:middle line:-1
（关于APP后台执行的改进）

00:00:23.590 --> 00:00:25.259 align:middle line:-1
用户们喜欢用app

00:00:25.659 --> 00:00:28.896 align:middle line:-2
他们喜欢用app的原因是因为
app为他们提供许多很优秀的体验

00:00:29.596 --> 00:00:32.766 align:middle line:-2
有些是在前台
当用户积极地使用app时

00:00:33.467 --> 00:00:35.269 align:middle line:-1
而有些是在后台

00:00:35.335 --> 00:00:38.038 align:middle line:-1
要求后台执行才能实现

00:00:38.705 --> 00:00:41.408 align:middle line:0
如果我们提出可能需要后台执行的
一个列表

00:00:41.742 --> 00:00:43.343 align:middle line:0
我们可能会提出类似这样的东西

00:00:43.844 --> 00:00:47.214 align:middle line:0
比如导航或配件通讯

00:00:47.548 --> 00:00:49.550 align:middle line:0
或也许是定期更新和下载

00:00:50.117 --> 00:00:53.620 align:middle line:0
在Apple我们设计了
提供后台执行的API

00:00:53.687 --> 00:00:55.923 align:middle line:0
用于处理这些用例和提供此类体验

00:00:57.591 --> 00:01:00.060 align:middle line:-1
今天我们要讲的是后台执行

00:01:00.394 --> 00:01:01.461 align:middle line:-1
先概述一下

00:01:01.762 --> 00:01:04.096 align:middle line:-1
然后接着讲一些最佳实践

00:01:04.631 --> 00:01:06.767 align:middle line:-1
最后我同事Thomas会上台来

00:01:06.834 --> 00:01:08.869 align:middle line:-1
介绍一个新的后台任务框架

00:01:08.936 --> 00:01:11.338 align:middle line:-1
提供新的后台执行的机会

00:01:13.340 --> 00:01:15.509 align:middle line:-1
让我们先简单了解一下后台执行

00:01:15.576 --> 00:01:16.910 align:middle line:-1
（后台执行概述）

00:01:16.977 --> 00:01:20.581 align:middle line:0
我们可以先回答这个问题
什么是后台执行？

00:01:20.647 --> 00:01:21.715 align:middle line:0
我们是指什么？

00:01:21.782 --> 00:01:24.585 align:middle line:0
当我们提到后台时
我们可以指很多东西

00:01:24.651 --> 00:01:26.920 align:middle line:0
后台线程或后台队列

00:01:27.421 --> 00:01:29.156 align:middle line:0
但当我们讲后台执行时

00:01:29.223 --> 00:01:32.292 align:middle line:0
我们指的是当app不处于前台时

00:01:32.593 --> 00:01:34.161 align:middle line:0
运行我们的执行代码

00:01:35.062 --> 00:01:36.663 align:middle line:0
请看这个图表

00:01:37.030 --> 00:01:39.032 align:middle line:-1
我们指的是第三个方框

00:01:39.366 --> 00:01:41.468 align:middle line:-1
app在后台运行

00:01:41.535 --> 00:01:43.437 align:middle line:-1
但用户不一定能看到它运行

00:01:45.372 --> 00:01:47.474 align:middle line:-1
我们为什么要进入这种状态呢？

00:01:47.908 --> 00:01:49.843 align:middle line:-1
这可以归结为两种途径

00:01:50.677 --> 00:01:52.446 align:middle line:-1
第一种是app发出请求

00:01:53.080 --> 00:01:55.816 align:middle line:-1
这应用于更通用的后台执行

00:01:56.083 --> 00:01:59.953 align:middle line:-2
当app想实施一些工作时
它可以向系统发出请求

00:02:04.124 --> 00:02:05.893 align:middle line:-1
或也许是完成一些后台工作

00:02:06.960 --> 00:02:09.830 align:middle line:-1
第二种是通过特定的事件触发器

00:02:10.497 --> 00:02:13.834 align:middle line:-1
app获得后台时间

00:02:13.901 --> 00:02:16.170 align:middle line:-1
以响应某件事

00:02:16.970 --> 00:02:19.873 align:middle line:-1
比如也许用户去了国外

00:02:20.340 --> 00:02:22.075 align:middle line:-1
或也许有一些新的健康数据

00:02:22.142 --> 00:02:23.677 align:middle line:-1
App需要引起注意

00:02:25.946 --> 00:02:29.583 align:middle line:-2
当在后台运行时
我们特别在意用户体验

00:02:29.917 --> 00:02:32.019 align:middle line:-2
因此当我们设计API来支持
这些用例时

00:02:32.085 --> 00:02:34.254 align:middle line:-1
我们有许多重要因素要考虑

00:02:34.988 --> 00:02:35.989 align:middle line:-1
我想强调其中三个因素

00:02:36.056 --> 00:02:37.758 align:middle line:-1
（关于后台执行的重要因素）

00:02:37.824 --> 00:02:41.562 align:middle line:-1
电源、性能和隐私

00:02:44.031 --> 00:02:45.065 align:middle line:-1
先讲电源

00:02:45.732 --> 00:02:48.802 align:middle line:-2
无论何时当你的app在前台或后台
运行时

00:02:49.236 --> 00:02:50.470 align:middle line:-1
都需要使用电源

00:02:50.838 --> 00:02:54.074 align:middle line:-2
随时间流逝 这会消耗能量
并会消耗电池

00:02:55.475 --> 00:02:57.244 align:middle line:-2
为了可视化这种消耗
让我们看一个时间线

00:02:57.678 --> 00:03:00.280 align:middle line:-2
左侧可能是一天的开始
当太阳升起时

00:03:00.347 --> 00:03:02.149 align:middle line:-1
而右侧可能是一天的结束

00:03:02.516 --> 00:03:05.419 align:middle line:-2
也许在一天结束时用户决定
给设备充电

00:03:06.486 --> 00:03:08.789 align:middle line:-1
我们用那个绿色充电区来代表它

00:03:09.556 --> 00:03:12.326 align:middle line:-1
我们用这些浅阴影矩形

00:03:12.392 --> 00:03:13.861 align:middle line:-1
来标绘app在前台运行的时间

00:03:14.695 --> 00:03:16.797 align:middle line:-1
我们用这些深阴影矩形

00:03:16.864 --> 00:03:18.265 align:middle line:-1
来标绘app在后台运行的时间

00:03:19.233 --> 00:03:20.434 align:middle line:-1
如果运行时间越长

00:03:20.767 --> 00:03:22.402 align:middle line:-1
我们就会越消耗电量

00:03:22.970 --> 00:03:25.272 align:middle line:-2
如果我们运行时间越短
电量消耗就会越少

00:03:26.473 --> 00:03:28.475 align:middle line:-1
因此 当我们设计API时

00:03:28.542 --> 00:03:31.845 align:middle line:-2
我们主要关注为了支持特定用例
所需要的运行时间

00:03:31.912 --> 00:03:33.413 align:middle line:-1
同时保持良好的电量

00:03:33.747 --> 00:03:36.583 align:middle line:-2
当使用这些API时
考虑如何有效地使用它们

00:03:36.850 --> 00:03:40.554 align:middle line:-2
当你完成后
请通过调用完成处理器来警告系统

00:03:41.088 --> 00:03:43.290 align:middle line:-2
那样 如果系统为你的app提供了
运行时间

00:03:43.624 --> 00:03:45.726 align:middle line:-2
你可以告诉系统说
“嘿 我提前完成了”

00:03:46.026 --> 00:03:49.096 align:middle line:-2
系统可以挂起你的app
然后你就会停止消耗用户的电量

00:03:50.531 --> 00:03:52.099 align:middle line:-1
接下来是性能

00:03:52.733 --> 00:03:55.435 align:middle line:-1
我们希望系统能尽可能流畅地运行

00:03:56.136 --> 00:03:59.640 align:middle line:-2
这意味着我们希望能快速启动app
并希望UI能快速响应

00:04:03.043 --> 00:04:06.413 align:middle line:-1
原因是虽然我们可能会认为

00:04:06.480 --> 00:04:10.517 align:middle line:-1
一天之中只有一个app在运行

00:04:11.552 --> 00:04:14.688 align:middle line:0
但实际上一天中不同的时间点
有多个app在运行

00:04:14.755 --> 00:04:16.322 align:middle line:0
在前台和后台

00:04:17.658 --> 00:04:18.692 align:middle line:-1
当我们遮掩这件事时

00:04:18.759 --> 00:04:20.827 align:middle line:-2
我们可以看到我们的app可能正在
后台运行

00:04:20.894 --> 00:04:22.796 align:middle line:-1
而同时另一个app正在前台运行

00:04:23.330 --> 00:04:25.199 align:middle line:-1
或者当一个app正在前台运行时

00:04:25.265 --> 00:04:26.800 align:middle line:-1
有多个app正在后台运行

00:04:27.234 --> 00:04:28.669 align:middle line:-1
因此当我们设计API时

00:04:29.269 --> 00:04:32.339 align:middle line:-2
我们要考虑设置智能
CPU和内存限制

00:04:32.406 --> 00:04:34.541 align:middle line:-1
从而最小化对其它用途的影响

00:04:35.042 --> 00:04:36.410 align:middle line:-1
当使用这些API时

00:04:36.777 --> 00:04:38.645 align:middle line:-1
你应该注意这些限制是多少

00:04:38.712 --> 00:04:40.814 align:middle line:-1
从而不会影响用户正在积极去做的事

00:04:41.048 --> 00:04:43.617 align:middle line:-2
但更重要的是那样系统
不会终止你的app

00:04:44.084 --> 00:04:45.619 align:middle line:-1
然后当你的app以后再启动时

00:04:45.686 --> 00:04:46.820 align:middle line:-1
它的启动速度可能会变慢

00:04:48.755 --> 00:04:51.024 align:middle line:-1
最后一个重要因素是隐私

00:04:51.592 --> 00:04:55.195 align:middle line:-2
用户非常敏感
非常关心他们的私人数据

00:04:55.796 --> 00:04:58.465 align:middle line:-1
他们也许了解

00:04:58.532 --> 00:05:00.033 align:middle line:-1
app每一次在前台的运行

00:05:00.100 --> 00:05:02.970 align:middle line:-1
并期待能访问某些信息

00:05:03.537 --> 00:05:07.207 align:middle line:-2
他们可能没有意识到app每一次
在后台的运行

00:05:08.275 --> 00:05:09.776 align:middle line:-1
因此当我们设计API时

00:05:09.843 --> 00:05:12.846 align:middle line:-2
这意味着我们要使用不同的API
来适应不同的用例

00:05:13.180 --> 00:05:15.983 align:middle line:-2
每个API都要访问
自己特定的数据集

00:05:16.049 --> 00:05:17.251 align:middle line:-1
它需要支持那些数据

00:05:17.718 --> 00:05:18.919 align:middle line:-1
当使用这些API时

00:05:18.986 --> 00:05:20.888 align:middle line:-1
考虑一下对用户的透明度该有多大

00:05:21.722 --> 00:05:24.424 align:middle line:-1
并让他们了解你正在使用哪些数据

00:05:25.692 --> 00:05:27.594 align:middle line:-1
这些是关于后台执行

00:05:27.661 --> 00:05:29.396 align:middle line:-1
要考虑的三个重要因素

00:05:29.796 --> 00:05:32.099 align:middle line:-1
电源、性能和隐私

00:05:33.033 --> 00:05:34.868 align:middle line:0
当我们返回到用例列表时

00:05:35.335 --> 00:05:38.405 align:middle line:0
这些不同的用例
要转化为不同的API

00:05:39.173 --> 00:05:42.609 align:middle line:0
每个API都要有不同的要求
才能实现所预期的行为

00:05:42.910 --> 00:05:45.112 align:middle line:0
同时保持优秀的用户体验

00:05:47.281 --> 00:05:48.916 align:middle line:-1
现在我们已经有了个大概的了解

00:05:48.982 --> 00:05:52.386 align:middle line:-2
让我们深入一些最佳实践
遵循某些特定模式

00:05:52.853 --> 00:05:54.555 align:middle line:-1
了解一下API发生了哪些变更

00:05:56.390 --> 00:05:59.426 align:middle line:0
为此 让我们以一款消息app为例

00:05:59.760 --> 00:06:01.528 align:middle line:0
它可能有核心功能 比如

00:06:01.929 --> 00:06:04.531 align:middle line:0
发消息或接打电话

00:06:05.098 --> 00:06:06.967 align:middle line:0
然后它可能还有一些额外功能 比如

00:06:07.034 --> 00:06:11.572 align:middle line:0
可以让用户设置消息免打扰
或下载以前的附件

00:06:12.306 --> 00:06:14.241 align:middle line:0
现在我们要看一下这四个步骤

00:06:14.508 --> 00:06:16.977 align:middle line:0
讲一下我们要使用哪个API来实现
每个功能

00:06:18.412 --> 00:06:19.847 align:middle line:-1
第一个功能是发消息

00:06:20.681 --> 00:06:23.250 align:middle line:-1
发消息是app的核心功能

00:06:23.817 --> 00:06:25.352 align:middle line:-1
如果我给我朋友发消息

00:06:25.419 --> 00:06:28.655 align:middle line:-2
我希望它能马上送达
而不是需要一天或一周

00:06:29.823 --> 00:06:32.326 align:middle line:-1
因此用户期待这个功能可以立即完成

00:06:33.293 --> 00:06:35.963 align:middle line:-1
虽然这通常很快

00:06:36.396 --> 00:06:38.031 align:middle line:-1
但有时候情况并非如此

00:06:38.532 --> 00:06:41.535 align:middle line:-1
也许网络拥挤或也许后台服务器慢

00:06:42.035 --> 00:06:44.137 align:middle line:-2
可能需要一些额外的时间
才能发送消息

00:06:44.972 --> 00:06:46.039 align:middle line:-1
在这段额外的时间内

00:06:46.106 --> 00:06:49.209 align:middle line:-2
用户可能甚至会离开app
或放下手机并锁定它

00:06:49.910 --> 00:06:53.113 align:middle line:-2
因此我们需要一种方式来保护
这个任务的完成

00:06:53.814 --> 00:06:55.415 align:middle line:-1
我们要确定我们的消息已成功发送

00:06:55.482 --> 00:06:58.585 align:middle line:-2
从而当用户返回app时不会发生
这种情况

00:06:58.952 --> 00:07:01.088 align:middle line:-2
“嘿 为什么我的消息没有发送给
我朋友”

00:07:02.389 --> 00:07:04.892 align:middle line:-2
这个功能要使用的API是
BackgroundTaskCompletion

00:07:06.093 --> 00:07:07.694 align:middle line:-2
它会为app
提供一些额外的运行时间

00:07:08.128 --> 00:07:10.163 align:middle line:-1
在app被挂起之前在后台运行

00:07:11.031 --> 00:07:14.067 align:middle line:-2
要使用这个API你要调用
UIApplicationBeginBackgroundTask

00:07:14.134 --> 00:07:17.004 align:middle line:-2
或调用
ProcessInfoPerformExpiringActivity

00:07:17.271 --> 00:07:18.672 align:middle line:-1
如果app是在扩展中运行的话

00:07:19.006 --> 00:07:22.543 align:middle line:-2
再说一次 这是为了要完成
从前台发起的任务

00:07:22.809 --> 00:07:25.913 align:middle line:-1
其它例子可能包括把文件保存到磁盘

00:07:26.246 --> 00:07:28.782 align:middle line:-1
或完成任意用户发起的请求

00:07:29.616 --> 00:07:31.618 align:middle line:-1
让我们在代码中看一下

00:07:31.685 --> 00:07:33.153 align:middle line:-1
我们那个发消息的例子

00:07:34.354 --> 00:07:36.156 align:middle line:-1
这是发送消息函数

00:07:37.858 --> 00:07:40.394 align:middle line:-1
在函数中 当我们创建发送操作之后

00:07:40.794 --> 00:07:42.329 align:middle line:-2
我们调用
BeginBackgroundTask

00:07:42.729 --> 00:07:44.164 align:middle line:-1
这就让系统了解

00:07:44.231 --> 00:07:47.301 align:middle line:-2
“嘿 我们正在执行任务
即使用户把app放到后台

00:07:47.668 --> 00:07:49.203 align:middle line:-1
也让我们继续完成它”

00:07:51.205 --> 00:07:53.073 align:middle line:-1
然后当我们发送完成后

00:07:53.574 --> 00:07:55.042 align:middle line:-1
我们…在完成代码块中

00:07:55.108 --> 00:07:58.245 align:middle line:-1
我们会告诉系统结束后台任务

00:07:58.312 --> 00:07:59.346 align:middle line:-1
我们不再需要时间了

00:07:59.847 --> 00:08:01.682 align:middle line:-2
这是为了以下情况
当系统为我们提供了一些时间

00:08:01.748 --> 00:08:03.283 align:middle line:-2
用户把app放到后台
而我们的任务执行完成后

00:08:03.350 --> 00:08:04.985 align:middle line:-1
我们要告诉系统把app挂起来

00:08:05.285 --> 00:08:06.887 align:middle line:-1
因此我们就不再消耗用户的电量了

00:08:06.954 --> 00:08:08.622 align:middle line:-1
或不再潜在地影响他们的性能了

00:08:09.456 --> 00:08:10.624 align:middle line:-1
我还要强调最后一件事

00:08:11.158 --> 00:08:14.595 align:middle line:-2
有些情况是也许系统给了你一些
额外的时间

00:08:14.661 --> 00:08:17.364 align:middle line:-1
但情况太糟糕了 也许网络特别拥挤

00:08:17.798 --> 00:08:20.200 align:middle line:-2
我们甚至在额外的时间内也不能
完成任务

00:08:20.601 --> 00:08:22.836 align:middle line:-1
为此 我们有一个过期处理器

00:08:23.237 --> 00:08:25.839 align:middle line:-1
系统可以在这个时候调用过期处理器

00:08:26.373 --> 00:08:29.343 align:middle line:-2
在这个例子中
我们会给用户发布一条用户通知

00:08:29.409 --> 00:08:30.677 align:middle line:-1
一则本地通知

00:08:30.744 --> 00:08:33.746 align:middle line:-2
内容是“嘿 请回到app中
因为消息未发送”

00:08:35.482 --> 00:08:37.417 align:middle line:-1
那么回顾一下 当我们发送消息时

00:08:37.717 --> 00:08:41.154 align:middle line:-2
我们用BackgroundTaskCompletions
保护它的发送

00:08:42.155 --> 00:08:45.125 align:middle line:-2
我们想确保我们根据用户的动作
开始了这个任务

00:08:45.492 --> 00:08:47.461 align:middle line:-1
我们不想等到我们进入后台

00:08:47.528 --> 00:08:48.896 align:middle line:-2
才能调用
BeginBackgroundTask

00:08:49.263 --> 00:08:50.397 align:middle line:-1
因为如果我们这样做了

00:08:50.464 --> 00:08:53.333 align:middle line:-1
会限制在系统挂起app之前

00:08:53.400 --> 00:08:55.002 align:middle line:-1
我们积极尝试发送消息的时间

00:08:56.970 --> 00:08:59.039 align:middle line:-1
现在我们讲了发消息

00:08:59.239 --> 00:09:00.307 align:middle line:-1
接下来让我们讲接打电话

00:09:00.374 --> 00:09:01.708 align:middle line:-1
（接打电话）

00:09:01.775 --> 00:09:06.013 align:middle line:-1
我可能一直想给我的朋友们发消息

00:09:06.079 --> 00:09:07.881 align:middle line:-1
但有时你只想接通电话

00:09:07.948 --> 00:09:10.150 align:middle line:-1
快速接听电话

00:09:10.484 --> 00:09:12.819 align:middle line:-2
告诉他们一些事
这样你就不需要打字了

00:09:13.520 --> 00:09:17.124 align:middle line:-2
有个API能实现这个功能
即VoIPPushNotifications

00:09:17.791 --> 00:09:20.460 align:middle line:-2
这是一种特殊的推送类型
可以启动你的app

00:09:20.794 --> 00:09:21.762 align:middle line:-1
并为它提供一些运行时间

00:09:21.828 --> 00:09:24.831 align:middle line:-2
那样你可以向用户呈现
有人给他们打电话的事实

00:09:24.898 --> 00:09:26.333 align:middle line:-1
然后用户可以接电话

00:09:27.935 --> 00:09:28.936 align:middle line:-1
为了实现这个功能

00:09:29.303 --> 00:09:30.938 align:middle line:-1
你只需要在注册VoIP推送时

00:09:32.206 --> 00:09:36.310 align:middle line:-2
在PK推送注册中
设置VoIP推送类型

00:09:39.646 --> 00:09:41.114 align:middle line:-1
今年有个新改进

00:09:41.448 --> 00:09:45.152 align:middle line:-2
你必须在didReceiveIncomingPush
回调中

00:09:45.752 --> 00:09:48.589 align:middle line:-2
使用CallKit报告来电
这一点非常重要

00:09:49.223 --> 00:09:50.624 align:middle line:-1
否则你的app将被终止

00:09:51.191 --> 00:09:53.060 align:middle line:-1
并且如果你反复这样做

00:09:53.393 --> 00:09:56.129 align:middle line:-1
或如果导入来电反复失败

00:09:56.430 --> 00:09:59.533 align:middle line:-2
系统可能会完全停止启动app
进行VoIP推送

00:10:05.239 --> 00:10:08.175 align:middle line:-2
这是我们的didReceiveIncomingPush
回调

00:10:08.909 --> 00:10:12.613 align:middle line:-2
在回调内我们看到如果推送类型
是VoIP

00:10:12.679 --> 00:10:14.748 align:middle line:-1
我们将使用来自推送有效载荷的信息

00:10:14.815 --> 00:10:17.017 align:middle line:-1
来填充CX呼叫更新对象

00:10:17.451 --> 00:10:21.555 align:middle line:-1
然后使用CX提供器报告新来电

00:10:25.125 --> 00:10:27.661 align:middle line:-1
你需要确保在那个方法返回之前

00:10:27.728 --> 00:10:29.129 align:middle line:-1
报告来电

00:10:29.796 --> 00:10:32.199 align:middle line:-1
否则系统…系统将终止app的运行

00:10:33.166 --> 00:10:35.402 align:middle line:-1
还有一些其它小技巧

00:10:35.836 --> 00:10:38.872 align:middle line:-2
如果你在推送有效载荷中包含
来电信息

00:10:38.939 --> 00:10:41.375 align:middle line:-1
然后你将拥有快速呈现

00:10:41.441 --> 00:10:42.643 align:middle line:-1
那个来电UI所需要的全部信息

00:10:42.943 --> 00:10:45.078 align:middle line:-1
因此请尝试包含尽可能多的信息

00:10:45.379 --> 00:10:47.948 align:middle line:-1
从而你可以呈现尽可能丰富的UI

00:10:49.583 --> 00:10:53.153 align:middle line:-2
第二 确保你把推送的
APN过期时间

00:10:53.420 --> 00:10:55.055 align:middle line:-1
设置为零或一些很小的值

00:10:56.056 --> 00:10:58.492 align:middle line:-2
这样用户将不会在来电几分钟后
收到一个推送

00:10:58.559 --> 00:11:00.928 align:middle line:-1
而此时已经停止拨打电话了

00:11:01.862 --> 00:11:02.930 align:middle line:-1
比如说

00:11:02.996 --> 00:11:06.767 align:middle line:-2
如果某人给我打电话了
而推送花了两分钟时间来发送

00:11:07.100 --> 00:11:09.203 align:middle line:-1
然后一旦推送在两分钟之后才送达

00:11:09.269 --> 00:11:11.071 align:middle line:-1
我不想报告来电

00:11:11.371 --> 00:11:13.707 align:middle line:-2
因为那个人很可能已经不再
拨打电话了

00:11:14.174 --> 00:11:16.343 align:middle line:-1
因此如果我们把过期时间设置为零

00:11:16.410 --> 00:11:18.378 align:middle line:-1
那意味着要立即提交或提交失败

00:11:18.445 --> 00:11:20.147 align:middle line:-1
或几秒之内完成

00:11:20.447 --> 00:11:22.850 align:middle line:-2
然后我们就知道
如果设备正在接收推送

00:11:22.916 --> 00:11:24.585 align:middle line:-1
这仍然是一个相关的来电

00:11:25.986 --> 00:11:29.022 align:middle line:-1
重点是要注意如果你想发送通知

00:11:29.089 --> 00:11:32.359 align:middle line:-2
你总是可以使用标准推送
而不是全屏…

00:11:32.426 --> 00:11:34.928 align:middle line:-2
那样你就不需要在呼叫UI中
全屏呈现通知

00:11:35.295 --> 00:11:37.564 align:middle line:-1
并且你可以使用通知服务扩展

00:11:37.631 --> 00:11:39.533 align:middle line:-1
如果你需要修改推送内容的话

00:11:39.600 --> 00:11:41.268 align:middle line:-1
比如 如果你需要解密推送内容的话

00:11:42.836 --> 00:11:44.938 align:middle line:-1
那么这就是VoIP推送和接打电话

00:11:45.405 --> 00:11:47.007 align:middle line:-1
现在让我们讲一下静音线程

00:11:47.074 --> 00:11:48.275 align:middle line:-1
（静音线程）

00:11:48.675 --> 00:11:50.677 align:middle line:-1
当用户有个消息app时

00:11:50.744 --> 00:11:52.479 align:middle line:-1
他们可能会给许多不同的朋友

00:11:52.546 --> 00:11:54.047 align:middle line:-1
或许多不同的朋友群发送消息

00:11:54.248 --> 00:11:57.150 align:middle line:-1
其中有些线程可能会很繁忙

00:11:57.217 --> 00:11:59.920 align:middle line:-2
用户可能不想收到
那个特定线程的警告

00:12:03.323 --> 00:12:04.591 align:middle line:-1
内容可能仍然不错

00:12:05.158 --> 00:12:06.560 align:middle line:-1
当用户返回到app中时

00:12:06.627 --> 00:12:07.961 align:middle line:-1
他们想查看消息

00:12:08.028 --> 00:12:10.831 align:middle line:-1
他们只是不想当每次接收消息时

00:12:11.098 --> 00:12:12.332 align:middle line:-1
都要震动设备并收到通知

00:12:13.233 --> 00:12:16.570 align:middle line:-2
因此我们需要一种方式可以警告设备
而不是用户

00:12:16.937 --> 00:12:18.739 align:middle line:-1
关于有可用的新内容了

00:12:20.107 --> 00:12:22.342 align:middle line:-1
为此你应该使用后台推送

00:12:23.710 --> 00:12:26.213 align:middle line:-1
后台推送是一种机制 告诉设备

00:12:26.280 --> 00:12:29.049 align:middle line:-1
有新数据可用 而不警告用户

00:12:30.717 --> 00:12:31.652 align:middle line:-1
要使用这些

00:12:31.718 --> 00:12:34.588 align:middle line:-2
你只需要把内容可用标志设置为一
并进行推送

00:12:34.955 --> 00:12:37.157 align:middle line:-2
不需要警告 不需要声音
或不需要任何标记

00:12:37.958 --> 00:12:39.893 align:middle line:-1
然后系统将决定

00:12:39.960 --> 00:12:41.929 align:middle line:-1
何时启动app下载内容

00:12:42.596 --> 00:12:46.099 align:middle line:-2
根据电量和性能影响
并尝试将影响最小化

00:12:46.633 --> 00:12:48.168 align:middle line:-1
我们可以在时间线上看一下这个过程

00:12:48.635 --> 00:12:49.770 align:middle line:-1
看起来类似这样

00:12:50.771 --> 00:12:52.239 align:middle line:-1
用户可能正在使用app

00:12:52.506 --> 00:12:54.174 align:middle line:-1
并决定静音某个线程

00:12:54.708 --> 00:12:56.610 align:middle line:0
然后在将来的某个时间点

00:12:56.677 --> 00:12:58.278 align:middle line:0
某人可能在那个线程上发了消息

00:12:58.345 --> 00:13:00.314 align:middle line:0
设备将收到后台推送

00:13:01.548 --> 00:13:03.750 align:middle line:0
在此之后的某个时间app将被启动

00:13:04.017 --> 00:13:05.919 align:middle line:0
并获得一些运行时间来取回那个内容

00:13:07.020 --> 00:13:09.923 align:middle line:0
然后当用户稍后返回到app中时

00:13:10.290 --> 00:13:12.559 align:middle line:0
打开app 用户可以打开线程

00:13:12.626 --> 00:13:14.428 align:middle line:0
并看到已经收到内容了

00:13:14.962 --> 00:13:17.865 align:middle line:-2
对于后台推送也有一些非常重要的
新改进

00:13:17.931 --> 00:13:19.132 align:middle line:-1
（后台推送）

00:13:19.199 --> 00:13:23.837 align:middle line:-2
你必须把APN优先级设置为五
否则app将不能启动

00:13:25.405 --> 00:13:28.509 align:middle line:-2
并且你还应该把APNS推送类型
设置为后台

00:13:28.842 --> 00:13:30.544 align:middle line:-1
这是watchOS所必需的

00:13:30.911 --> 00:13:33.480 align:middle line:-2
但我们强烈建议在所有平台上
都这样做

00:13:34.214 --> 00:13:36.817 align:middle line:-2
如果你想获得关于在
watchOS上的推送的更多信息

00:13:37.251 --> 00:13:40.287 align:middle line:-2
昨天有场单独的Watch app
演讲 你可以参考一下

00:13:42.656 --> 00:13:44.591 align:middle line:-1
回顾一下 对于静音线程

00:13:45.325 --> 00:13:48.328 align:middle line:-2
使用后台推送
作为下载内容的最佳方式

00:13:48.729 --> 00:13:52.366 align:middle line:-1
如果app没有获得运行时间

00:13:52.432 --> 00:13:54.401 align:middle line:-1
在收到后台推送后

00:13:54.668 --> 00:13:58.138 align:middle line:-2
你总是可以在app重新进入前台时
下载那些内容

00:14:04.845 --> 00:14:06.413 align:middle line:-1
假如用户登录了他们的账户

00:14:07.347 --> 00:14:09.149 align:middle line:-1
他们在一台新设备上登录了

00:14:09.783 --> 00:14:12.753 align:middle line:-2
他们可能想立即从账户中
获取某些内容

00:14:12.819 --> 00:14:15.389 align:middle line:-1
比如对话列表或某些最近的消息

00:14:16.723 --> 00:14:18.859 align:middle line:-1
但可能有一批比较老的内容

00:14:18.926 --> 00:14:21.061 align:middle line:-2
如果你不在用户进入app时
就立即下载它

00:14:21.328 --> 00:14:22.596 align:middle line:-1
那非常好

00:14:23.697 --> 00:14:24.765 align:middle line:-1
想象一下

00:14:25.132 --> 00:14:28.869 align:middle line:-2
如果我们可以在设备充电时和闲置时
下载的话

00:14:28.936 --> 00:14:30.637 align:middle line:-2
我们为什么要在用户处于前台时
下载呢

00:14:31.205 --> 00:14:34.508 align:middle line:-2
那可能会潜在地
影响他们的性能或电量

00:14:35.943 --> 00:14:39.179 align:middle line:-2
实现方式是使用
任意后台URL会话

00:14:40.147 --> 00:14:43.483 align:middle line:-2
这可以让系统推迟下载
直到出现一个更好的下载时间

00:14:44.184 --> 00:14:47.588 align:middle line:-1
这个API可以让你传递更多信息

00:14:47.955 --> 00:14:49.690 align:middle line:-1
从而它可以更智能地安排时间

00:14:50.490 --> 00:14:51.491 align:middle line:-1
要使用它

00:14:51.792 --> 00:14:54.561 align:middle line:-2
你需要像往常那样
设置后台URL会话

00:14:55.295 --> 00:14:57.798 align:middle line:-1
然后把任意标志设为真

00:14:59.666 --> 00:15:01.735 align:middle line:-2
让我们看一下你可以传入的一些
额外信息

00:15:01.802 --> 00:15:04.271 align:middle line:-1
从而使系统变得更智能

00:15:05.606 --> 00:15:07.274 align:middle line:-1
你可以传入超时间隔

00:15:07.608 --> 00:15:10.277 align:middle line:-1
也许你不希望系统一直尝试下载

00:15:10.344 --> 00:15:11.745 align:middle line:-2
因此你希望可以界定系统可以下载
多长时间

00:15:13.280 --> 00:15:15.082 align:middle line:-1
你可以传入一个最早开始时间

00:15:15.415 --> 00:15:17.251 align:middle line:-1
也许你不想执行上传或下载

00:15:17.317 --> 00:15:18.719 align:middle line:-1
直到将来的某个时间点

00:15:19.353 --> 00:15:22.256 align:middle line:-1
并且你可以传入所预期的工作量大小

00:15:22.523 --> 00:15:26.393 align:middle line:-1
从而系统了解当运行下载时

00:15:26.460 --> 00:15:27.561 align:middle line:-1
有多少工作要做

00:15:30.430 --> 00:15:32.566 align:middle line:-1
当你正在下载以前的附件时

00:15:32.833 --> 00:15:36.370 align:middle line:-2
如果可能的话 你希望推迟这个操作
从而最小化对用户可见的影响

00:15:36.837 --> 00:15:40.707 align:middle line:-2
我们可以对任意可推迟的下载或上传
实施同样的原则

00:15:41.141 --> 00:15:43.644 align:middle line:-1
也许你有一些分析

00:15:43.710 --> 00:15:44.912 align:middle line:-1
你想在一个更合适的时间批量上传

00:15:45.179 --> 00:15:46.813 align:middle line:-1
或也许有一些用户拍摄的照片

00:15:47.080 --> 00:15:48.282 align:middle line:-1
你想稍后再进行备份

00:15:49.850 --> 00:15:51.952 align:middle line:0
回顾一下 我们有一款消息app

00:15:52.019 --> 00:15:53.687 align:middle line:0
它有一些核心功能

00:15:54.054 --> 00:15:56.089 align:middle line:0
你可以发消息、接打电话

00:15:56.757 --> 00:15:59.393 align:middle line:0
允许用户设置消息免打扰
并且你还可以下载以前的附件

00:16:03.030 --> 00:16:04.598 align:middle line:-2
我们使用
BackgroundTaskCompletion

00:16:04.865 --> 00:16:07.401 align:middle line:0
保障即使用户离开app
消息也能发送出去

00:16:07.868 --> 00:16:10.204 align:middle line:0
我们使用VoIP推送
作为启用接打电话的方式

00:16:10.704 --> 00:16:13.507 align:middle line:-1
我们使用后台推送

00:16:13.574 --> 00:16:16.443 align:middle line:0
作为给app提供运行时间
以响应新内容的最佳方式

00:16:16.777 --> 00:16:20.380 align:middle line:0
并且我们使用任意URL会话
在合适的时间下载附件

00:16:21.682 --> 00:16:23.317 align:middle line:0
但还有许多其它用例

00:16:23.383 --> 00:16:25.519 align:middle line:0
我们现有的模式目前还没有覆盖到

00:16:25.819 --> 00:16:27.421 align:middle line:-2
因此我想邀请我同事
Thomas上台来

00:16:27.487 --> 00:16:30.023 align:middle line:-1
介绍一种新的后台模式和框架

00:16:30.090 --> 00:16:31.758 align:middle line:-1
是特别针对这些用例设计的

00:16:32.092 --> 00:16:32.926 align:middle line:-1
谢谢大家

00:16:35.229 --> 00:16:36.063 align:middle line:-1
谢谢Roberto

00:16:36.830 --> 00:16:38.465 align:middle line:-1
让我们讲一下这些用例

00:16:38.532 --> 00:16:39.733 align:middle line:-1
（新的后台任务框架）

00:16:39.800 --> 00:16:43.170 align:middle line:-1
这些是比如主动与服务器同步状态

00:16:43.637 --> 00:16:44.972 align:middle line:-1
清理数据库

00:16:45.305 --> 00:16:46.773 align:middle line:-1
或把数据备份到Cloud

00:16:47.274 --> 00:16:49.776 align:middle line:-1
这些是可推迟的维护型任务

00:16:50.177 --> 00:16:52.513 align:middle line:-1
你最好在后台执行

00:16:52.779 --> 00:16:55.549 align:middle line:-1
从而不影响前台用户活动

00:16:56.416 --> 00:16:57.618 align:middle line:-1
如今我们看到的是

00:16:57.684 --> 00:17:01.288 align:middle line:-2
app在进入后台后就立即执行
这种任务

00:17:01.655 --> 00:17:03.423 align:middle line:-1
在一整天之中

00:17:03.757 --> 00:17:05.092 align:middle line:-1
这些任务其实可以累计起来一起执行

00:17:06.326 --> 00:17:08.462 align:middle line:-2
如果你可以把全部那种任务都推迟到
稍后执行怎么样

00:17:08.795 --> 00:17:11.999 align:middle line:-1
也许是当设备充电时或闲置时？

00:17:13.032 --> 00:17:15.135 align:middle line:-1
这就是我们今年引入的新功能

00:17:15.202 --> 00:17:18.505 align:middle line:-2
一个全新的后台模式和与之匹配的
一个框架

00:17:18.571 --> 00:17:20.040 align:middle line:-1
我们叫做后台任务

00:17:20.773 --> 00:17:21.775 align:middle line:-1
后台任务

00:17:21.842 --> 00:17:25.045 align:middle line:-1
可以让你稍后在后台执行任务

00:17:26.413 --> 00:17:29.550 align:middle line:-1
它在iOS、iPadOS、

00:17:30.017 --> 00:17:32.819 align:middle line:-2
tvOS上可用 对Mac上的
iPad app也可用

00:17:34.054 --> 00:17:37.124 align:middle line:0
我们不仅引入了这个新后台模式

00:17:37.191 --> 00:17:38.892 align:middle line:0
我们调用后台处理任务

00:17:39.560 --> 00:17:43.063 align:middle line:0
我们还利用这个机会
改善了现有API

00:17:43.330 --> 00:17:44.831 align:middle line:0
在后台刷新app的功能

00:17:46.733 --> 00:17:48.669 align:middle line:-1
先讲一下新后台模式

00:17:49.369 --> 00:17:50.737 align:middle line:-1
后台处理任务

00:17:51.104 --> 00:17:54.575 align:middle line:-2
可以在系统友好时间为你的app
提供几分钟的运行时间

00:17:55.242 --> 00:17:58.278 align:middle line:-1
从而你可以执行我之前提到的

00:17:58.345 --> 00:18:01.215 align:middle line:-1
可推迟的维护级任务以及新任务

00:18:01.481 --> 00:18:02.850 align:middle line:-1
比如设备上、

00:18:02.916 --> 00:18:05.519 align:middle line:-1
Core ML、在后台训练和推断

00:18:05.586 --> 00:18:07.254 align:middle line:-2
你可以从它们各自的演讲中
了解更多内容

00:18:07.321 --> 00:18:08.589 align:middle line:-1
（后台处理任务）

00:18:09.356 --> 00:18:11.391 align:middle line:-1
CPU监控是系统的一个功能

00:18:11.725 --> 00:18:15.062 align:middle line:-2
自动终止在后台使用了太多
CPU循环的app

00:18:15.128 --> 00:18:18.398 align:middle line:-1
以保护用户的电量

00:18:19.132 --> 00:18:20.434 align:middle line:-1
有史以来我们首次

00:18:20.501 --> 00:18:22.903 align:middle line:-1
可以让你在任务处理过程中

00:18:22.970 --> 00:18:24.838 align:middle line:-1
关闭CPU监控

00:18:25.138 --> 00:18:27.274 align:middle line:-1
从而你可以在设备充电时

00:18:27.341 --> 00:18:28.876 align:middle line:-1
充分利用硬件

00:18:30.677 --> 00:18:33.247 align:middle line:-1
最后我们会确保你有资格

00:18:33.313 --> 00:18:36.149 align:middle line:-1
运行这些任务

00:18:36.216 --> 00:18:37.651 align:middle line:-2
只要你在app处于前台时
请求执行这些任务

00:18:37.718 --> 00:18:40.521 align:middle line:-2
或如果你的app最近在前台使用过
也可以

00:18:42.189 --> 00:18:43.390 align:middle line:-1
（后台APP刷新任务）

00:18:43.457 --> 00:18:47.628 align:middle line:-2
接下来我要讲用于后台app刷新的
新API

00:18:48.762 --> 00:18:50.063 align:middle line:-1
这是个新API

00:18:50.130 --> 00:18:52.566 align:middle line:-1
但它的政策与当前API一模一样

00:18:53.000 --> 00:18:56.770 align:middle line:-2
这意味着app每次启动时将获得
30秒的运行时间

00:18:57.104 --> 00:19:00.307 align:middle line:-2
用于获取新内容并在一天内保持
一直有最新内容

00:19:02.409 --> 00:19:05.279 align:middle line:-1
app的启动频率以及何时启动

00:19:05.345 --> 00:19:07.881 align:middle line:-1
取决于用户在过于使用app的方式

00:19:09.016 --> 00:19:12.452 align:middle line:-1
因此如果用户一般在早上、

00:19:12.753 --> 00:19:14.555 align:middle line:-1
下午和晚上使用你的app

00:19:15.022 --> 00:19:17.724 align:middle line:-2
系统将会了解这种模式
并在这些时间之前不久

00:19:17.791 --> 00:19:19.259 align:middle line:-1
启动你的app

00:19:19.326 --> 00:19:21.929 align:middle line:-1
因此你就有机会获得你所需要的内容

00:19:23.030 --> 00:19:26.233 align:middle line:-2
这也意味着
如果app的使用频率不高

00:19:26.300 --> 00:19:27.935 align:middle line:-1
启动频率可能也不高

00:19:30.137 --> 00:19:33.674 align:middle line:-2
正如我所提到过的
这是用于后台app刷新的新API

00:19:33.740 --> 00:19:37.211 align:middle line:0
因此我们不推荐使用你在这里看到的
UI Application中的现有API

00:19:38.212 --> 00:19:40.013 align:middle line:0
但这些API可以继续使用

00:19:40.080 --> 00:19:44.952 align:middle line:0
它们在iOS、iPadOS
和tvOS设备上的使用方式不变

00:19:45.385 --> 00:19:46.987 align:middle line:0
但Mac上不支持它们

00:19:47.054 --> 00:19:49.223 align:middle line:0
因此一定要采用后台任务

00:19:49.289 --> 00:19:50.958 align:middle line:0
在Mac上执行后台app刷新

00:19:53.760 --> 00:19:55.729 align:middle line:-1
让我们看看这个API是如何运作的

00:19:56.930 --> 00:20:00.267 align:middle line:-2
假如我们有一款app
它包含一些扩展

00:20:01.635 --> 00:20:03.937 align:middle line:-1
你将与之交互的原始对象是

00:20:04.304 --> 00:20:06.139 align:middle line:-1
后台任务调度程序

00:20:07.508 --> 00:20:09.076 align:middle line:-1
后台任务调度程序

00:20:09.142 --> 00:20:13.680 align:middle line:-2
是系统智能的、
动态的活动调度程序的界面

00:20:13.981 --> 00:20:16.617 align:middle line:-1
它持续监控各种系统情况

00:20:17.050 --> 00:20:21.455 align:middle line:-2
包括电量等级、app的使用、
网络的连通性等等

00:20:23.323 --> 00:20:24.758 align:middle line:-1
当app正在运行时

00:20:24.825 --> 00:20:28.061 align:middle line:-2
你可以请求它稍后在后台唤醒它
并执行任务

00:20:28.829 --> 00:20:33.267 align:middle line:-2
为此 你要创建一个后台任务
请求对象的实例

00:20:34.334 --> 00:20:36.970 align:middle line:-1
响应你要实施的任务的类型

00:20:37.437 --> 00:20:40.440 align:middle line:-2
在这个例子中
我们想执行后台app刷新

00:20:40.707 --> 00:20:43.377 align:middle line:-2
因此我发起了一个
后台app刷新任务请求

00:20:44.378 --> 00:20:45.746 align:middle line:-1
我们把它提交给调度程序

00:20:47.447 --> 00:20:49.750 align:middle line:-1
如果你想执行多种类型的任务

00:20:49.816 --> 00:20:51.351 align:middle line:-1
你可以提交多个请求

00:20:51.718 --> 00:20:54.188 align:middle line:-2
在这个例子中
我们还想执行一些数据库清理

00:20:54.488 --> 00:20:58.358 align:middle line:-2
因此我也要发起一个
后台处理任务请求并提交它

00:21:05.165 --> 00:21:08.302 align:middle line:-1
因此如果你的键盘扩展

00:21:08.368 --> 00:21:09.736 align:middle line:-1
想根据用户的键入习惯进行学习

00:21:10.070 --> 00:21:13.240 align:middle line:-2
它也可以创建一个后台处理任务请求
并提交它

00:21:14.174 --> 00:21:15.175 align:middle line:-1
你可以看到

00:21:15.242 --> 00:21:18.345 align:middle line:-2
你有多个等待处理的
后台处理任务请求

00:21:18.879 --> 00:21:22.783 align:middle line:-2
每个都代表你希望app执行的
特定任务

00:21:24.418 --> 00:21:27.387 align:middle line:-2
现在调度程序知道我们的app
要做的全部任务

00:21:28.722 --> 00:21:30.991 align:middle line:-1
当满足所有必要的系统条件

00:21:31.058 --> 00:21:32.492 align:middle line:-1
和政策时

00:21:33.060 --> 00:21:34.528 align:middle line:-1
它将执行那个任务

00:21:34.962 --> 00:21:37.598 align:middle line:-1
唤醒你的app并在后台启动它

00:21:38.498 --> 00:21:40.968 align:middle line:-1
给它提交一个

00:21:41.034 --> 00:21:43.036 align:middle line:-2
响应你应该实施的那个任务的
后台任务对象

00:21:43.770 --> 00:21:46.273 align:middle line:-2
在这个例子中
我们有后台app刷新任务

00:21:46.640 --> 00:21:50.577 align:middle line:-2
因此我们现在可以实施
后台app刷新获取内容

00:21:50.644 --> 00:21:51.645 align:middle line:-1
并更新我们的UI

00:21:52.880 --> 00:21:55.582 align:middle line:-2
当我们完成后 我们要调用
SetTaskCompleted

00:21:55.949 --> 00:21:59.319 align:middle line:-1
它会把任务标记为完成并挂起app

00:22:04.024 --> 00:22:05.926 align:middle line:-1
以及各种系统情况和政策

00:22:06.627 --> 00:22:10.130 align:middle line:-2
我们可能选择同时启动app执行
多个任务

00:22:11.031 --> 00:22:14.401 align:middle line:-2
在这个例子中
系统启动了我们的app

00:22:14.701 --> 00:22:17.171 align:middle line:-2
系统向app同时提交了之前请求的
两个后台处理任务

00:22:18.572 --> 00:22:19.540 align:middle line:-1
当app启动时

00:22:19.606 --> 00:22:22.609 align:middle line:-2
系统就为它提供一段有限的时间
来完成分配给它的任务

00:22:23.010 --> 00:22:26.113 align:middle line:-2
那个时间是按启动来分配的
而不是按任务分配

00:22:26.513 --> 00:22:30.317 align:middle line:-2
因此你应该准备好
在分配给你的时间内

00:22:30.584 --> 00:22:31.518 align:middle line:-1
同时地处理分配给你的全部任务

00:22:32.252 --> 00:22:36.590 align:middle line:-2
同时请注意键盘扩展发起的
处理任务请求

00:22:36.890 --> 00:22:38.392 align:middle line:-1
会提交到主app中

00:22:38.926 --> 00:22:42.329 align:middle line:-1
那是因为始终是启动主app

00:22:42.396 --> 00:22:45.532 align:middle line:-1
来处理后台任务 而不是启动扩展

00:22:47.935 --> 00:22:49.970 align:middle line:-1
当app完成执行必要的任务之后

00:22:50.037 --> 00:22:53.273 align:middle line:-2
在系统分配给它的全部后台任务
对象上调用SetTaskCompleted

00:22:53.774 --> 00:22:54.675 align:middle line:-1
然后就会挂起app

00:22:55.409 --> 00:22:58.779 align:middle line:-2
这就是关于如何使用
后台任务API的高级概述

00:22:59.379 --> 00:23:01.849 align:middle line:-1
你创建后台任务请求

00:23:02.182 --> 00:23:03.517 align:middle line:-1
并提交给后台任务调度程序

00:23:04.051 --> 00:23:06.453 align:middle line:-1
等待系统在后台启动你的app

00:23:06.920 --> 00:23:08.255 align:middle line:-1
执行必要的任务

00:23:08.522 --> 00:23:11.859 align:middle line:-2
然后在BG任务对象上调用
SetTaskCompleted

00:23:12.926 --> 00:23:15.462 align:middle line:-2
为了让你了解如何在你的app中
实施这个API

00:23:15.729 --> 00:23:17.030 align:middle line:-1
我要给你做一个演示

00:23:24.771 --> 00:23:25.873 align:middle line:-1
这是我们的app

00:23:25.939 --> 00:23:29.009 align:middle line:-2
它叫做Color Feed
是款典型的社交媒体类型的app

00:23:29.343 --> 00:23:31.845 align:middle line:-1
除了照片信息

00:23:31.912 --> 00:23:33.814 align:middle line:-1
你还可以获得最近流行颜色的信息

00:23:34.448 --> 00:23:36.116 align:middle line:-1
你可以看到

00:23:36.183 --> 00:23:38.819 align:middle line:-1
我可以滚动并查看

00:23:39.086 --> 00:23:40.320 align:middle line:-1
不同的时间点的最新颜色

00:23:41.421 --> 00:23:42.689 align:middle line:-1
我其实想做的是

00:23:42.956 --> 00:23:45.259 align:middle line:-2
确保我的app在一天的时间里
可以保持拥有最新消息

00:23:45.325 --> 00:23:47.060 align:middle line:-1
并进行自我刷新

00:23:47.127 --> 00:23:49.196 align:middle line:-1
而不需要用户进入app并手动操作

00:23:49.830 --> 00:23:52.466 align:middle line:-2
处理这个问题最完美的工具是
后台app刷新

00:23:52.533 --> 00:23:54.401 align:middle line:-1
我要通过后台任务实施这个操作

00:23:55.903 --> 00:23:57.437 align:middle line:-1
你要做的第一件事就是

00:23:57.804 --> 00:24:00.741 align:middle line:-2
向info.plist中
添加所需要的键

00:24:00.807 --> 00:24:02.843 align:middle line:-1
声明你对后台任务

00:24:03.243 --> 00:24:04.311 align:middle line:-1
和后台app刷新的支持

00:24:04.978 --> 00:24:07.748 align:middle line:-1
因此我要进入我的项目设置

00:24:09.783 --> 00:24:11.351 align:middle line:-1
点击我app的目标

00:24:13.020 --> 00:24:15.122 align:middle line:-1
并进入“签名和功能”选项卡

00:24:16.990 --> 00:24:19.393 align:middle line:-1
我要点击加号并为后台模式

00:24:20.327 --> 00:24:21.361 align:middle line:-1
添加新功能

00:24:23.964 --> 00:24:26.099 align:middle line:-1
你可以看到 它增加了这个新的部分

00:24:26.166 --> 00:24:29.069 align:middle line:-2
我们需要给这种类型的任务
选择合适的后台模式

00:24:29.603 --> 00:24:31.338 align:middle line:-1
在这个例子中 对于后台app刷新

00:24:31.672 --> 00:24:34.675 align:middle line:-2
该框标记为后台提取
就与在老API中一样

00:24:34.942 --> 00:24:36.210 align:middle line:-1
因此我要继续并查看一下

00:24:38.045 --> 00:24:40.914 align:middle line:-2
接下来我要进入我的
请求info.plist文件

00:24:41.348 --> 00:24:42.316 align:middle line:-1
就在这里…

00:24:43.884 --> 00:24:46.854 align:middle line:-1
我要点击加号并添加一个新键

00:24:48.789 --> 00:24:52.392 align:middle line:-2
这个键叫做PermittedBackground
TaskSchedulerIdentifiers

00:24:52.993 --> 00:24:54.795 align:middle line:-1
它是一个字符串的数组

00:24:55.462 --> 00:24:57.397 align:middle line:-1
这个数组中的每个字符串

00:24:57.464 --> 00:25:00.634 align:middle line:-2
都唯一标识你的app要执行的
某个特定的任务

00:25:01.034 --> 00:25:02.803 align:middle line:-1
并且它在你的app内应该是唯一的

00:25:03.270 --> 00:25:05.472 align:middle line:-1
我们推荐使用反向DNS表示法

00:25:05.539 --> 00:25:08.308 align:middle line:-2
避免与你可能使用的任何第三方框架
发生冲突

00:25:09.977 --> 00:25:12.279 align:middle line:-1
在这里我要扩展那个数组

00:25:12.346 --> 00:25:14.114 align:middle line:-1
并点击加号来添加新字符串

00:25:15.282 --> 00:25:18.752 align:middle line:-2
我要把它命名为
com.colorfeed.refresh

00:25:20.554 --> 00:25:21.555 align:middle line:-1
并点击保存

00:25:22.389 --> 00:25:24.825 align:middle line:-1
接下来当我的app启动时

00:25:25.092 --> 00:25:26.493 align:middle line:-1
我需要实际实施要处理的代码

00:25:26.960 --> 00:25:28.662 align:middle line:-1
我要在app委托中实现

00:25:31.732 --> 00:25:33.333 align:middle line:-1
我要进入app委托文件

00:25:33.400 --> 00:25:35.702 align:middle line:-1
我要做的第一件事是导入后台任务

00:25:39.673 --> 00:25:40.507 align:middle line:-1
好吧

00:25:41.175 --> 00:25:42.409 align:middle line:-1
下一步

00:25:42.876 --> 00:25:45.479 align:middle line:-1
就是告诉系统当你启动时你想做什么

00:25:45.546 --> 00:25:48.415 align:middle line:-1
你可以通过在app完成启动之前

00:25:48.482 --> 00:25:50.417 align:middle line:-1
就注册启动处理器来实现

00:25:51.285 --> 00:25:54.788 align:middle line:-2
didFinishLaunching
和Options方法

00:25:55.556 --> 00:25:56.657 align:middle line:-1
我要调用…

00:25:58.892 --> 00:26:01.061 align:middle line:-1
共享后台任务调度程序

00:26:01.128 --> 00:26:03.130 align:middle line:-1
用标识符注册任务

00:26:03.530 --> 00:26:07.434 align:middle line:-2
传入我刚放在info.plist
中的同一个标识符

00:26:08.702 --> 00:26:10.771 align:middle line:-1
下一个参数是一个分派队列

00:26:10.838 --> 00:26:12.873 align:middle line:-1
我的处理器将调用分派队列

00:26:12.940 --> 00:26:14.775 align:middle line:-2
并且如果我想在app中
同步执行其它任务

00:26:14.842 --> 00:26:16.810 align:middle line:-1
我可以指定我要使用的队列

00:26:17.411 --> 00:26:19.012 align:middle line:-1
或我可以传入无

00:26:19.079 --> 00:26:21.949 align:middle line:-1
系统将替我创建一个后台串行队列

00:26:23.483 --> 00:26:24.585 align:middle line:-1
下一个参数是

00:26:24.651 --> 00:26:25.986 align:middle line:-1
启动处理器

00:26:26.053 --> 00:26:28.755 align:middle line:-2
当在后台启动app执行后台任务时
调用它

00:26:29.523 --> 00:26:30.390 align:middle line:-1
你可以看到

00:26:30.457 --> 00:26:32.693 align:middle line:-1
它接受后台任务的一个参数

00:26:34.094 --> 00:26:35.195 align:middle line:-1
我要做的是

00:26:35.629 --> 00:26:40.767 align:middle line:-2
调用一个方法…我要编写一个名为
HandleAppRefresh的方法

00:26:41.068 --> 00:26:45.506 align:middle line:-2
把那个后台任务对象向下转换为
后台app刷新任务

00:26:45.839 --> 00:26:47.708 align:middle line:-1
因为这是用于后台app刷新的参数

00:26:48.842 --> 00:26:51.345 align:middle line:-2
现在我要继续并编写那个
HandleAppRefresh方法

00:26:55.015 --> 00:26:56.850 align:middle line:-2
我在这里编写了
用于实施后台app刷新

00:26:56.917 --> 00:26:58.986 align:middle line:-1
所需要的全部代码

00:26:59.286 --> 00:27:01.722 align:middle line:-1
它将从服务器获取最新内容

00:27:01.788 --> 00:27:03.991 align:middle line:-1
更新数据库并更新UI

00:27:04.658 --> 00:27:06.660 align:middle line:-1
为了把这个与后台任务集成到一起

00:27:07.127 --> 00:27:08.896 align:middle line:-1
我需要做两件事

00:27:09.663 --> 00:27:11.832 align:middle line:-1
第一件是处理过期

00:27:12.566 --> 00:27:15.969 align:middle line:-2
系统为你的任务分配了有限的
完成时间

00:27:16.570 --> 00:27:18.805 align:middle line:-1
当你的时间差不多要用完时

00:27:18.872 --> 00:27:21.475 align:middle line:-1
我们会警告你并给你提供一个机会

00:27:21.542 --> 00:27:22.676 align:middle line:-1
让你快速完成全部工作

00:27:23.010 --> 00:27:26.480 align:middle line:-1
系统可能还选择提早终止你的任务

00:27:26.747 --> 00:27:29.950 align:middle line:-1
如果系统决定当前情况

00:27:30.017 --> 00:27:31.084 align:middle line:-1
不足以运行你的任务的话

00:27:32.186 --> 00:27:35.289 align:middle line:-2
我要做的就是在任务上设置一个
过期处理器…

00:27:36.690 --> 00:27:39.126 align:middle line:-1
在过期处理器中

00:27:39.693 --> 00:27:42.596 align:middle line:-2
我要在我的操作队列上调用
CancelAllOperations

00:27:42.663 --> 00:27:44.965 align:middle line:-1
这会停止我正在做的全部工作

00:27:45.032 --> 00:27:47.000 align:middle line:-1
并取消我甚至还没开始的任何工作

00:27:48.569 --> 00:27:49.903 align:middle line:-1
我要做的下一件事是

00:27:50.404 --> 00:27:55.008 align:middle line:-2
完成之后在任务上调用
SetTaskCompleted

00:27:56.410 --> 00:27:59.580 align:middle line:-2
即使在系统调用过期处理器之后
我也需要调用SetTaskCompleted

00:28:02.883 --> 00:28:04.651 align:middle line:-1
系统实际上可能会终止我的app

00:28:05.052 --> 00:28:07.020 align:middle line:-1
那会影响稍后的启动性能

00:28:07.087 --> 00:28:08.188 align:middle line:-1
你绝对不想那样做

00:28:08.722 --> 00:28:10.858 align:middle line:-1
我要做的是

00:28:10.924 --> 00:28:12.059 align:middle line:-1
我要…

00:28:13.227 --> 00:28:16.964 align:middle line:-2
在那个队列中的最后一个操作
完成之后

00:28:17.397 --> 00:28:18.966 align:middle line:-2
调用
SetTaskCompleted

00:28:19.333 --> 00:28:20.868 align:middle line:-1
我要充分利用这一点

00:28:21.101 --> 00:28:23.203 align:middle line:-1
即操作总是会调用它们的完成代码块

00:28:23.537 --> 00:28:26.373 align:middle line:-1
无论操作是被提早取消或是正常完成

00:28:26.640 --> 00:28:29.910 align:middle line:-2
并且我通过这一点来决定
我的任务是否成功完成

00:28:31.144 --> 00:28:32.913 align:middle line:-1
好吧 最后一步…

00:28:33.347 --> 00:28:36.016 align:middle line:-1
是安排后台任务请求

00:28:36.617 --> 00:28:39.286 align:middle line:-1
并且我要当app进入后台时再安排

00:28:39.353 --> 00:28:41.421 align:middle line:-1
因为那时用户会停止使用app

00:28:41.655 --> 00:28:42.990 align:middle line:-1
因此我要继续并编写这个功能

00:28:47.494 --> 00:28:48.495 align:middle line:-1
你可以看到

00:28:48.562 --> 00:28:51.498 align:middle line:-2
我正在调用我刚才编写的那个
ScheduleAppRefresh方法

00:28:51.565 --> 00:28:53.467 align:middle line:-1
而我的app确实进入了后台方法

00:28:53.834 --> 00:28:57.437 align:middle line:-2
在这里我要创建一个后台app
刷新任务请求对象

00:28:58.005 --> 00:29:00.307 align:middle line:-1
并给它传入那个相同的标识符

00:29:01.341 --> 00:29:04.945 align:middle line:-2
然后我把那个请求提交到
任务调度程序

00:29:06.480 --> 00:29:08.916 align:middle line:-1
有一个额外属性

00:29:08.982 --> 00:29:10.484 align:middle line:-1
我想在任务请求对象上调用

00:29:11.151 --> 00:29:12.920 align:middle line:-1
即最早开始时间

00:29:13.453 --> 00:29:16.056 align:middle line:-1
你可以通过这个给任务指定开始推迟

00:29:16.590 --> 00:29:19.826 align:middle line:-2
在这个例子中
我指的是不要开始app刷新

00:29:19.893 --> 00:29:24.264 align:middle line:-2
不要开始刷新app 除非在我安排
它刷新后的至少15分钟之后再执行

00:29:24.565 --> 00:29:26.300 align:middle line:-1
这让我获得了与老的

00:29:26.366 --> 00:29:29.369 align:middle line:-2
SetMinimumBackgroundFetchInterval
API一样的行为

00:29:31.071 --> 00:29:32.739 align:middle line:-1
我安排我的任务

00:29:32.806 --> 00:29:35.642 align:middle line:-1
但实际上我很可能还想做另一件事

00:29:36.677 --> 00:29:39.780 align:middle line:-1
因为每个单个后台任务请求对象

00:29:39.847 --> 00:29:41.682 align:middle line:-1
恰好响应一次启动

00:29:42.182 --> 00:29:45.219 align:middle line:-2
现在如果系统启动了我的app
执行后台app刷新

00:29:45.285 --> 00:29:48.488 align:middle line:-2
系统将不会再次启动它
直到用户打开并离开我的app

00:29:48.889 --> 00:29:51.592 align:middle line:-2
但我并不希望这样
我希望能一直刷新

00:29:51.992 --> 00:29:55.462 align:middle line:-2
因此我要做的就是
在我的handle方法中

00:29:55.529 --> 00:29:56.396 align:middle line:-2
调用
ScheduleAppRefresh

00:29:57.297 --> 00:30:00.434 align:middle line:-2
我会在系统启动app执行
现有任务时 立即发起另一个请求

00:30:01.835 --> 00:30:03.971 align:middle line:-2
就是这个
这就是我要处理app中的

00:30:04.037 --> 00:30:05.839 align:middle line:-2
后台app刷新
所需要编写的全部代码

00:30:07.241 --> 00:30:09.543 align:middle line:-2
但因为我正在使用app
并且正在滚动浏览

00:30:10.644 --> 00:30:14.314 align:middle line:-1
我看到那有许多很久之前的内容

00:30:14.381 --> 00:30:16.750 align:middle line:-1
那可能是不再与用户相关的内容

00:30:16.817 --> 00:30:18.085 align:middle line:-1
只是占用磁盘空间

00:30:18.552 --> 00:30:21.788 align:middle line:-2
如果我们可以为用户清理数据库
那真是太棒了

00:30:22.289 --> 00:30:25.459 align:middle line:-1
最好的工具就是后台处理任务

00:30:25.526 --> 00:30:27.294 align:middle line:-1
我要继续并实施它

00:30:28.595 --> 00:30:31.031 align:middle line:-1
跟以前一样 我要进入我的项目设置

00:30:32.132 --> 00:30:33.567 align:middle line:-1
进入“签名和功能”选项卡

00:30:34.468 --> 00:30:36.503 align:middle line:-1
这一次 在后台模式中

00:30:36.803 --> 00:30:39.706 align:middle line:-1
我要确保勾选后台处理复选框

00:30:43.644 --> 00:30:44.945 align:middle line:-2
我要进入
我的info.plist…

00:30:47.080 --> 00:30:49.183 align:middle line:-1
并点击加号添加新标识符

00:30:49.783 --> 00:30:53.420 align:middle line:-2
我把它命名为
com.colorfeed.dbcleaning…

00:30:56.089 --> 00:30:56.957 align:middle line:-1
并点击保存

00:30:58.091 --> 00:30:59.226 align:middle line:-1
然后跟以前一样

00:30:59.526 --> 00:31:00.928 align:middle line:-1
我要进入app委托…

00:31:01.762 --> 00:31:03.197 align:middle line:-1
并再次调用注册

00:31:07.000 --> 00:31:09.269 align:middle line:-1
这跟我之前的调用相同

00:31:09.336 --> 00:31:11.238 align:middle line:-1
除非我传入了新标识符

00:31:12.039 --> 00:31:15.175 align:middle line:-2
并且我要调用
HandleDatabaseCleaning

00:31:15.242 --> 00:31:17.611 align:middle line:-1
并向下转换为后台处理任务

00:31:18.979 --> 00:31:20.981 align:middle line:-2
现在我要继续并实施
HandleDatabaseCleaning

00:31:27.254 --> 00:31:29.823 align:middle line:-1
我已经把这段代码与后台任务集成了

00:31:30.257 --> 00:31:33.427 align:middle line:-1
它的功能是删除昨天之前的一切数据

00:31:34.294 --> 00:31:37.097 align:middle line:-1
你可以看到 我设置了过期处理器

00:31:37.164 --> 00:31:38.565 align:middle line:-1
和取消我的全部操作

00:31:39.099 --> 00:31:43.270 align:middle line:-2
并且当我完成后成功调用了
SetTaskCompleted

00:31:44.071 --> 00:31:45.672 align:middle line:-1
有一点不同

00:31:45.739 --> 00:31:49.142 align:middle line:-2
就是我一直追踪我上次成功清理
数据库的时间

00:31:50.844 --> 00:31:53.780 align:middle line:-1
这是因为当我安排任务时

00:31:53.847 --> 00:31:56.884 align:middle line:-1
我想谨慎地使用系统的资源

00:31:57.351 --> 00:31:59.586 align:middle line:-1
我不想当用户每次离开app时

00:31:59.653 --> 00:32:01.154 align:middle line:-1
都安排数据库清理任务

00:32:01.221 --> 00:32:03.156 align:middle line:-2
如果我的数据库
实际上不需要清理的话

00:32:03.991 --> 00:32:06.760 align:middle line:-1
我要做的就是编写一个

00:32:07.027 --> 00:32:08.996 align:middle line:-2
ScheduleDatabaseCleaning方法
如果需要的话

00:32:11.265 --> 00:32:12.900 align:middle line:-1
我会检查

00:32:12.966 --> 00:32:16.103 align:middle line:-2
是否距离上次清理已经过去了
至少一周的时间

00:32:16.436 --> 00:32:18.372 align:middle line:-2
如果不是 我就不采取任何措施
我会立即跳出

00:32:19.339 --> 00:32:21.475 align:middle line:-1
反之我将继续并安排那个请求

00:32:22.242 --> 00:32:24.144 align:middle line:-1
我要创建一个后台处理任务请求

00:32:24.511 --> 00:32:26.747 align:middle line:-2
并给它传递我之前传递过的同一个
标识符

00:32:28.715 --> 00:32:31.552 align:middle line:-2
在后台处理任务请求上有一些
额外的属性

00:32:31.618 --> 00:32:32.653 align:middle line:-1
你可能要引起注意

00:32:33.387 --> 00:32:36.089 align:middle line:-1
第一个是要求网络连接

00:32:36.356 --> 00:32:37.891 align:middle line:-1
实际上它默认设为假

00:32:38.525 --> 00:32:40.327 align:middle line:-1
你应该确保把它设为真

00:32:40.394 --> 00:32:43.297 align:middle line:-2
如果执行你的任务真的需要
网络连接的话

00:32:43.564 --> 00:32:45.566 align:middle line:-2
否则我们可能会在没有网络连接时
启动你的任务

00:32:45.632 --> 00:32:48.335 align:middle line:-1
那样你就不能完成很多工作

00:32:49.203 --> 00:32:51.305 align:middle line:-2
在我们的例子中
我们要做一些本地数据库维护

00:32:51.605 --> 00:32:52.906 align:middle line:-1
因此我们可以把它保留为假

00:32:54.007 --> 00:32:56.610 align:middle line:-1
下一个是要求外部电源

00:32:57.911 --> 00:33:00.514 align:middle line:-1
根据设备的特定类型

00:33:00.848 --> 00:33:02.716 align:middle line:-1
和各种系统情况和政策

00:33:03.083 --> 00:33:06.887 align:middle line:-2
我们可能倾向于当设备充电时
启动app

00:33:07.654 --> 00:33:09.523 align:middle line:-1
然而如果你请求

00:33:09.590 --> 00:33:13.060 align:middle line:-1
如果你请求你自己执行密集的任务

00:33:13.126 --> 00:33:14.494 align:middle line:-1
并使用大量资源

00:33:14.561 --> 00:33:16.864 align:middle line:-1
我们强烈建议你把这个设为真

00:33:17.297 --> 00:33:19.032 align:middle line:-1
那样有助于保存用户的电量

00:33:19.766 --> 00:33:23.170 align:middle line:-2
把这个设为真
也是你对CPU密集型任务

00:33:23.237 --> 00:33:24.471 align:middle line:-1
禁用CPU监控的方式

00:33:26.373 --> 00:33:28.709 align:middle line:-2
就是这么多了 我要继续
并把那个请求提交到调度程序

00:33:28.775 --> 00:33:32.079 align:middle line:-1
如果需要的话

00:33:32.379 --> 00:33:34.081 align:middle line:-1
我会在app进入后台时再执行

00:33:35.616 --> 00:33:38.552 align:middle line:-1
这是我要处理后台app刷新

00:33:38.819 --> 00:33:40.254 align:middle line:-2
和后台处理任务所需要编写的
全部代码

00:33:41.088 --> 00:33:42.456 align:middle line:-1
但我如何知道这些代码没问题呢？

00:33:43.524 --> 00:33:45.192 align:middle line:-1
我想我是个完美的程序员 但是

00:33:45.959 --> 00:33:47.728 align:middle line:-1
显然情况并非总是如此

00:33:48.262 --> 00:33:51.532 align:middle line:-1
端对端测试的最好方式是

00:33:51.598 --> 00:33:54.034 align:middle line:-2
把它放在设备上
并像用户一样使用它

00:33:54.301 --> 00:33:56.937 align:middle line:-1
那会确保你可以获得

00:33:57.004 --> 00:33:58.505 align:middle line:-2
用于执行特定任务所需要的
时间和政策

00:33:59.573 --> 00:34:02.309 align:middle line:-1
但我们还知道当你编码时

00:34:02.376 --> 00:34:03.410 align:middle line:-1
你没有时间坐在那儿等着

00:34:03.477 --> 00:34:06.613 align:middle line:-2
因此我们添加了一些方法
你可以在调试器中调用

00:34:06.680 --> 00:34:08.849 align:middle line:-1
用于调试后台任务的使用

00:34:09.149 --> 00:34:10.350 align:middle line:-1
现在让我来演示一下

00:34:11.618 --> 00:34:13.453 align:middle line:-1
我要创建并在我的iPhone上

00:34:13.754 --> 00:34:15.522 align:middle line:-1
运行这个新版后台任务

00:34:21.261 --> 00:34:22.696 align:middle line:-1
你可以看到 它启动了

00:34:22.763 --> 00:34:24.697 align:middle line:-1
现在我要把它放到后台去

00:34:25.966 --> 00:34:27.601 align:middle line:-1
从而确保安排我的任务请求

00:34:28.635 --> 00:34:30.437 align:middle line:-1
我再把它放到前台来 在这里

00:34:30.704 --> 00:34:33.739 align:middle line:-1
我要点击底部的暂停按钮

00:34:35.576 --> 00:34:36.710 align:middle line:-1
这将会进入调试器

00:34:38.110 --> 00:34:39.446 align:middle line:-1
我可以看到控制台

00:34:40.447 --> 00:34:41.481 align:middle line:-1
我要做的就是

00:34:41.547 --> 00:34:42.949 align:middle line:-1
粘贴命令

00:34:43.016 --> 00:34:46.018 align:middle line:-2
你可以从文档中找到命令
因此不需要把它记下来

00:34:47.353 --> 00:34:48.688 align:middle line:-1
在这里我要做的就是

00:34:49.121 --> 00:34:51.225 align:middle line:-1
用我想要模拟的任务的标识符

00:34:51.291 --> 00:34:53.226 align:middle line:-2
替换这个
“task identifier”

00:34:53.726 --> 00:34:55.362 align:middle line:-1
我想测试后台app刷新

00:34:55.661 --> 00:34:58.165 align:middle line:-2
因此我要键入
com.colorfeed.refresh

00:34:59.266 --> 00:35:01.401 align:middle line:-1
但步骤与我的处理任务一样

00:35:02.269 --> 00:35:03.303 align:middle line:-1
我要按回车…

00:35:04.271 --> 00:35:05.138 align:middle line:0
你可以看到

00:35:05.205 --> 00:35:07.274 align:middle line:0
系统已经识别我想模拟一次启动

00:35:07.574 --> 00:35:08.942 align:middle line:0
执行后台app刷新任务

00:35:10.511 --> 00:35:11.979 align:middle line:0
我要点击这里的播放按钮

00:35:15.382 --> 00:35:16.617 align:middle line:-1
你可以看到

00:35:17.084 --> 00:35:18.819 align:middle line:-1
系统开始执行我的app刷新任务

00:35:18.886 --> 00:35:20.621 align:middle line:-1
我的app主动地进行了刷新

00:35:20.687 --> 00:35:22.089 align:middle line:-1
我可以看到代码起作用了

00:35:23.457 --> 00:35:24.558 align:middle line:-1
我要再次点击暂停

00:35:25.025 --> 00:35:28.195 align:middle line:0
这一次我要确保过期也没问题

00:35:28.262 --> 00:35:29.630 align:middle line:0
因为它也同等重要

00:35:30.631 --> 00:35:33.467 align:middle line:0
我要做的就是输入同一个命令

00:35:34.101 --> 00:35:36.570 align:middle line:0
但这一次我要用过期替换“启动”

00:35:36.837 --> 00:35:39.273 align:middle line:0
并按回车

00:35:40.641 --> 00:35:43.076 align:middle line:0
你可以看到
系统识别到我发起了这个请求

00:35:43.710 --> 00:35:44.678 align:middle line:0
当我点击播放时

00:35:44.945 --> 00:35:47.614 align:middle line:0
你应该可以看到我的app会成功地
停止刷新

00:35:47.915 --> 00:35:50.584 align:middle line:0
识别到那个任务已过期
并把任务标记为完成

00:35:51.251 --> 00:35:54.922 align:middle line:0
现在我知道对于后台任务

00:35:54.988 --> 00:35:58.659 align:middle line:0
我的app已经成功地实施并测试了

00:35:59.059 --> 00:36:00.260 align:middle line:0
后台app刷新和后台处理任务

00:36:05.899 --> 00:36:06.900 align:middle line:-1
谢谢

00:36:07.601 --> 00:36:09.036 align:middle line:-2
当你使用我们的框架时
还有一些额外的注意事项

00:36:09.102 --> 00:36:11.471 align:middle line:-1
你可能要引起注意

00:36:12.573 --> 00:36:15.642 align:middle line:-1
第一 请注意对最早开始时间的设置

00:36:15.709 --> 00:36:17.244 align:middle line:-1
不要把时间设置得太远

00:36:17.978 --> 00:36:19.446 align:middle line:-1
如果你把它设置得太远

00:36:19.513 --> 00:36:22.082 align:middle line:-2
并且在此期间用户也没有返回到
你的app中

00:36:22.416 --> 00:36:24.351 align:middle line:-1
我们可能会选择完全不启动你的任务

00:36:24.818 --> 00:36:28.355 align:middle line:-1
那只是为了保护用户的预期和隐私

00:36:28.789 --> 00:36:31.091 align:middle line:-1
几个月都不使用你app的用户

00:36:31.158 --> 00:36:33.727 align:middle line:-1
不会期待它突然开始在后台运行

00:36:34.228 --> 00:36:36.997 align:middle line:-1
因此我们建议你把最早开始时间

00:36:37.464 --> 00:36:40.701 align:middle line:-2
把你推迟的最早开始时间设置为
一周或更短

00:36:42.970 --> 00:36:46.874 align:middle line:-2
接下来请确保在处理任务过程中
你需要访问的任何文件

00:36:47.441 --> 00:36:49.243 align:middle line:-1
当设备被锁定时可访问

00:36:49.576 --> 00:36:51.979 align:middle line:-1
因为我们一般会在那时启动你的任务

00:36:53.046 --> 00:36:55.215 align:middle line:-1
我们保证我们不会开始你的任务

00:36:55.282 --> 00:36:57.217 align:middle line:-1
直到用户第一次锁定他们的设备

00:36:57.518 --> 00:36:59.386 align:middle line:-1
因此请确保你要访问的任何文件

00:36:59.453 --> 00:37:04.291 align:middle line:-2
大部分文件保护类型都是完整的
直到第一次用户验证

00:37:07.060 --> 00:37:08.929 align:middle line:-2
我们在传统的单个窗口的
UIKit app中

00:37:08.996 --> 00:37:11.431 align:middle line:-1
演示了如何实施后台app刷新

00:37:11.765 --> 00:37:14.801 align:middle line:-2
但你知道的 今年我们通过
UIScene API

00:37:15.068 --> 00:37:16.503 align:middle line:-1
引入了多窗口app

00:37:16.970 --> 00:37:18.472 align:middle line:-1
如果你采用那个API

00:37:18.839 --> 00:37:23.644 align:middle line:-2
可以在合适的时间调用UIApplication
RequestSceneSessionRefresh

00:37:23.710 --> 00:37:26.280 align:middle line:-1
从而告诉系统

00:37:26.346 --> 00:37:28.849 align:middle line:-1
App切换器中的快照需要更新

00:37:29.383 --> 00:37:32.085 align:middle line:-2
你可以在它们各自的文档中找到
相关详情

00:37:34.188 --> 00:37:35.088 align:middle line:-1
最后

00:37:35.389 --> 00:37:39.059 align:middle line:-2
BGTaskScheduler.submit
是一个阻塞的同步调用

00:37:39.426 --> 00:37:42.029 align:middle line:-2
我们之所以那样设计它是因为
那样会简化对它的采用方式

00:37:42.095 --> 00:37:44.198 align:middle line:-1
当你进行调度时 当你进入后台时

00:37:44.398 --> 00:37:45.499 align:middle line:-1
这是常见的情况

00:37:46.200 --> 00:37:48.101 align:middle line:-1
然而如果你计划

00:37:48.468 --> 00:37:51.104 align:middle line:-1
在更具性能敏感性的情境中进行调度

00:37:51.605 --> 00:37:53.307 align:middle line:-1
比如当app启动时

00:37:53.807 --> 00:37:55.976 align:middle line:-1
你要确保在后台队列上调用它

00:37:56.243 --> 00:37:59.613 align:middle line:-1
从而不会阻塞主线程并妨碍启动性能

00:38:06.486 --> 00:38:09.756 align:middle line:-2
但请认真考虑
如何在后台使用运行时间

00:38:10.090 --> 00:38:13.227 align:middle line:-2
请谨记我们在设计我们的API时
所考虑的要素

00:38:13.627 --> 00:38:16.730 align:middle line:-1
比如电源、性能和隐私

00:38:18.932 --> 00:38:21.235 align:middle line:-1
请一定使用合适的后台模式

00:38:21.301 --> 00:38:23.303 align:middle line:-1
来完成你要执行的任务

00:38:23.370 --> 00:38:25.806 align:middle line:-1
并获得你想要的用户体验

00:38:28.475 --> 00:38:31.378 align:middle line:-1
最后请使用新后台任务API

00:38:31.445 --> 00:38:33.247 align:middle line:-1
来安排稍后在后台中要执行的任务

00:38:33.714 --> 00:38:35.349 align:middle line:-1
请使用后台app刷新任务

00:38:35.616 --> 00:38:37.784 align:middle line:-1
保持app拥有最新内容

00:38:38.118 --> 00:38:41.588 align:middle line:-2
并使用后台处理任务来执行
可推迟的维护级任务

00:38:42.122 --> 00:38:44.691 align:middle line:-1
当设备闲置时和充电时

00:38:46.760 --> 00:38:51.465 align:middle line:0
要获取更多信息 请参加我们的演讲
或访问演讲网站

00:38:51.532 --> 00:38:53.767 align:middle line:0
查看文档连接和示例代码

00:38:54.234 --> 00:38:55.269 align:middle line:0
谢谢

