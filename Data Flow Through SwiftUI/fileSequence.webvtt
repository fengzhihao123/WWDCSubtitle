WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:00.506 --> 00:00:04.500 A:middle
[音乐]

00:00:08.016 --> 00:00:09.156 A:middle
[掌声]

00:00:09.156 --> 00:00:12.186 A:middle
&gt;&gt; 上午好 欢迎

00:00:12.186 --> 00:00:13.526 A:middle
大家来到 SwiftUI 中的数据流

00:00:13.526 --> 00:00:15.986 A:middle
我叫 Luca Bernardi 

00:00:15.986 --> 00:00:17.096 A:middle
稍后会有一位我的朋友 也是我的同事

00:00:17.096 --> 00:00:18.096 A:middle
Raj Ramamaurthy

00:00:18.096 --> 00:00:18.686 A:middle
加入讲演

00:00:18.906 --> 00:00:20.486 A:middle
大家对 SwiftUI 感到兴奋吗

00:00:20.486 --> 00:00:21.836 A:middle
&gt;&gt; [齐声回答] 兴奋

00:00:21.836 --> 00:00:25.276 A:middle
&gt;&gt; 很好 今天来到这儿

00:00:25.276 --> 00:00:25.996 A:middle
我感到非常高兴

00:00:25.996 --> 00:00:28.476 A:middle
SwiftUI 是制作一个优秀 App 的

00:00:28.476 --> 00:00:30.226 A:middle
最便捷的途径

00:00:30.226 --> 00:00:31.896 A:middle
但是我们也从头开始设计

00:00:32.006 --> 00:00:33.526 A:middle
目标是降低

00:00:33.526 --> 00:00:35.096 A:middle
UI 开发的复杂程度

00:00:35.096 --> 00:00:37.876 A:middle
这就意味着数据在 SwiftUI 中

00:00:37.876 --> 00:00:39.376 A:middle
是第一类对象

00:00:40.056 --> 00:00:42.856 A:middle
在这次讲演中

00:00:42.856 --> 00:00:44.646 A:middle
我们将向大家展示一个

00:00:44.646 --> 00:00:45.776 A:middle
简单却有用的工具

00:00:45.776 --> 00:00:47.706 A:middle
你可以用它

00:00:47.706 --> 00:00:48.506 A:middle
使数据在视图层级中流动

00:00:49.306 --> 00:00:50.706 A:middle
这个工具可以帮助你

00:00:50.706 --> 00:00:53.506 A:middle
设计美观且好用的 App

00:00:56.046 --> 00:00:57.386 A:middle
我们也将会深入内部机制

00:00:57.386 --> 00:00:59.526 A:middle
看看 SwiftUI 如何更新视图层级

00:00:59.526 --> 00:01:01.166 A:middle
来确保

00:01:01.166 --> 00:01:02.956 A:middle
你可以正确而又持续地

00:01:02.956 --> 00:01:04.575 A:middle
呈现你的数据

00:01:05.916 --> 00:01:07.856 A:middle
最后我们将为你

00:01:07.986 --> 00:01:09.376 A:middle
在脑海中建立一个框架

00:01:09.376 --> 00:01:10.996 A:middle
去理解你的数据

00:01:10.996 --> 00:01:12.256 A:middle
和可用工具

00:01:13.836 --> 00:01:16.176 A:middle
在继续说明之前 我们必须要问

00:01:16.176 --> 00:01:16.906 A:middle
数据是什么意思

00:01:18.196 --> 00:01:19.746 A:middle
数据是所有

00:01:19.746 --> 00:01:20.666 A:middle
驱动你 UI 的信息

00:01:21.296 --> 00:01:23.746 A:middle
数据的形态结构多种多样

00:01:24.356 --> 00:01:25.806 A:middle
一个例子是

00:01:25.806 --> 00:01:27.886 A:middle
像 Toggle 中的状态一样
声明你的 UI

00:01:29.036 --> 00:01:30.766 A:middle
数据还代表模型数据

00:01:31.306 --> 00:01:32.976 A:middle
比如驱动一列信息的对象

00:01:36.096 --> 00:01:37.716 A:middle
我们有许多工具

00:01:37.716 --> 00:01:39.166 A:middle
供你选择

00:01:39.166 --> 00:01:39.746 A:middle
取决于你想做什么

00:01:40.656 --> 00:01:41.586 A:middle
你也许已经在之前的讲解中

00:01:41.586 --> 00:01:42.926 A:middle
看到了这些工具

00:01:42.926 --> 00:01:44.756 A:middle
如果你对它们并不熟悉

00:01:44.756 --> 00:01:47.206 A:middle
不必担心

00:01:47.206 --> 00:01:48.786 A:middle
我们会解释它们是什么

00:01:48.786 --> 00:01:49.256 A:middle
以及什么时候用得到

00:01:50.236 --> 00:01:51.836 A:middle
听完讲解后

00:01:51.836 --> 00:01:54.186 A:middle
你就会清楚地知道使用哪个工具

00:01:54.306 --> 00:01:54.826 A:middle
以及什么时候使用

00:01:55.486 --> 00:01:57.736 A:middle
但是在展示工具之前

00:01:57.736 --> 00:01:59.316 A:middle
我想先阐释

00:01:59.316 --> 00:02:00.866 A:middle
两个指导性原则

00:02:00.866 --> 00:02:03.136 A:middle
这两个原则启发了我们的设计

00:02:03.936 --> 00:02:05.266 A:middle
第一个原则是

00:02:05.266 --> 00:02:06.996 A:middle
每次你在视图中

00:02:06.996 --> 00:02:08.166 A:middle
读取数据时

00:02:08.166 --> 00:02:09.776 A:middle
你都在为那个视图创建一个依赖

00:02:10.616 --> 00:02:11.806 A:middle
这是一个依赖

00:02:11.806 --> 00:02:13.116 A:middle
因为每当数据发生变化

00:02:13.466 --> 00:02:14.736 A:middle
你的视图也要变化

00:02:14.736 --> 00:02:15.576 A:middle
去反映一个新的值

00:02:17.156 --> 00:02:18.776 A:middle
举个例子

00:02:18.776 --> 00:02:19.876 A:middle
这里蓝色的是播放控制的视图

00:02:19.876 --> 00:02:21.856 A:middle
这个视图需要

00:02:21.856 --> 00:02:23.006 A:middle
读取紫色的数据

00:02:23.806 --> 00:02:25.116 A:middle
每当这个值变化时

00:02:25.116 --> 00:02:25.976 A:middle
我们都要更新视图

00:02:28.666 --> 00:02:31.686 A:middle
所以 定义这个依赖

00:02:31.686 --> 00:02:33.126 A:middle
是个手动的过程

00:02:33.126 --> 00:02:34.696 A:middle
很快就会变得复杂起来

00:02:35.266 --> 00:02:38.206 A:middle
正如查看 SwiftUI

00:02:38.206 --> 00:02:40.096 A:middle
数据依赖

00:02:40.096 --> 00:02:40.596 A:middle
也是声明式的

00:02:40.596 --> 00:02:41.956 A:middle
并不是手动

00:02:41.956 --> 00:02:43.696 A:middle
同步或失效

00:02:43.696 --> 00:02:46.756 A:middle
通过 SwiftUI 

00:02:46.756 --> 00:02:48.056 A:middle
你只需用很少的工具

00:02:48.056 --> 00:02:50.056 A:middle
把依赖描述给框架

00:02:50.056 --> 00:02:51.566 A:middle
框架就会处理剩下的

00:02:51.596 --> 00:02:54.006 A:middle
这就意味着你可以

00:02:54.056 --> 00:02:55.456 A:middle
将你的注意力集中在

00:02:55.456 --> 00:02:57.316 A:middle
为用户提供最佳体验上

00:03:01.516 --> 00:03:03.446 A:middle
在视图层级中

00:03:03.446 --> 00:03:04.696 A:middle
你读取的每一条数据

00:03:04.846 --> 00:03:05.806 A:middle
都有一个数据源

00:03:07.016 --> 00:03:08.166 A:middle
数据源存在

00:03:08.166 --> 00:03:08.816 A:middle
在视图层级里

00:03:09.216 --> 00:03:10.576 A:middle
比如说你有状态

00:03:10.576 --> 00:03:13.366 A:middle
要折叠

00:03:13.426 --> 00:03:14.986 A:middle
或者不折叠

00:03:14.986 --> 00:03:16.866 A:middle
它也可以是外部的

00:03:16.916 --> 00:03:18.396 A:middle
比如当你显示一个

00:03:18.396 --> 00:03:18.976 A:middle
来自不变模型的信息时

00:03:21.696 --> 00:03:22.836 A:middle
不论数据源在哪里

00:03:22.836 --> 00:03:24.876 A:middle
你应该一直有一个

00:03:24.876 --> 00:03:27.266 A:middle
单一数据源

00:03:29.096 --> 00:03:31.196 A:middle
重复数据源会

00:03:31.196 --> 00:03:32.766 A:middle
会产生 Bug 和不一致

00:03:32.986 --> 00:03:34.256 A:middle
你要一直很小心

00:03:34.256 --> 00:03:35.766 A:middle
让它们保持同步

00:03:36.776 --> 00:03:38.286 A:middle
想一想你一直重复

00:03:38.286 --> 00:03:39.786 A:middle
同一条数据

00:03:39.866 --> 00:03:42.626 A:middle
比如在同级视图里重复同一条数据

00:03:42.626 --> 00:03:44.876 A:middle
想一想消息传递

00:03:44.876 --> 00:03:46.186 A:middle
是多么复杂

00:03:46.276 --> 00:03:47.626 A:middle
KV 观察

00:03:47.626 --> 00:03:48.796 A:middle
或响应一个不同的

00:03:48.796 --> 00:03:50.326 A:middle
事件顺序

00:03:50.326 --> 00:03:50.876 A:middle
会产生 Bug

00:03:52.086 --> 00:03:53.386 A:middle
很容易就出错了

00:03:54.046 --> 00:03:55.036 A:middle
它们会重复同一个错误

00:03:55.036 --> 00:03:56.286 A:middle
很多次

00:03:56.866 --> 00:03:59.936 A:middle
反而 你需要做的是

00:03:59.936 --> 00:04:01.456 A:middle
把数据提取到一个

00:04:01.456 --> 00:04:03.386 A:middle
共同的父级节点

00:04:03.386 --> 00:04:05.546 A:middle
让两个子节点链接到父节点

00:04:06.836 --> 00:04:08.426 A:middle
当你有一个单一数据源时

00:04:08.426 --> 00:04:10.066 A:middle
你就消除了这种

00:04:10.276 --> 00:04:11.946 A:middle
视图和数据

00:04:11.946 --> 00:04:12.596 A:middle
不一致的 Bug

00:04:13.206 --> 00:04:14.176 A:middle
你就可以用

00:04:14.426 --> 00:04:15.786 A:middle
语言有的工具

00:04:15.786 --> 00:04:17.255 A:middle
在你的数据中执行变量

00:04:17.866 --> 00:04:20.586 A:middle
记住这个原则

00:04:20.966 --> 00:04:22.846 A:middle
退一步 看看

00:04:22.846 --> 00:04:23.856 A:middle
你代码里的所有数据源

00:04:23.856 --> 00:04:25.466 A:middle
用这个原则

00:04:25.466 --> 00:04:27.376 A:middle
去决定

00:04:27.376 --> 00:04:33.126 A:middle
数据的结构

00:04:33.276 --> 00:04:35.696 A:middle
在我来 Apple 总部

00:04:35.696 --> 00:04:37.016 A:middle
上班的路上

00:04:37.016 --> 00:04:37.746 A:middle
我特别喜欢听一个很棒的播客

00:04:37.746 --> 00:04:39.386 A:middle
我觉得用 SwiftUI 

00:04:39.386 --> 00:04:41.646 A:middle
做一个播放器是个好主意

00:04:41.646 --> 00:04:44.616 A:middle
在这次讲解中

00:04:44.616 --> 00:04:45.596 A:middle
我会用这个做例子

00:04:45.736 --> 00:04:46.926 A:middle
展示所有的

00:04:46.926 --> 00:04:47.676 A:middle
可用工具

00:04:48.676 --> 00:04:50.256 A:middle
这是我们将要建构的 UI

00:04:51.506 --> 00:04:52.556 A:middle
这是播放器的界面

00:04:52.556 --> 00:04:53.826 A:middle
我们需要它显示

00:04:53.826 --> 00:04:55.236 A:middle
节目和剧集的名字

00:04:55.276 --> 00:04:57.836 A:middle
播放按钮

00:04:57.836 --> 00:04:58.496 A:middle
和当前时间

00:04:59.096 --> 00:05:01.916 A:middle
我们将一步一步

00:05:01.916 --> 00:05:02.796 A:middle
建构这个 UI

00:05:03.686 --> 00:05:04.846 A:middle
首先创建一个视图

00:05:04.846 --> 00:05:05.976 A:middle
显示当前剧集的视图

00:05:09.386 --> 00:05:10.506 A:middle
第一步是创建一个新视图

00:05:10.506 --> 00:05:12.536 A:middle
PlayerView 

00:05:12.536 --> 00:05:13.636 A:middle
这个视图有一个属性

00:05:13.636 --> 00:05:15.296 A:middle
存储着当前播放剧集

00:05:15.936 --> 00:05:17.836 A:middle
我们还想要显示

00:05:17.836 --> 00:05:19.466 A:middle
剧集和标题

00:05:19.926 --> 00:05:20.986 A:middle
所以在主体中

00:05:20.986 --> 00:05:22.956 A:middle
我们会做一个 VStack 包含两个文本

00:05:22.956 --> 00:05:23.966 A:middle
这样它们会纵向排列

00:05:24.536 --> 00:05:27.946 A:middle
基本的 Swift 属性

00:05:27.946 --> 00:05:28.846 A:middle
是你的第一个工具

00:05:29.276 --> 00:05:30.206 A:middle
当你有一个视图

00:05:30.206 --> 00:05:31.506 A:middle
需要读取所有的派生数据访问时

00:05:31.506 --> 00:05:33.446 A:middle
它是很好用的

00:05:34.406 --> 00:05:35.346 A:middle
这条数据会被它的父节点

00:05:35.346 --> 00:05:37.206 A:middle
提供给视图

00:05:38.556 --> 00:05:40.386 A:middle
现在我想让它有

00:05:40.386 --> 00:05:42.246 A:middle
播放和暂停的功能

00:05:42.936 --> 00:05:46.676 A:middle
我们有一个新的属性

00:05:46.676 --> 00:05:48.546 A:middle
表明当前剧集是否在播放

00:05:48.546 --> 00:05:50.896 A:middle
现在 显示不同片段的图像

00:05:50.896 --> 00:05:52.266 A:middle
取决于

00:05:52.266 --> 00:05:53.236 A:middle
isPlaying 这个值

00:05:53.856 --> 00:05:56.176 A:middle
但是现在我想让播放键

00:05:56.176 --> 00:05:58.196 A:middle
有交互功能

00:05:58.196 --> 00:05:59.556 A:middle
用户按播放键时

00:05:59.586 --> 00:06:01.146 A:middle
播放状态会切换

00:06:01.146 --> 00:06:02.226 A:middle
图片也会随之改变

00:06:02.816 --> 00:06:07.636 A:middle
我们可以用 Button （按钮）

00:06:07.786 --> 00:06:09.636 A:middle
Button 包含一些内容

00:06:09.636 --> 00:06:10.756 A:middle
运行一个动作

00:06:10.756 --> 00:06:11.646 A:middle
当用户点击这个它时

00:06:12.726 --> 00:06:13.906 A:middle
我们只是切换

00:06:13.906 --> 00:06:14.446 A:middle
isPlaying

00:06:15.086 --> 00:06:18.726 A:middle
但如果我们运行一下

00:06:18.726 --> 00:06:19.676 A:middle
就会出现编译错误

00:06:20.686 --> 00:06:21.876 A:middle
这是个好事情

00:06:21.876 --> 00:06:23.736 A:middle
通过 UI 的

00:06:23.736 --> 00:06:24.766 A:middle
其中一条普遍原则

00:06:24.766 --> 00:06:25.726 A:middle
把我们引上正确的道路

00:06:25.726 --> 00:06:28.366 A:middle
我们不改写视图层级

00:06:28.916 --> 00:06:31.606 A:middle
你的 UI 每次更新

00:06:31.606 --> 00:06:33.536 A:middle
都是因为某个视图主体

00:06:33.536 --> 00:06:34.726 A:middle
在生成新的值

00:06:34.726 --> 00:06:37.266 A:middle
为了处理这种情况

00:06:37.306 --> 00:06:38.616 A:middle
我们有一个工具

00:06:38.616 --> 00:06:38.976 A:middle
叫作 State （状态）

00:06:42.146 --> 00:06:43.676 A:middle
我们在这个视图里创建一个主状态

00:06:44.256 --> 00:06:46.726 A:middle
通过 isPlaying 属性上的 

00:06:46.726 --> 00:06:48.226 A:middle
State Property Wrapper

00:06:48.226 --> 00:06:49.106 A:middle
我们可以实现这一点

00:06:49.716 --> 00:06:51.006 A:middle
这么做相当于

00:06:51.006 --> 00:06:52.106 A:middle
告诉系统

00:06:52.186 --> 00:06:53.566 A:middle
isPlaying 是个值

00:06:53.566 --> 00:06:55.286 A:middle
它可以变化

00:06:55.286 --> 00:06:56.656 A:middle
播放器视图会随它变化

00:06:58.086 --> 00:06:59.716 A:middle
现在再运行一下

00:06:59.716 --> 00:07:00.666 A:middle
就不会出现编辑错误了

00:07:01.106 --> 00:07:02.146 A:middle
用户每轻点一次按钮

00:07:02.146 --> 00:07:05.196 A:middle
状态值都会变化

00:07:05.786 --> 00:07:06.756 A:middle
框架就会为这个视图

00:07:06.756 --> 00:07:07.846 A:middle
生成一个新主体

00:07:08.776 --> 00:07:09.726 A:middle
如果你不了解

00:07:09.966 --> 00:07:11.716 A:middle
Property Wrapper

00:07:11.716 --> 00:07:14.026 A:middle
它是 Swift 5.1 里非常有用的一点

00:07:14.606 --> 00:07:17.136 A:middle
至于它们是如何运作的

00:07:17.136 --> 00:07:18.296 A:middle
我们不再细说

00:07:18.776 --> 00:07:19.826 A:middle
如果你想了解更多的话

00:07:20.026 --> 00:07:21.366 A:middle
可以去看这两个很好的分会议

00:07:21.966 --> 00:07:24.796 A:middle
在今天这个讲演中

00:07:24.796 --> 00:07:25.836 A:middle
你只需要知道

00:07:25.836 --> 00:07:27.196 A:middle
当你添加 Property Wrapper 时

00:07:27.196 --> 00:07:28.596 A:middle
你就是在打包这个属性

00:07:28.596 --> 00:07:29.916 A:middle
并当它读写时

00:07:29.916 --> 00:07:32.146 A:middle
为它增加一些额外操作

00:07:32.666 --> 00:07:35.036 A:middle
你可能想知道

00:07:35.036 --> 00:07:35.596 A:middle
这是怎么实现的

00:07:36.216 --> 00:07:38.076 A:middle
这个额外操作

00:07:38.646 --> 00:07:40.626 A:middle
是什么

00:07:40.836 --> 00:07:42.836 A:middle
当你声明框架

00:07:42.836 --> 00:07:44.206 A:middle
为视图上的变量 

00:07:44.206 --> 00:07:45.596 A:middle
分配永久存储时

00:07:45.596 --> 00:07:46.936 A:middle
我们会追踪它为一个依赖

00:07:46.936 --> 00:07:49.526 A:middle
因为如果系统给你

00:07:49.526 --> 00:07:51.936 A:middle
创建了一个存储

00:07:51.936 --> 00:07:53.316 A:middle
你必须总是明确规定

00:07:53.316 --> 00:07:54.376 A:middle
一个初始常量值

00:07:54.926 --> 00:07:57.466 A:middle
视图经常会被系统重建

00:07:57.466 --> 00:07:59.636 A:middle
但是对于 State 来说

00:07:59.636 --> 00:08:01.436 A:middle
尽管视图同样有很多次更新

00:08:01.436 --> 00:08:03.016 A:middle
框架知道它需要

00:08:03.016 --> 00:08:04.686 A:middle
永久存储

00:08:05.166 --> 00:08:08.256 A:middle
这是个很好的操作

00:08:08.256 --> 00:08:10.006 A:middle
清楚地声明状态属性

00:08:10.006 --> 00:08:12.296 A:middle
是私有变量 

00:08:12.296 --> 00:08:14.366 A:middle
真正实现

00:08:14.366 --> 00:08:16.076 A:middle
状态由视图所有和管理

00:08:16.646 --> 00:08:19.106 A:middle
但是我想深入内部结构

00:08:19.106 --> 00:08:20.766 A:middle
让你们看看

00:08:20.766 --> 00:08:21.556 A:middle
当用户点击按钮时

00:08:21.556 --> 00:08:21.976 A:middle
会发生什么

00:08:25.346 --> 00:08:26.636 A:middle
从我们刚才展示的

00:08:26.636 --> 00:08:27.276 A:middle
视图层级开始

00:08:28.466 --> 00:08:30.346 A:middle
我们刚才说

00:08:30.346 --> 00:08:31.976 A:middle
当我们定义了一个状态时

00:08:31.976 --> 00:08:33.086 A:middle
框架会为你

00:08:33.086 --> 00:08:34.256 A:middle
分配永久存储

00:08:35.535 --> 00:08:36.736 A:middle
状态变量的一个特殊属性是

00:08:36.736 --> 00:08:38.376 A:middle
当它们变化时 

00:08:38.376 --> 00:08:40.176 A:middle
SwiftUI 就开始了

00:08:40.176 --> 00:08:43.226 A:middle
因为 SwiftUI 知道

00:08:43.226 --> 00:08:44.466 A:middle
状态变量正在写主体

00:08:44.466 --> 00:08:46.506 A:middle
它知道视图渲染

00:08:46.506 --> 00:08:47.976 A:middle
取决于状态变量

00:08:50.586 --> 00:08:51.666 A:middle
当用户和按钮互动时

00:08:51.666 --> 00:08:53.786 A:middle
框架就会运行动作

00:08:53.786 --> 00:08:55.346 A:middle
这个动作继而

00:08:55.346 --> 00:08:56.236 A:middle
会和某个状态关联

00:08:58.476 --> 00:09:00.196 A:middle
运行时数据

00:09:00.196 --> 00:09:01.386 A:middle
状态确实会变化

00:09:01.386 --> 00:09:02.736 A:middle
并验证状态的视图

00:09:02.736 --> 00:09:05.636 A:middle
这也就是说

00:09:05.636 --> 00:09:07.166 A:middle
它会重新计算那个视图的主体

00:09:07.306 --> 00:09:08.396 A:middle
以及它所有的子类

00:09:09.006 --> 00:09:12.056 A:middle
在这种意义上

00:09:12.056 --> 00:09:13.356 A:middle
所有的变化都会一直

00:09:13.356 --> 00:09:14.046 A:middle
贯穿你的视图层级 

00:09:14.836 --> 00:09:16.486 A:middle
这样效率很高

00:09:16.486 --> 00:09:17.716 A:middle
这是因为

00:09:17.716 --> 00:09:19.366 A:middle
框架会比较视图

00:09:19.736 --> 00:09:21.766 A:middle
而且只会重新渲染改变了的地方

00:09:22.346 --> 00:09:25.016 A:middle
这正是我们

00:09:25.016 --> 00:09:26.306 A:middle
之前提到的

00:09:26.306 --> 00:09:27.596 A:middle
框架可以

00:09:27.596 --> 00:09:28.396 A:middle
为你管理依赖

00:09:30.116 --> 00:09:32.266 A:middle
我们刚才还提到数据源

00:09:32.266 --> 00:09:34.276 A:middle
要记住

00:09:34.276 --> 00:09:35.856 A:middle
每次你

00:09:35.856 --> 00:09:38.146 A:middle
声明一个状态

00:09:38.146 --> 00:09:39.886 A:middle
你就定义了一个数据源

00:09:39.886 --> 00:09:40.746 A:middle
这个数据源是属于视图的

00:09:40.746 --> 00:09:43.406 A:middle
这点很重要

00:09:43.786 --> 00:09:45.106 A:middle
我用了更大的字母来强调

00:09:45.106 --> 00:09:47.576 A:middle
另一个重要的点是

00:09:47.576 --> 00:09:49.426 A:middle
视图是状态的

00:09:49.426 --> 00:09:50.896 A:middle
一个函数

00:09:50.896 --> 00:09:53.446 A:middle
而非事件顺序

00:09:53.576 --> 00:09:55.496 A:middle
传统方法是

00:09:55.496 --> 00:09:57.296 A:middle
通过直接修改视图层级

00:09:57.296 --> 00:09:58.016 A:middle
响应某个事件

00:09:58.836 --> 00:09:59.966 A:middle
比如 通过添加或者删除

00:09:59.966 --> 00:10:01.756 A:middle
一个 subview 

00:10:01.756 --> 00:10:02.296 A:middle
或改变 alpha

00:10:03.356 --> 00:10:05.806 A:middle
但是在 SwiftUI 里

00:10:05.806 --> 00:10:08.056 A:middle
你修改某个状态

00:10:08.056 --> 00:10:09.366 A:middle
这个状态就是数据源的函数

00:10:09.366 --> 00:10:10.056 A:middle
通过这个就可以生成视图

00:10:10.056 --> 00:10:12.536 A:middle
这就是 SwiftUI

00:10:12.666 --> 00:10:15.096 A:middle
声明式语法出色的地方

00:10:15.566 --> 00:10:17.336 A:middle
你鉴于当前状态

00:10:17.336 --> 00:10:18.076 A:middle
描述视图

00:10:18.076 --> 00:10:21.196 A:middle
SwiftUI 就是这样

00:10:21.196 --> 00:10:22.786 A:middle
降低了 UI 开发的复杂程度

00:10:22.786 --> 00:10:24.866 A:middle
让你可以写一个

00:10:24.866 --> 00:10:26.966 A:middle
好看又准确的交互界面

00:10:30.656 --> 00:10:31.886 A:middle
你可以把 App 看作

00:10:31.886 --> 00:10:33.706 A:middle
一个用户和设备之间的

00:10:33.706 --> 00:10:34.976 A:middle
持续反馈循环

00:10:37.666 --> 00:10:38.896 A:middle
一切都从用户开始

00:10:40.396 --> 00:10:42.246 A:middle
用户和 App 交互

00:10:42.246 --> 00:10:46.716 A:middle
生成一个动作

00:10:46.896 --> 00:10:48.056 A:middle
动作被框架执行

00:10:48.056 --> 00:10:49.716 A:middle
修改某个状态

00:10:51.126 --> 00:10:52.346 A:middle
系统发现状态发生了变化

00:10:52.346 --> 00:10:54.146 A:middle
所以它就知道

00:10:54.146 --> 00:10:55.676 A:middle
它需要根据状态

00:10:55.676 --> 00:10:57.426 A:middle
刷新视图

00:10:59.496 --> 00:11:01.436 A:middle
这个刷新给了 UI 

00:11:01.436 --> 00:11:03.166 A:middle
一个新的形式

00:11:03.166 --> 00:11:05.216 A:middle
用户继续和新形式互动

00:11:06.436 --> 00:11:09.016 A:middle
在这个模型中

00:11:09.016 --> 00:11:10.726 A:middle
数据流向是单一向的

00:11:11.116 --> 00:11:13.276 A:middle
它是所有变化的

00:11:13.276 --> 00:11:15.796 A:middle
单一终点

00:11:15.796 --> 00:11:18.296 A:middle
让视图刷新变得

00:11:18.296 --> 00:11:19.356 A:middle
可预测且易理解

00:11:19.956 --> 00:11:22.026 A:middle
现在我们弄明白了状态

00:11:22.116 --> 00:11:23.826 A:middle
我想回到 AppWare 构建

00:11:23.826 --> 00:11:25.586 A:middle
并做一些优化

00:11:26.126 --> 00:11:30.186 A:middle
我想做的第一件事是

00:11:30.186 --> 00:11:31.916 A:middle
每次用户按下

00:11:31.986 --> 00:11:33.996 A:middle
暂停键 剧集名

00:11:33.996 --> 00:11:34.946 A:middle
都会变成灰色

00:11:34.946 --> 00:11:37.516 A:middle
我们已经知道怎么做了

00:11:38.236 --> 00:11:39.526 A:middle
我们只需要用 isPlaying 状态

00:11:39.526 --> 00:11:41.586 A:middle
选择正确的文字颜色

00:11:42.106 --> 00:11:45.816 A:middle
接下来我想做一些重构

00:11:46.316 --> 00:11:47.866 A:middle
如果你已经看过 SwiftUI 的
基本工具讲演

00:11:47.866 --> 00:11:49.646 A:middle
你就已经知道

00:11:49.646 --> 00:11:51.186 A:middle
视图在 SwiftUI 里

00:11:51.186 --> 00:11:52.666 A:middle
是一个 Locust 阻塞

00:11:53.726 --> 00:11:55.636 A:middle
不必害怕

00:11:55.636 --> 00:11:56.886 A:middle
将视图中有意义的数据

00:11:57.316 --> 00:11:59.336 A:middle
合并为可以被一起编写的 

00:11:59.336 --> 00:12:00.886 A:middle
更小的

00:12:00.886 --> 00:12:01.826 A:middle
可重复使用的组件

00:12:01.906 --> 00:12:04.196 A:middle
正好可以以此为例

00:12:04.776 --> 00:12:07.386 A:middle
这是播放按钮和暂停按钮

00:12:07.386 --> 00:12:08.006 A:middle
的代码

00:12:08.606 --> 00:12:10.976 A:middle
封装这个逻辑

00:12:10.976 --> 00:12:11.956 A:middle
到它自己的视图

00:12:12.526 --> 00:12:13.906 A:middle
命名为 PlayButton

00:12:15.246 --> 00:12:16.296 A:middle
现在看一下

00:12:16.296 --> 00:12:17.676 A:middle
PlayButton 的实现

00:12:17.816 --> 00:12:22.086 A:middle
代码还是一样的

00:12:22.586 --> 00:12:24.196 A:middle
只是封装到了一个新视图

00:12:25.046 --> 00:12:26.296 A:middle
但是注意这里我们做了一个新状态

00:12:26.296 --> 00:12:29.776 A:middle
但是状态不是正确的工具

00:12:30.856 --> 00:12:32.806 A:middle
使用状态

00:12:32.806 --> 00:12:34.516 A:middle
我们就为 isPlaying 建立了一个新数据源

00:12:34.516 --> 00:12:36.206 A:middle
这样我们必须

00:12:36.206 --> 00:12:37.556 A:middle
和父级 PlayerView 的状态

00:12:37.556 --> 00:12:38.326 A:middle
保持同步

00:12:38.326 --> 00:12:40.096 A:middle
这不是我们想要的效果

00:12:40.746 --> 00:12:43.406 A:middle
我们想做的是

00:12:43.406 --> 00:12:44.636 A:middle
让它成为可重复使用的组件

00:12:45.236 --> 00:12:46.396 A:middle
所以这个视图不会拥有

00:12:46.396 --> 00:12:48.956 A:middle
一个数据源

00:12:48.956 --> 00:12:50.286 A:middle
它只能读取一个值

00:12:50.286 --> 00:12:50.896 A:middle
然后改写它

00:12:52.006 --> 00:12:53.206 A:middle
但是它不需要拥有状态

00:12:53.206 --> 00:12:55.476 A:middle
我们有处理这种情况的工具

00:12:55.816 --> 00:12:56.666 A:middle
这个工具叫作 Binding（绑定）

00:12:56.666 --> 00:13:00.466 A:middle
通过 Binding Property Wrapper

00:13:00.506 --> 00:13:02.436 A:middle
给数据源

00:13:02.436 --> 00:13:04.016 A:middle
定义一个清楚的依赖

00:13:04.016 --> 00:13:05.316 A:middle
而不拥有它

00:13:06.656 --> 00:13:07.936 A:middle
而且 你不需要

00:13:07.936 --> 00:13:09.676 A:middle
提供初始值

00:13:09.676 --> 00:13:11.566 A:middle
因为绑定可以从状态中生成

00:13:12.886 --> 00:13:14.256 A:middle
看一下效果如何

00:13:14.256 --> 00:13:15.136 A:middle
是不是很适合我们的例子

00:13:15.746 --> 00:13:17.846 A:middle
我们唯一要做的就是

00:13:17.846 --> 00:13:19.616 A:middle
用 Binding Property Wrapper

00:13:19.616 --> 00:13:21.936 A:middle
删除初始值

00:13:22.256 --> 00:13:23.086 A:middle
就是这么简单

00:13:23.706 --> 00:13:26.216 A:middle
现在来看一下

00:13:26.216 --> 00:13:27.936 A:middle
如何通过返回 PlayerView

00:13:27.936 --> 00:13:29.196 A:middle
为 PlayButton 提供一个绑定

00:13:31.756 --> 00:13:33.696 A:middle
PlayerView 依旧持有状态

00:13:33.906 --> 00:13:35.076 A:middle
这是你的数据源

00:13:35.686 --> 00:13:38.866 A:middle
在属性名字上 

00:13:38.866 --> 00:13:40.296 A:middle
使用美元符号

00:13:40.296 --> 00:13:41.826 A:middle
你就可以从状态生成一个绑定

00:13:42.386 --> 00:13:44.936 A:middle
这是你让组件

00:13:44.936 --> 00:13:48.436 A:middle
通过绑定访问状态的方法

00:13:49.056 --> 00:13:51.696 A:middle
美元符号是 Property Wrapper 的

00:13:51.696 --> 00:13:53.206 A:middle
另一个特色

00:13:53.416 --> 00:13:54.796 A:middle
如果你想了解更多

00:13:55.096 --> 00:13:57.486 A:middle
请看现代 Swift API 设计讲演

00:14:01.466 --> 00:14:04.076 A:middle
欣赏一下这是多么

00:14:04.476 --> 00:14:05.456 A:middle
简单却有效

00:14:06.536 --> 00:14:08.326 A:middle
PlayButton 不包含

00:14:08.326 --> 00:14:09.736 A:middle
isPlaying 值的主体

00:14:10.826 --> 00:14:12.046 A:middle
只是通过绑定

00:14:12.276 --> 00:14:14.046 A:middle
作为它的引用

00:14:14.046 --> 00:14:16.186 A:middle
所以没有必要

00:14:16.186 --> 00:14:17.976 A:middle
让数据和视图保持同步

00:14:20.046 --> 00:14:21.696 A:middle
我想把这个

00:14:21.696 --> 00:14:23.066 A:middle
和我们现在使用的 UIKit GraphKit

00:14:23.066 --> 00:14:23.976 A:middle
对比一下

00:14:26.256 --> 00:14:28.376 A:middle
我们有一个 View Controller

00:14:28.376 --> 00:14:30.276 A:middle
有多个视图 

00:14:30.276 --> 00:14:32.256 A:middle
需要响应我们用户的交互

00:14:32.256 --> 00:14:34.106 A:middle
要非常麻烦地设定目标 动作

00:14:34.106 --> 00:14:35.876 A:middle
或者定义委托

00:14:36.946 --> 00:14:38.366 A:middle
你需要观察模型变化

00:14:38.366 --> 00:14:40.486 A:middle
并且也要响应事件

00:14:41.626 --> 00:14:43.536 A:middle
每次有值变化时

00:14:43.826 --> 00:14:45.466 A:middle
你都需要读取值

00:14:45.466 --> 00:14:46.796 A:middle
把它设置在任何需要它的地方

00:14:47.416 --> 00:14:50.246 A:middle
一旦你的 App 复杂起来

00:14:50.276 --> 00:14:52.596 A:middle
这就成了大问题

00:14:52.596 --> 00:14:55.216 A:middle
我确信

00:14:55.216 --> 00:14:56.606 A:middle
在座诸位都知道

00:14:56.606 --> 00:14:57.266 A:middle
我说的这种情况

00:14:58.086 --> 00:14:59.396 A:middle
View Controller 的整体目标

00:14:59.396 --> 00:15:01.376 A:middle
就是让你的数据

00:15:01.376 --> 00:15:02.866 A:middle
和你的视图保持同步

00:15:03.746 --> 00:15:05.436 A:middle
这是你我要处理的复杂难题

00:15:05.816 --> 00:15:08.796 A:middle
但是在 SwiftUI 中不存在

00:15:09.476 --> 00:15:12.496 A:middle
你有一个简单的工具

00:15:12.496 --> 00:15:14.186 A:middle
来定义数据依赖

00:15:14.186 --> 00:15:16.146 A:middle
框架会处理其他的

00:15:16.846 --> 00:15:18.186 A:middle
你再也不需要

00:15:18.186 --> 00:15:19.146 A:middle
View Controller 了

00:15:20.516 --> 00:15:27.806 A:middle
[掌声 欢呼]

00:15:28.306 --> 00:15:30.396 A:middle
这个想法非常有用

00:15:30.496 --> 00:15:32.906 A:middle
这应用在整个框架中

00:15:35.806 --> 00:15:37.046 A:middle
如果你看一下组件的 API

00:15:37.046 --> 00:15:38.376 A:middle
如 Toggle

00:15:38.686 --> 00:15:40.946 A:middle
TextField 和 Slider

00:15:40.946 --> 00:15:42.056 A:middle
它们都需要一个绑定框架

00:15:42.906 --> 00:15:44.736 A:middle
让你控制

00:15:44.736 --> 00:15:46.756 A:middle
数据源在的地方

00:15:46.756 --> 00:15:51.056 A:middle
你创建数据 

00:15:51.056 --> 00:15:52.106 A:middle
把它给组件

00:15:52.106 --> 00:15:53.906 A:middle
只是作为一个引用

00:15:53.906 --> 00:15:55.976 A:middle
而不需要重复信息

00:15:55.976 --> 00:15:57.306 A:middle
或者费力保持同步

00:15:57.306 --> 00:15:58.846 A:middle
这真是太棒了

00:16:02.706 --> 00:16:03.886 A:middle
有很多 App 可以查看

00:16:04.376 --> 00:16:06.626 A:middle
布局 导航等

00:16:07.176 --> 00:16:09.106 A:middle
实际上它们是你的

00:16:09.246 --> 00:16:10.296 A:middle
单一原生组件

00:16:11.016 --> 00:16:12.516 A:middle
它们也是好工具

00:16:12.516 --> 00:16:14.226 A:middle
用来为单一数据 

00:16:14.456 --> 00:16:15.686 A:middle
封装表示逻辑

00:16:16.866 --> 00:16:18.306 A:middle
框架使你能够

00:16:18.306 --> 00:16:20.296 A:middle
并鼓励你创建小的视图

00:16:20.296 --> 00:16:22.436 A:middle
去呈现一条

00:16:22.436 --> 00:16:24.596 A:middle
可以被一起编写的

00:16:25.856 --> 00:16:27.036 A:middle
单个数据

00:16:27.036 --> 00:16:28.726 A:middle
再一次 框架带领你

00:16:29.166 --> 00:16:31.006 A:middle
编写小单元

00:16:31.006 --> 00:16:31.906 A:middle
让你更清楚明白

00:16:31.906 --> 00:16:35.766 A:middle
现在回到我们的例子

00:16:38.046 --> 00:16:39.056 A:middle
我把这个 UI 给我的设计师看了

00:16:39.056 --> 00:16:40.776 A:middle
她非常惊讶

00:16:40.776 --> 00:16:42.156 A:middle
没想到这么少的代码

00:16:42.156 --> 00:16:42.836 A:middle
就能有这些效果

00:16:44.256 --> 00:16:45.806 A:middle
她也提出了一些优化的建议

00:16:47.066 --> 00:16:48.386 A:middle
我们应该把播放和暂停的

00:16:48.386 --> 00:16:49.416 A:middle
过渡变化动画化

00:16:50.746 --> 00:16:52.606 A:middle
幸运的是

00:16:52.606 --> 00:16:54.926 A:middle
这很简单

00:16:54.926 --> 00:16:56.536 A:middle
因为框架追踪了

00:16:56.536 --> 00:16:57.736 A:middle
所有变化了的东西

00:16:58.006 --> 00:16:59.426 A:middle
难以置信

00:16:59.426 --> 00:17:01.776 A:middle
用状态驱动动画

00:17:01.906 --> 00:17:03.026 A:middle
是多么简单强大

00:17:05.336 --> 00:17:06.976 A:middle
用一个动画模块

00:17:06.976 --> 00:17:08.646 A:middle
通过打包改写给绑定

00:17:09.165 --> 00:17:10.646 A:middle
当值改变时

00:17:10.646 --> 00:17:12.906 A:middle
框架会动画这个过渡变化

00:17:13.526 --> 00:17:15.056 A:middle
直到最后的状态 

00:17:15.056 --> 00:17:17.415 A:middle
你都会一直得到正确的动画

00:17:18.965 --> 00:17:20.656 A:middle
如果你想了解更多

00:17:20.656 --> 00:17:22.746 A:middle
关于 SwiftUI 强大的动画和布局系统

00:17:22.746 --> 00:17:24.896 A:middle
以及如何制作优秀 App 的信息

00:17:24.896 --> 00:17:26.715 A:middle
我建议大家看一下

00:17:26.715 --> 00:17:29.616 A:middle
在 SwiftUI 中构建自定义视图这个分会

00:17:30.166 --> 00:17:32.496 A:middle
现在我们已经了解了 State 和 Binding

00:17:32.496 --> 00:17:35.386 A:middle
但是 SwiftUI 还有一些绝活

00:17:35.386 --> 00:17:36.716 A:middle
大家没有看到

00:17:37.136 --> 00:17:38.586 A:middle
为了让大家了解得更多

00:17:38.586 --> 00:17:39.826 A:middle
我现在要请 Raj 上台

00:17:40.276 --> 00:17:40.596 A:middle
Raj

00:17:41.516 --> 00:17:47.500 A:middle
[掌声]

00:17:50.316 --> 00:17:51.026 A:middle
&gt;&gt; 谢谢你 Luca

00:17:51.026 --> 00:17:53.846 A:middle
接下来我会介绍

00:17:53.846 --> 00:17:55.466 A:middle
一些其他工具

00:17:56.056 --> 00:17:57.706 A:middle
在 SwiftUI 中它们可以用来管理数据

00:17:58.816 --> 00:18:00.376 A:middle
听了这个讲演

00:18:00.796 --> 00:18:02.306 A:middle
你就可以设计和构建

00:18:02.306 --> 00:18:05.246 A:middle
稳固的可重复使用的组件

00:18:05.336 --> 00:18:09.716 A:middle
可以应用在各种数据上

00:18:09.866 --> 00:18:11.556 A:middle
大家刚才也看到了

00:18:11.556 --> 00:18:13.986 A:middle
我们有很多有用的工具

00:18:13.986 --> 00:18:15.166 A:middle
可以在 SwiftUI 中处理数据

00:18:15.956 --> 00:18:17.776 A:middle
Luca 已经介绍了一些

00:18:17.776 --> 00:18:19.896 A:middle
比如使用 State

00:18:20.666 --> 00:18:22.536 A:middle
Binding 

00:18:22.536 --> 00:18:23.346 A:middle
甚至只用 Swift Property

00:18:23.346 --> 00:18:25.816 A:middle
我会介绍

00:18:25.816 --> 00:18:27.446 A:middle
剩下的工具

00:18:28.146 --> 00:18:30.036 A:middle
以 SwiftUI 中的外部变化

00:18:30.036 --> 00:18:30.546 A:middle
作为开始

00:18:30.546 --> 00:18:33.496 A:middle
我们现在回到

00:18:33.496 --> 00:18:35.096 A:middle
Luca 刚才为大家展示的图解

00:18:36.206 --> 00:18:38.266 A:middle
在这个图解中

00:18:38.376 --> 00:18:39.886 A:middle
用户和 App 互动

00:18:40.766 --> 00:18:42.616 A:middle
这形成了一个动作

00:18:42.616 --> 00:18:44.176 A:middle
结果是改写了状态

00:18:44.176 --> 00:18:48.346 A:middle
这就生成了

00:18:48.346 --> 00:18:49.946 A:middle
视图的新主体

00:18:49.946 --> 00:18:50.936 A:middle
提供给用户

00:18:52.436 --> 00:18:55.506 A:middle
一些事件从外部被初始化

00:18:55.506 --> 00:18:59.296 A:middle
比如计时器和通知

00:19:03.016 --> 00:19:04.896 A:middle
你的视图是状态的函数

00:19:06.296 --> 00:19:07.926 A:middle
所有的改变

00:19:08.106 --> 00:19:09.366 A:middle
只有一个单一漏斗点

00:19:10.866 --> 00:19:12.666 A:middle
这意味着

00:19:12.666 --> 00:19:14.706 A:middle
SwiftUI 

00:19:14.706 --> 00:19:17.106 A:middle
用响应用户操作的方法

00:19:17.146 --> 00:19:17.976 A:middle
响应外部更改

00:19:20.556 --> 00:19:22.846 A:middle
所以当计时器启动

00:19:22.846 --> 00:19:24.906 A:middle
或者接收到通知时

00:19:24.906 --> 00:19:26.926 A:middle
过程看起来是差不多的

00:19:27.876 --> 00:19:30.126 A:middle
我们创建了一个动作

00:19:30.126 --> 00:19:33.226 A:middle
执行一些状态改写

00:19:33.226 --> 00:19:35.486 A:middle
生成视图的新副本

00:19:35.526 --> 00:19:36.606 A:middle
重新提供给用户

00:19:37.196 --> 00:19:40.276 A:middle
在 SwiftUI 中 

00:19:40.276 --> 00:19:41.766 A:middle
为表述这些外部事件

00:19:41.766 --> 00:19:42.916 A:middle
我们有单一抽象化

00:19:44.046 --> 00:19:45.006 A:middle
它被成为 Publisher

00:19:45.596 --> 00:19:48.876 A:middle
Publisher 来自一个新的

00:19:48.876 --> 00:19:49.926 A:middle
组合框架

00:19:50.876 --> 00:19:53.456 A:middle
Combine 是一个统一声明式 API

00:19:53.456 --> 00:19:56.186 A:middle
随时间处理数据

00:19:57.506 --> 00:19:58.646 A:middle
今天我们

00:19:58.646 --> 00:20:00.106 A:middle
不会细说 Combine

00:20:00.326 --> 00:20:01.966 A:middle
但是大家一定要去看

00:20:01.966 --> 00:20:03.416 A:middle
一些相关的讲解

00:20:03.416 --> 00:20:04.876 A:middle
这样可以了解更多

00:20:06.486 --> 00:20:08.156 A:middle
要达到我们的目的

00:20:08.156 --> 00:20:09.706 A:middle
需记住一点

00:20:09.706 --> 00:20:11.316 A:middle
在 SwiftUI 里用 Publisher 时

00:20:12.186 --> 00:20:13.606 A:middle
它们应该删除主线程

00:20:14.576 --> 00:20:16.606 A:middle
Combine 提供了一种用操作符的简单方法

00:20:16.606 --> 00:20:19.136 A:middle
被称为 Receive On 

00:20:19.746 --> 00:20:21.366 A:middle
想知道更多的话

00:20:21.366 --> 00:20:22.706 A:middle
可以去看 

00:20:22.706 --> 00:20:25.666 A:middle
Combine and Practice 分会

00:20:25.816 --> 00:20:28.346 A:middle
现在我们通过例子来看一下

00:20:28.346 --> 00:20:28.866 A:middle
它是如何运行的

00:20:29.996 --> 00:20:32.566 A:middle
有时候用户

00:20:32.566 --> 00:20:35.026 A:middle
不知道自己听播客听到了哪儿

00:20:35.236 --> 00:20:36.676 A:middle
他们厌倦听年轻的一代

00:20:36.676 --> 00:20:38.966 A:middle
接连好几个小时

00:20:38.966 --> 00:20:41.366 A:middle
大谈特谈牛油果吐司

00:20:42.576 --> 00:20:44.976 A:middle
所以我们要为播客播放器

00:20:44.976 --> 00:20:46.856 A:middle
加一个时间戳

00:20:46.856 --> 00:20:48.356 A:middle
这样用户就知道

00:20:48.356 --> 00:20:48.986 A:middle
自己听到了哪儿

00:20:50.696 --> 00:20:53.596 A:middle
要实现这个效果

00:20:53.886 --> 00:20:55.236 A:middle
我们要加 State 表现当前时间

00:20:56.116 --> 00:21:00.486 A:middle
和描绘该值的文本 

00:21:00.636 --> 00:21:04.366 A:middle
接下来我们会使用 onReceive 修饰符

00:21:05.296 --> 00:21:06.906 A:middle
很方便 我已经构建了一个 publisher 

00:21:06.906 --> 00:21:09.246 A:middle
当前时间一改变

00:21:09.246 --> 00:21:10.346 A:middle
它就会启动

00:21:11.256 --> 00:21:12.746 A:middle
我会使用那个 publisher 

00:21:12.746 --> 00:21:14.936 A:middle
传递给 onReceive 修饰符

00:21:15.776 --> 00:21:17.836 A:middle
另外 我还会给一个闭包

00:21:17.836 --> 00:21:20.216 A:middle
当 publisher 删除时

00:21:20.216 --> 00:21:21.306 A:middle
这个闭包会运行

00:21:22.596 --> 00:21:24.686 A:middle
就是这样

00:21:24.686 --> 00:21:26.416 A:middle
这么做 我们已经给 SwiftUI 

00:21:26.416 --> 00:21:27.806 A:middle
描述了依赖

00:21:28.966 --> 00:21:30.996 A:middle
现在当 currentTime 刷新时

00:21:30.996 --> 00:21:33.226 A:middle
我们会刷新状态

00:21:34.016 --> 00:21:35.876 A:middle
SwiftUI 就会知道

00:21:35.876 --> 00:21:36.666 A:middle
那儿有一个依赖

00:21:37.136 --> 00:21:39.466 A:middle
标签就会自动刷新

00:21:40.056 --> 00:21:42.236 A:middle
就无需费力

00:21:42.316 --> 00:21:43.186 A:middle
去做失效或管理了

00:21:44.516 --> 00:21:50.516 A:middle
[掌声]

00:21:51.016 --> 00:21:52.706 A:middle
我们已经简单说明了

00:21:52.706 --> 00:21:53.796 A:middle
SwiftUI 里的外部变化

00:21:55.006 --> 00:21:56.386 A:middle
接下来我会介绍

00:21:56.386 --> 00:21:57.506 A:middle
外部数据

00:22:01.936 --> 00:22:03.196 A:middle
我们有 BindableObject 协议

00:22:04.566 --> 00:22:06.406 A:middle
BindableObject 是

00:22:06.406 --> 00:22:08.516 A:middle
使用封装了的 测试过的 

00:22:08.856 --> 00:22:10.706 A:middle
你已有的“true”模型的

00:22:10.766 --> 00:22:11.486 A:middle
简便方法

00:22:13.106 --> 00:22:14.966 A:middle
这对教 SwiftUI

00:22:15.456 --> 00:22:17.146 A:middle
你已经架构的引用类型模型

00:22:17.146 --> 00:22:17.936 A:middle
是非常有用的

00:22:19.326 --> 00:22:22.146 A:middle
这是你拥有并需要管理的数据

00:22:23.106 --> 00:22:25.436 A:middle
SwiftUI 只需要知道

00:22:25.436 --> 00:22:28.916 A:middle
如何在这个数据中响应改变

00:22:29.096 --> 00:22:30.876 A:middle
我们换个例子

00:22:32.116 --> 00:22:34.376 A:middle
用户希望

00:22:34.376 --> 00:22:36.366 A:middle
播客可以在他们

00:22:36.366 --> 00:22:38.016 A:middle
所有的设备上同步

00:22:38.016 --> 00:22:39.666 A:middle
我负责添加这个功能

00:22:39.666 --> 00:22:41.696 A:middle
所以我已经开始了

00:22:41.846 --> 00:22:44.116 A:middle
我已经建立了一个模型

00:22:44.116 --> 00:22:45.476 A:middle
现在是时候使用 

00:22:45.476 --> 00:22:47.246 A:middle
我在视图层级里做好的模型

00:22:47.246 --> 00:22:48.636 A:middle
把它带到

00:22:48.636 --> 00:22:49.356 A:middle
我们的播客播放器

00:22:50.306 --> 00:22:52.206 A:middle
看看多么简单

00:22:53.066 --> 00:22:54.776 A:middle
这里是我们搭建的

00:22:54.776 --> 00:22:57.426 A:middle
模型的一个草图

00:22:57.616 --> 00:22:59.406 A:middle
要通过 SwiftUI 用这个模型

00:22:59.406 --> 00:23:01.936 A:middle
我要做的只是

00:23:01.976 --> 00:23:04.726 A:middle
确认它到 BindableObject 协议

00:23:10.056 --> 00:23:12.556 A:middle
用 BindableObject

00:23:12.556 --> 00:23:13.956 A:middle
我们需要提供的只是一个 publisher

00:23:14.856 --> 00:23:17.096 A:middle
这个 publisher 显示

00:23:17.096 --> 00:23:18.386 A:middle
对数据的更改

00:23:19.196 --> 00:23:20.696 A:middle
记住组合 publisher

00:23:20.696 --> 00:23:22.516 A:middle
是我们为表现

00:23:22.516 --> 00:23:23.886 A:middle
对 SwiftUI 外部更改的

00:23:23.886 --> 00:23:25.756 A:middle
单一抽象化

00:23:26.716 --> 00:23:28.186 A:middle
这里 我们会在 didChange property

00:23:28.186 --> 00:23:29.956 A:middle
提供一个 publisher

00:23:30.516 --> 00:23:32.446 A:middle
PassthroughSubject 是一个 publisher

00:23:33.016 --> 00:23:35.966 A:middle
接着 SwiftUI 会订阅这个 publisher

00:23:36.226 --> 00:23:37.786 A:middle
所以它知道什么时候

00:23:37.786 --> 00:23:39.636 A:middle
更新我们的视图层级

00:23:40.186 --> 00:23:43.076 A:middle
在高级操作中

00:23:44.246 --> 00:23:46.796 A:middle
当我们改写模型时

00:23:46.796 --> 00:23:48.666 A:middle
我们只是简单地发送 publisher 请求

00:23:50.086 --> 00:23:52.326 A:middle
现在 注意 为保证正确

00:23:52.676 --> 00:23:54.326 A:middle
不管什么时候 模型一变化

00:23:54.326 --> 00:23:55.766 A:middle
我们就需要这样做

00:23:55.766 --> 00:23:56.986 A:middle
这样视图层级才能保持刷新

00:23:57.826 --> 00:24:00.286 A:middle
幸好 SwiftUI 可以帮助我们

00:24:00.286 --> 00:24:01.336 A:middle
它优雅地应对这些数据

00:24:01.436 --> 00:24:03.936 A:middle
帮我们很好且正确地

00:24:04.106 --> 00:24:05.806 A:middle
实现这个效果

00:24:07.496 --> 00:24:09.346 A:middle
现在我们已经搭建了模型

00:24:09.346 --> 00:24:12.146 A:middle
以及它对 BindableObject 协议的确认

00:24:13.326 --> 00:24:14.796 A:middle
接下来我将向大家展示

00:24:14.796 --> 00:24:16.386 A:middle
如何在视图层级中用模型

00:24:17.466 --> 00:24:19.466 A:middle
还记得之前说的两大原则吗

00:24:20.026 --> 00:24:21.546 A:middle
每一条数据都有一个数据源

00:24:21.546 --> 00:24:23.916 A:middle
当你访问那个数据时

00:24:23.956 --> 00:24:25.986 A:middle
你在上面创建了一个依赖

00:24:26.626 --> 00:24:28.306 A:middle
我们已经创建了数据源

00:24:28.306 --> 00:24:30.676 A:middle
但是我们还没有一个依赖

00:24:31.636 --> 00:24:33.066 A:middle
幸运的是

00:24:33.066 --> 00:24:35.126 A:middle
在你的可绑定对象上创建依赖

00:24:35.126 --> 00:24:36.006 A:middle
是非常简单的

00:24:36.576 --> 00:24:41.526 A:middle
这里有一个非常基础的图解

00:24:41.856 --> 00:24:43.576 A:middle
可以看到我们的视图层级在右侧

00:24:43.576 --> 00:24:45.486 A:middle
是蓝色的

00:24:46.106 --> 00:24:47.466 A:middle
我们的模型在左侧

00:24:47.466 --> 00:24:47.906 A:middle
是绿色的

00:24:49.456 --> 00:24:51.076 A:middle
现在我们连接二者

00:24:51.126 --> 00:24:53.276 A:middle
用 ObjectBinding Property Wrapper

00:24:53.326 --> 00:24:55.236 A:middle
创建一个依赖

00:24:56.756 --> 00:24:58.986 A:middle
我们这么做时

00:24:58.986 --> 00:25:00.506 A:middle
每一个有那个 Property Wrapper 的视图

00:25:00.716 --> 00:25:03.216 A:middle
都取决于我们之前写的模型

00:25:05.296 --> 00:25:07.866 A:middle
就像用 State 一样

00:25:07.866 --> 00:25:09.526 A:middle
当你用 ObjectBinding Property Wrapper

00:25:09.526 --> 00:25:10.916 A:middle
将它添加到视图中时

00:25:10.916 --> 00:25:13.296 A:middle
框架会识别出

00:25:13.296 --> 00:25:14.546 A:middle
那儿有一个依赖

00:25:14.916 --> 00:25:16.786 A:middle
所以在主体中

00:25:16.786 --> 00:25:18.756 A:middle
当你访问那个数据时

00:25:18.836 --> 00:25:21.336 A:middle
我们自动明白什么时候刷新视图

00:25:21.896 --> 00:25:27.236 A:middle
在代码里看起来就像这样

00:25:27.446 --> 00:25:28.936 A:middle
你创建视图时

00:25:28.936 --> 00:25:30.486 A:middle
添加 ObjectBinding Property Wrapper

00:25:30.486 --> 00:25:32.526 A:middle
到你视图里的一个 Property

00:25:33.076 --> 00:25:36.006 A:middle
当你实例化视图时

00:25:36.006 --> 00:25:38.446 A:middle
你只是将引用传递给

00:25:38.446 --> 00:25:40.576 A:middle
你已有的模型

00:25:41.306 --> 00:25:43.996 A:middle
注意 这在视图的实例中 

00:25:43.996 --> 00:25:45.716 A:middle
创建了一个

00:25:45.716 --> 00:25:47.436 A:middle
清楚的依赖

00:25:47.436 --> 00:25:48.976 A:middle
这样很棒

00:25:49.016 --> 00:25:50.666 A:middle
因为每次我要实例化视图时

00:25:50.666 --> 00:25:52.246 A:middle
我都知道模型上

00:25:52.246 --> 00:25:53.946 A:middle
有个依赖

00:25:58.076 --> 00:25:58.936 A:middle
就是这样

00:26:02.676 --> 00:26:04.026 A:middle
每个有 Property Wrapper 的视图

00:26:04.146 --> 00:26:05.806 A:middle
都会自动订阅

00:26:05.806 --> 00:26:07.596 A:middle
BindableObject 的变化

00:26:08.566 --> 00:26:09.936 A:middle
也就意味着我们实现了

00:26:09.936 --> 00:26:10.806 A:middle
依赖自动追踪

00:26:11.156 --> 00:26:13.596 A:middle
又不需要

00:26:13.596 --> 00:26:15.346 A:middle
失效和同步了

00:26:16.516 --> 00:26:22.736 A:middle
[掌声]

00:26:23.236 --> 00:26:24.416 A:middle
这里我想停一下

00:26:24.456 --> 00:26:26.756 A:middle
有一点需要强调 

00:26:26.756 --> 00:26:28.826 A:middle
因为如果用 SwiftUI 

00:26:29.376 --> 00:26:30.536 A:middle
是值类型的话

00:26:30.536 --> 00:26:32.026 A:middle
每次你使用引用类型时

00:26:32.026 --> 00:26:34.066 A:middle
你都应该用 ObjectBinding Property Wrapper

00:26:34.736 --> 00:26:36.486 A:middle
这样当数据改变时 

00:26:36.536 --> 00:26:38.276 A:middle
框架就会知道

00:26:38.376 --> 00:26:40.106 A:middle
然后让你的视图层级随之改变

00:26:40.646 --> 00:26:43.166 A:middle
这就是如何在 BindableObject 上

00:26:43.166 --> 00:26:45.176 A:middle
如何使用 ObjectBinding

00:26:45.426 --> 00:26:46.486 A:middle
创建一个依赖

00:26:47.446 --> 00:26:48.976 A:middle
其实我们还有一个工具

00:26:48.976 --> 00:26:49.966 A:middle
也可以创建

00:26:49.966 --> 00:26:51.106 A:middle
这些依赖

00:26:52.566 --> 00:26:54.726 A:middle
我们可以创建间接依赖

00:26:56.156 --> 00:26:57.756 A:middle
所以我带了一个

00:26:57.756 --> 00:26:58.976 A:middle
和刚才大家看到的图解

00:26:58.976 --> 00:27:01.266 A:middle
很相似的一个图解 

00:27:01.266 --> 00:27:02.146 A:middle
但是这次我们的视图中多了些子类

00:27:02.656 --> 00:27:06.946 A:middle
接下来 我想要引入 Environment 

00:27:08.066 --> 00:27:09.586 A:middle
如果你看了 SwiftUI Essentials 讲解

00:27:09.636 --> 00:27:11.636 A:middle
你就知道

00:27:11.636 --> 00:27:12.936 A:middle
Environment 是非常好的封装

00:27:12.936 --> 00:27:15.316 A:middle
它可以推动数据

00:27:15.316 --> 00:27:17.046 A:middle
一路向下流过视图层级 

00:27:18.196 --> 00:27:19.936 A:middle
使用 Environment Object Modifier

00:27:19.936 --> 00:27:22.766 A:middle
我们可以真正地

00:27:22.766 --> 00:27:28.116 A:middle
把 BindableObject 写入 Environment 

00:27:28.116 --> 00:27:30.166 A:middle
现在 我们的模型在 Environment 里

00:27:30.836 --> 00:27:34.276 A:middle
我们可以用

00:27:34.276 --> 00:27:35.736 A:middle
EnvironmentObject Property Wrapper

00:27:35.736 --> 00:27:37.396 A:middle
在模型上

00:27:39.936 --> 00:27:40.096 A:middle
创建依赖

00:27:40.266 --> 00:27:41.706 A:middle
现在 通过使用这个 

00:27:41.706 --> 00:27:43.086 A:middle
Property Wrapper

00:27:43.086 --> 00:27:44.426 A:middle
我们可以在那个模型上创建依赖

00:27:46.976 --> 00:27:48.376 A:middle
但是不止这样

00:27:49.156 --> 00:27:50.526 A:middle
你可以在很多地方

00:27:50.526 --> 00:27:51.776 A:middle
用到它

00:27:52.756 --> 00:27:55.376 A:middle
所以你可以

00:27:55.376 --> 00:27:56.406 A:middle
在整个层级的

00:27:56.406 --> 00:27:57.896 A:middle
各种视图中使用它 

00:27:57.896 --> 00:27:59.506 A:middle
它们都依赖于同一个模型

00:28:03.166 --> 00:28:05.706 A:middle
一切都会自动

00:28:05.706 --> 00:28:07.206 A:middle
随之更新

00:28:08.586 --> 00:28:09.906 A:middle
你获得了

00:28:09.906 --> 00:28:11.636 A:middle
和 ObjectBinding 相同的 

00:28:11.636 --> 00:28:12.546 A:middle
依赖追踪

00:28:13.066 --> 00:28:15.676 A:middle
你用这些工具 

00:28:15.676 --> 00:28:18.186 A:middle
把依赖描述给 SwiftUI

00:28:18.186 --> 00:28:19.516 A:middle
框架会处理其他的部分

00:28:20.056 --> 00:28:20.596 A:middle
这很棒

00:28:21.516 --> 00:28:27.036 A:middle
[掌声]

00:28:27.536 --> 00:28:29.066 A:middle
这个便捷的方法

00:28:29.066 --> 00:28:30.156 A:middle
就可以更新我们的播客播放器

00:28:31.306 --> 00:28:33.796 A:middle
就像这样

00:28:34.656 --> 00:28:35.766 A:middle
你只需要添加

00:28:35.766 --> 00:28:37.086 A:middle
EnvironmentObject Property Wrapper 到视图

00:28:37.086 --> 00:28:40.126 A:middle
然后在视图

00:28:40.126 --> 00:28:41.486 A:middle
上方的父类中 

00:28:41.486 --> 00:28:43.366 A:middle
只用 EnvironmentObject Modifier 

00:28:43.366 --> 00:28:45.106 A:middle
提供模型

00:28:46.426 --> 00:28:48.466 A:middle
现在 不论什么时候

00:28:48.466 --> 00:28:50.426 A:middle
只要我们在主体中使用播放器

00:28:50.526 --> 00:28:53.346 A:middle
SwiftUI 就会自动替我们更新数据

00:28:53.976 --> 00:28:55.346 A:middle
你可能会想

00:28:56.026 --> 00:28:56.866 A:middle
什么时候用

00:28:56.866 --> 00:28:58.836 A:middle
EnvironmentObject 

00:28:58.836 --> 00:28:59.566 A:middle
什么时候用 ObjectBinding

00:29:02.966 --> 00:29:04.246 A:middle
构建整个 App

00:29:04.246 --> 00:29:06.796 A:middle
但是从出栈到进栈

00:29:06.796 --> 00:29:08.006 A:middle
传递模型

00:29:08.006 --> 00:29:10.006 A:middle
会比较冗长

00:29:11.286 --> 00:29:11.846 A:middle
这时候就需要

00:29:11.846 --> 00:29:13.126 A:middle
EnvironmentObject 了

00:29:14.136 --> 00:29:16.366 A:middle
这真的很方便

00:29:16.696 --> 00:29:18.446 A:middle
不直接在层级间 

00:29:18.446 --> 00:29:19.866 A:middle
传输数据

00:29:21.316 --> 00:29:23.626 A:middle
这里 你可以看到

00:29:23.626 --> 00:29:25.686 A:middle
通过 EnvironmentObject

00:29:25.686 --> 00:29:27.156 A:middle
我们可以间接传送模型

00:29:27.156 --> 00:29:29.026 A:middle
通过视图层级 

00:29:29.026 --> 00:29:30.566 A:middle
也就是说我们不需要

00:29:30.566 --> 00:29:32.006 A:middle
用模型实例化所有的即时视图

00:29:32.006 --> 00:29:33.846 A:middle
到视图层级

00:29:37.816 --> 00:29:39.616 A:middle
所以 Environment 真的是一个很好的方式

00:29:39.616 --> 00:29:41.186 A:middle
用来间接传送各种数据

00:29:41.186 --> 00:29:42.876 A:middle
一路通过

00:29:42.876 --> 00:29:43.626 A:middle
你的视图层级

00:29:44.366 --> 00:29:46.126 A:middle
你可能已经看过

00:29:46.396 --> 00:29:48.956 A:middle
它在重点色

00:29:48.956 --> 00:29:51.356 A:middle
或布局方向等方面的应用

00:29:52.446 --> 00:29:55.036 A:middle
正如 Luca 刚才所说 

00:29:55.036 --> 00:29:57.106 A:middle
数据的形态结构多种多样

00:29:58.276 --> 00:30:00.616 A:middle
值 像是重点色

00:30:00.726 --> 00:30:02.746 A:middle
布局方向

00:30:02.746 --> 00:30:03.226 A:middle
它们只是数据

00:30:04.276 --> 00:30:06.006 A:middle
当你在视图中使用它们时

00:30:06.006 --> 00:30:07.506 A:middle
你就是在它们上面

00:30:07.506 --> 00:30:08.406 A:middle
创建依赖

00:30:09.726 --> 00:30:11.906 A:middle
实际上 Environment 是一个

00:30:12.016 --> 00:30:13.416 A:middle
通用集装箱 

00:30:13.416 --> 00:30:15.186 A:middle
可以用来处理各种

00:30:15.256 --> 00:30:16.376 A:middle
间接数据和依赖

00:30:16.776 --> 00:30:17.956 A:middle
框架自由使用它

00:30:17.956 --> 00:30:20.066 A:middle
为你带来各种特色功能

00:30:20.066 --> 00:30:22.606 A:middle
比如动态类型

00:30:22.606 --> 00:30:23.176 A:middle
和深色模式

00:30:24.156 --> 00:30:25.566 A:middle
你还可以

00:30:25.686 --> 00:30:27.546 A:middle
在预览中使用 Environment  

00:30:27.546 --> 00:30:29.066 A:middle
给重点色或主题等

00:30:29.066 --> 00:30:31.486 A:middle
赋新值

00:30:35.756 --> 00:30:37.406 A:middle
我们已经快速过了一遍

00:30:37.406 --> 00:30:39.646 A:middle
SwiftUI 里

00:30:39.646 --> 00:30:41.226 A:middle
处理数据的强大工具

00:30:42.466 --> 00:30:43.916 A:middle
现在我让大家

00:30:43.916 --> 00:30:46.496 A:middle
对如何使用正确的工具

00:30:46.496 --> 00:30:48.276 A:middle
和如何调配它们

00:30:48.276 --> 00:30:48.836 A:middle
有一个概念

00:30:49.386 --> 00:30:53.276 A:middle
这里主题之一是

00:30:53.526 --> 00:30:55.446 A:middle
每一条数据

00:30:55.446 --> 00:30:57.006 A:middle
都有单一数据源

00:30:57.646 --> 00:30:59.516 A:middle
在 SwiftUI 中 

00:30:59.606 --> 00:31:01.746 A:middle
我们有两种选择 

00:31:01.746 --> 00:31:03.936 A:middle
去处理这些数据源

00:31:04.126 --> 00:31:05.586 A:middle
第一种是 State

00:31:06.606 --> 00:31:08.236 A:middle
State 适合本地视图的数据

00:31:08.386 --> 00:31:10.766 A:middle
一个值类型

00:31:11.766 --> 00:31:14.506 A:middle
由框架 

00:31:14.506 --> 00:31:15.106 A:middle
处理 分配 和创建 

00:31:15.776 --> 00:31:19.836 A:middle
BindableObject 适合

00:31:19.836 --> 00:31:20.916 A:middle
你控制的数据

00:31:22.286 --> 00:31:23.396 A:middle
它适用于给 SwiftUI 展现

00:31:23.526 --> 00:31:25.746 A:middle
外部数据

00:31:25.746 --> 00:31:29.576 A:middle
比如在 onDevice 数据库

00:31:29.786 --> 00:31:32.756 A:middle
这里有你处理的内存

00:31:32.756 --> 00:31:34.306 A:middle
对你已有的模型

00:31:34.306 --> 00:31:35.296 A:middle
很有帮助

00:31:35.926 --> 00:31:38.756 A:middle
现在我们已经了解了

00:31:38.756 --> 00:31:40.866 A:middle
数据源 接下来

00:31:40.866 --> 00:31:42.306 A:middle
我想介绍一下

00:31:42.306 --> 00:31:43.486 A:middle
构建可重复使用的组件

00:31:44.056 --> 00:31:46.456 A:middle
SwiftUI 的一个优点是

00:31:46.456 --> 00:31:48.866 A:middle
视图是

00:31:48.866 --> 00:31:49.976 A:middle
低成本阻塞

00:31:49.976 --> 00:31:52.786 A:middle
这意味着

00:31:52.946 --> 00:31:54.466 A:middle
我们不需要

00:31:54.756 --> 00:31:57.576 A:middle
在架构和性能之间做折中

00:31:58.246 --> 00:31:59.566 A:middle
你可以搭建

00:31:59.566 --> 00:32:00.996 A:middle
你想搭建的架构

00:32:01.206 --> 00:32:03.466 A:middle
同时也能获得很好的性能

00:32:03.626 --> 00:32:04.566 A:middle
你不需要

00:32:04.566 --> 00:32:05.666 A:middle
权衡折中

00:32:06.826 --> 00:32:09.316 A:middle
通过 SwiftUI 你可以集中精力于

00:32:09.436 --> 00:32:10.786 A:middle
让你的视图成为

00:32:10.786 --> 00:32:11.906 A:middle
可重复使用的组件

00:32:12.446 --> 00:32:14.606 A:middle
当你这么做时

00:32:14.816 --> 00:32:16.646 A:middle
你可能会注意到

00:32:16.646 --> 00:32:17.966 A:middle
在视图中使用数据时

00:32:17.966 --> 00:32:19.896 A:middle
你也许不需要

00:32:19.896 --> 00:32:20.666 A:middle
改写它

00:32:21.326 --> 00:32:24.106 A:middle
所以当你可以不管它时

00:32:24.686 --> 00:32:27.106 A:middle
只读路径是更好的选择

00:32:28.236 --> 00:32:30.336 A:middle
在这一点上 我们有 Swift Property

00:32:30.336 --> 00:32:31.826 A:middle
和 Environment 

00:32:32.766 --> 00:32:34.566 A:middle
因为视图在 SwiftUI 中是

00:32:34.566 --> 00:32:36.396 A:middle
值类型

00:32:36.566 --> 00:32:37.606 A:middle
框架可以自动确定

00:32:37.606 --> 00:32:39.126 A:middle
数据什么时候改变

00:32:39.126 --> 00:32:43.146 A:middle
视图也会随之变化

00:32:43.146 --> 00:32:44.596 A:middle
总的来说 你应该倾向于选择

00:32:44.596 --> 00:32:46.896 A:middle
不可改写访问

00:32:46.956 --> 00:32:48.306 A:middle
但是有时你确实需要改写值

00:32:49.626 --> 00:32:51.596 A:middle
这时我们有 Binding

00:32:52.256 --> 00:32:55.756 A:middle
正如 Luca 刚才告诉大家的

00:32:55.756 --> 00:32:58.186 A:middle
Binding 是数据的第一类对象

00:32:59.126 --> 00:33:00.976 A:middle
它可以让你的组件

00:33:00.976 --> 00:33:03.756 A:middle
在不拥有的情况下

00:33:03.756 --> 00:33:05.276 A:middle
读写数据

00:33:05.276 --> 00:33:07.256 A:middle
这对于可重复使用来说很有利

00:33:08.226 --> 00:33:09.576 A:middle
实际上 你可以

00:33:09.576 --> 00:33:10.586 A:middle
绑定到很多不同的

00:33:10.586 --> 00:33:11.596 A:middle
数据表现

00:33:12.566 --> 00:33:13.836 A:middle
今天我们将展示如何

00:33:13.836 --> 00:33:15.476 A:middle
绑定到 State

00:33:15.476 --> 00:33:16.796 A:middle
和如何绑定到

00:33:16.796 --> 00:33:17.486 A:middle
ObjectBinding

00:33:18.096 --> 00:33:20.616 A:middle
实际上 你也可以

00:33:20.616 --> 00:33:21.756 A:middle
绑定另一个绑定

00:33:22.926 --> 00:33:24.266 A:middle
你只需要用

00:33:24.266 --> 00:33:25.846 A:middle
我们之前展示的

00:33:25.846 --> 00:33:26.406 A:middle
美元符号前缀

00:33:26.406 --> 00:33:28.266 A:middle
它可以让你

00:33:28.266 --> 00:33:29.596 A:middle
从其他工具之一里

00:33:29.596 --> 00:33:30.346 A:middle
生成一个绑定

00:33:30.346 --> 00:33:33.716 A:middle
我想停一下让大家欣赏

00:33:33.716 --> 00:33:35.066 A:middle
这是多么有用

00:33:35.946 --> 00:33:37.926 A:middle
刚才 Luca 展示了

00:33:37.926 --> 00:33:39.316 A:middle
我们在 SwiftUI 里提供的组件

00:33:39.376 --> 00:33:41.386 A:middle
它们运行在 Binding 上

00:33:42.436 --> 00:33:44.286 A:middle
接下来以 Toggle 为例

00:33:45.296 --> 00:33:47.256 A:middle
Toggle 把绑定给到 Boolean

00:33:48.456 --> 00:33:49.856 A:middle
但是 SwiftUI 中数据的美观性在于

00:33:49.856 --> 00:33:51.906 A:middle
Toggle 不需要知道

00:33:51.906 --> 00:33:55.036 A:middle
或不需要在意

00:33:55.036 --> 00:33:56.736 A:middle
Boolean 在哪儿或来自哪儿

00:33:57.476 --> 00:33:59.446 A:middle
它要做的只是

00:33:59.446 --> 00:34:01.906 A:middle
知道如何读取和改变值

00:34:02.916 --> 00:34:04.106 A:middle
Binding 是一个工具 

00:34:04.106 --> 00:34:05.926 A:middle
它可以封装这些操作

00:34:06.246 --> 00:34:08.576 A:middle
而且同时

00:34:08.576 --> 00:34:09.856 A:middle
不需要考虑 Toggle

00:34:10.456 --> 00:34:14.255 A:middle
这是在 SwiftUI 中使用数据的

00:34:14.255 --> 00:34:15.466 A:middle
真正魅力所在

00:34:16.286 --> 00:34:17.996 A:middle
你可以做到非常准确

00:34:18.866 --> 00:34:20.835 A:middle
而且不需要担心其他的

00:34:23.876 --> 00:34:25.346 A:middle
你会发现

00:34:25.346 --> 00:34:26.826 A:middle
在我讲解

00:34:26.826 --> 00:34:28.076 A:middle
搭建可重复使用组件的时候

00:34:28.076 --> 00:34:29.036 A:middle
我实际并没怎么提及 State

00:34:29.356 --> 00:34:32.416 A:middle
State 被卡在你的

00:34:32.416 --> 00:34:33.706 A:middle
视图以及它的子类里

00:34:34.696 --> 00:34:36.846 A:middle
所以如果你的组件需要

00:34:36.846 --> 00:34:38.045 A:middle
操作一个值

00:34:38.156 --> 00:34:40.146 A:middle
一个来自外部或其他地方的值

00:34:40.795 --> 00:34:43.426 A:middle
State 也许不合适

00:34:44.235 --> 00:34:46.356 A:middle
对于原型开发第一步来说

00:34:46.356 --> 00:34:47.366 A:middle
State 是一个很好的工具

00:34:47.366 --> 00:34:49.386 A:middle
正如你今天看到的

00:34:49.386 --> 00:34:50.116 A:middle
它在我们播客播放器上的表现一样

00:34:51.196 --> 00:34:53.126 A:middle
但是大部分情况下

00:34:53.346 --> 00:34:55.036 A:middle
你的数据是存在于

00:34:55.226 --> 00:34:55.666 A:middle
SwiftUI 之外的

00:34:57.386 --> 00:34:59.096 A:middle
比如数据可能

00:34:59.096 --> 00:35:00.936 A:middle
在一个数据库里 

00:35:00.936 --> 00:35:02.266 A:middle
这可能就需要其他东西来展现它

00:35:02.586 --> 00:35:04.036 A:middle
比如 BindableObject

00:35:04.726 --> 00:35:07.266 A:middle
所以如果你要用 State 的话

00:35:07.266 --> 00:35:09.376 A:middle
请退一步

00:35:09.376 --> 00:35:12.066 A:middle
考虑一下

00:35:12.106 --> 00:35:13.886 A:middle
数据真的需要

00:35:13.886 --> 00:35:14.346 A:middle
被视图拥有吗

00:35:15.526 --> 00:35:17.806 A:middle
也许数据 状态

00:35:17.856 --> 00:35:19.166 A:middle
需要被提到父类

00:35:19.166 --> 00:35:20.616 A:middle
就像刚才 Loca 展示的那样

00:35:20.616 --> 00:35:23.206 A:middle
或者数据可以

00:35:23.206 --> 00:35:24.736 A:middle
被外部源

00:35:24.956 --> 00:35:27.486 A:middle
通过 BindableObject 展现

00:35:27.966 --> 00:35:31.076 A:middle
所以使用数据时

00:35:31.076 --> 00:35:33.546 A:middle
需要非常小心

00:35:33.546 --> 00:35:34.306 A:middle
但它确实有它的优点

00:35:35.566 --> 00:35:37.196 A:middle
State 的一大用途是

00:35:37.436 --> 00:35:40.066 A:middle
我们框架里有按钮

00:35:41.486 --> 00:35:43.286 A:middle
按钮用 State 追踪

00:35:43.576 --> 00:35:44.916 A:middle
用户是否按下了按钮

00:35:44.916 --> 00:35:46.656 A:middle
然后以合适的方式高亮它

00:35:47.676 --> 00:35:48.796 A:middle
通过 State 处理按钮的好处是

00:35:48.796 --> 00:35:51.286 A:middle
当你创建了一个按钮

00:35:51.286 --> 00:35:52.626 A:middle
你不需要再考虑

00:35:52.626 --> 00:35:54.656 A:middle
高亮状态

00:35:55.726 --> 00:35:58.366 A:middle
数据真正

00:35:58.606 --> 00:36:01.336 A:middle
归按钮所有

00:36:01.506 --> 00:36:02.566 A:middle
所以当你要用 State 时

00:36:02.566 --> 00:36:04.816 A:middle
你需要考虑的是

00:36:04.816 --> 00:36:05.556 A:middle
情况是否和按钮一样

00:36:06.256 --> 00:36:07.516 A:middle
如果一样的话

00:36:07.516 --> 00:36:08.036 A:middle
State 或许是个很好的工具

00:36:08.906 --> 00:36:10.776 A:middle
如果情况不一样

00:36:10.776 --> 00:36:12.066 A:middle
那你就要考虑使用其他工具了

00:36:12.066 --> 00:36:13.656 A:middle
我们刚才也为大家展示了

00:36:13.656 --> 00:36:14.236 A:middle
这些 SwiftUI 中的工具

00:36:17.536 --> 00:36:18.946 A:middle
这就是如何用 SwiftUI 

00:36:18.946 --> 00:36:20.016 A:middle
构建可重复使用组件

00:36:20.686 --> 00:36:23.196 A:middle
我们在这里向大家展示的是

00:36:23.196 --> 00:36:25.246 A:middle
对所有类型的软件都适用的

00:36:25.246 --> 00:36:26.386 A:middle
普遍情况

00:36:27.606 --> 00:36:29.156 A:middle
每个软件都有数据

00:36:30.076 --> 00:36:32.126 A:middle
而且每个软件都有

00:36:32.176 --> 00:36:33.126 A:middle
数据访问

00:36:34.296 --> 00:36:36.036 A:middle
仔细了解你的数据

00:36:36.036 --> 00:36:38.196 A:middle
尽量减少

00:36:38.196 --> 00:36:40.396 A:middle
数据源

00:36:40.396 --> 00:36:42.356 A:middle
构建可重复使用组件

00:36:42.356 --> 00:36:44.986 A:middle
你可以消除一整级的 Bug 

00:36:45.646 --> 00:36:48.426 A:middle
使用 SwiftUI 时

00:36:49.016 --> 00:36:50.526 A:middle
应用这些观念

00:36:50.526 --> 00:36:52.596 A:middle
会非常简单

00:36:52.676 --> 00:36:54.096 A:middle
因为我们已经把它们

00:36:54.146 --> 00:36:54.556 A:middle
应用在框架里了

00:36:57.436 --> 00:36:58.686 A:middle
我们还有很多关于

00:36:58.686 --> 00:37:00.766 A:middle
SwiftUI 的讲解

00:37:00.766 --> 00:37:04.106 A:middle
我建议大家去看一下所有的相关介绍

00:37:04.306 --> 00:37:07.146 A:middle
这将会改变你搭建 App 的方式

00:37:08.096 --> 00:37:08.746 A:middle
谢谢大家

00:37:09.516 --> 00:37:15.500 A:middle
[掌声]

